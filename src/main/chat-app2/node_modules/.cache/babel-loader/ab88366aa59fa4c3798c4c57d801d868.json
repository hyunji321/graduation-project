{"ast":null,"code":"import _slicedToArray from \"C:/Users/\\uC774\\uACBD\\uBBFC/IdeaProjects/sendbird-uikit-whatsapp-sample/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useState, useLayoutEffect, useEffect } from 'react';\nfunction getMentionNodes(root) {\n  if (root) {\n    var mentions = root.querySelectorAll(\"[data-sb-mention='true']\");\n    var mentionsArray = Array.from(mentions);\n    return mentionsArray;\n  }\n  return [];\n}\n\n/**\n * This is a dirty way to get the mentions given DOM node\n */\nfunction useDirtyGetMentions(_ref, _ref2) {\n  var ref = _ref.ref;\n  var logger = _ref2.logger;\n  // Select the node that will be observed for mutations\n  var targetNode = ref.current;\n  var _useState = useState([]),\n    _useState2 = _slicedToArray(_useState, 2),\n    mentionNodes = _useState2[0],\n    setMentionNodes = _useState2[1];\n\n  // to get the initial mentions\n  useLayoutEffect(function () {\n    if (targetNode) {\n      var mentions = getMentionNodes(targetNode);\n      setMentionNodes(mentions);\n    }\n  }, [targetNode]);\n  useEffect(function () {\n    // Options for the observer (which mutations to observe)\n    var config = {\n      childList: true,\n      subtree: true\n    };\n\n    // Callback function to execute when mutations are observed\n    var callback = function callback(mutationList) {\n      var hasMutation = mutationList.length > 0;\n      if (hasMutation) {\n        setMentionNodes(getMentionNodes(targetNode));\n      }\n    };\n\n    // Create an observer instance linked to the callback function\n    var observer = new MutationObserver(callback);\n    if (targetNode) {\n      // Start observing the target node for configured mutations\n      observer.observe(targetNode, config);\n      logger.info('useDirtyGetMentions: observer started', {\n        observer: observer,\n        config: config\n      });\n    }\n    return function () {\n      try {\n        observer.disconnect();\n        logger.info('useDirtyGetMentions: observer disconnected', {\n          observer: observer\n        });\n      } catch (error) {\n        logger.error('useDirtyGetMentions: observer disconnect failed', {\n          observer: observer\n        });\n      }\n    };\n  }, [targetNode]);\n  return mentionNodes;\n}\nexport { useDirtyGetMentions as u };","map":{"version":3,"mappings":";;AAAO,SAASA,eAAeA,CAACC,IAAiB,EAAa;EAC5D,IAAIA,IAAI,EAAE;IACR,IAAMC,QAAQ,GAAGD,IAAI,CAACE,gBAAgB,CAAC,0BAA0B,CAAC;IAClE,IAAMC,aAAa,GAAGC,KAAK,CAACC,IAAI,CAACJ,QAAQ,CAAC;IAC1C,OAAOE,aAAa;EACtB;EACA,OAAO,EAAE;AACX;;ACMA;AACA;AACA;AACO,SAASG,mBAAmBA,cAIlB;EAAA,IAHfC,MACcC,KADdD;EACc,IACdE,SACaC,MADbD;EAEA;EACA,IAAME,UAAU,GAAGJ,GAAG,CAACK,OAAsB;EAC7C,gBAAwCC,QAAQ,CAAY,EAAE,CAAC;IAAA;IAAxDC,YAAY;IAAEC,eAAe;;EAEpC;EACAC,eAAe,CAAC,YAAM;IACpB,IAAIL,UAAU,EAAE;MACd,IAAMV,QAAQ,GAAGF,eAAe,CAACY,UAAU,CAAC;MAC5CI,eAAe,CAACd,QAAQ,CAAC;IAC3B;EACF,CAAC,EAAE,CAACU,UAAU,CAAC,CAAC;EAEhBM,SAAS,CAAC,YAAM;IACd;IACA,IAAMC,MAAM,GAAG;MAAEC,SAAS,EAAE,IAAI;MAAEC,OAAO,EAAE;KAAM;;IAEjD;IACA,IAAMC,QAAQ,GAAIC,SAAZD,QAAQ,CAAIC,YAA8B,EAAW;MACzD,IAAMC,WAAW,GAAGD,YAAY,CAACE,MAAM,GAAG,CAAC;MAC3C,IAAID,WAAW,EAAE;QACfR,eAAe,CAAChB,eAAe,CAACY,UAAU,CAAC,CAAC;MAC9C;KACD;;IAED;IACA,IAAMc,QAAQ,GAAG,IAAIC,gBAAgB,CAACL,QAAQ,CAAC;IAE/C,IAAIV,UAAU,EAAE;MACd;MACAc,QAAQ,CAACE,OAAO,CAAChB,UAAU,EAAEO,MAAM,CAAC;MACpCT,MAAM,CAACmB,IAAI,CAAC,uCAAuC,EAAE;QAAEH,QAAQ,EAARA,QAAQ;QAAEP;MAAO,CAAC,CAAC;IAC5E;IAEA,OAAO,YAAM;MACX,IAAI;QACFO,QAAQ,CAACI,UAAU,EAAE;QACrBpB,MAAM,CAACmB,IAAI,CAAC,4CAA4C,EAAE;UAAEH;QAAS,CAAC,CAAC;OACxE,CAAC,OAAOK,KAAK,EAAE;QACdrB,MAAM,CAACqB,KAAK,CAAC,iDAAiD,EAAE;UAAEL;QAAS,CAAC,CAAC;MAC/E;KACD;EACH,CAAC,EAAE,CAACd,UAAU,CAAC,CAAC;EAChB,OAAOG,YAAY;AACrB","names":["getMentionNodes","root","mentions","querySelectorAll","mentionsArray","Array","from","useDirtyGetMentions","ref","_ref","logger","_ref2","targetNode","current","useState","mentionNodes","setMentionNodes","useLayoutEffect","useEffect","config","childList","subtree","callback","mutationList","hasMutation","length","observer","MutationObserver","observe","info","disconnect","error"],"sources":["C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Message\\utils\\getMentionNodes.ts","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Message\\hooks\\useDirtyGetMentions.ts"],"sourcesContent":["export function getMentionNodes(root: HTMLElement): Element[] {\n  if (root) {\n    const mentions = root.querySelectorAll(\"[data-sb-mention='true']\");\n    const mentionsArray = Array.from(mentions);\n    return mentionsArray;\n  }\n  return [];\n}\n","import { useEffect, useLayoutEffect, useState } from 'react';\n\nimport { Logger } from '../../../lib/SendbirdState';\nimport { getMentionNodes } from '../utils/getMentionNodes';\n\ninterface DynamicParams {\n  ref: React.RefObject<HTMLElement>;\n}\n\ninterface StaticParams {\n  logger: Logger;\n}\n\n/**\n * This is a dirty way to get the mentions given DOM node\n */\nexport function useDirtyGetMentions({\n  ref,\n}: DynamicParams, {\n  logger,\n}: StaticParams) {\n  // Select the node that will be observed for mutations\n  const targetNode = ref.current as HTMLElement;\n  const [mentionNodes, setMentionNodes] = useState<Element[]>([]);\n\n  // to get the initial mentions\n  useLayoutEffect(() => {\n    if (targetNode) {\n      const mentions = getMentionNodes(targetNode);\n      setMentionNodes(mentions);\n    }\n  }, [targetNode]);\n\n  useEffect(() => {\n    // Options for the observer (which mutations to observe)\n    const config = { childList: true, subtree: true };\n\n    // Callback function to execute when mutations are observed\n    const callback = (mutationList: MutationRecord[]): void => {\n      const hasMutation = mutationList.length > 0;\n      if (hasMutation) {\n        setMentionNodes(getMentionNodes(targetNode));\n      }\n    };\n\n    // Create an observer instance linked to the callback function\n    const observer = new MutationObserver(callback);\n\n    if (targetNode) {\n      // Start observing the target node for configured mutations\n      observer.observe(targetNode, config);\n      logger.info('useDirtyGetMentions: observer started', { observer, config });\n    }\n\n    return () => {\n      try {\n        observer.disconnect();\n        logger.info('useDirtyGetMentions: observer disconnected', { observer });\n      } catch (error) {\n        logger.error('useDirtyGetMentions: observer disconnect failed', { observer });\n      }\n    };\n  }, [targetNode]);\n  return mentionNodes;\n}\n"]},"metadata":{},"sourceType":"module"}