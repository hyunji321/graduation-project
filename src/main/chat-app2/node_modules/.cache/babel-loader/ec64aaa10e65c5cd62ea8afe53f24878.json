{"ast":null,"code":"import React__default, { useState, useEffect, useCallback, useContext, createContext } from 'react';\nimport { B as BROWSER_SUPPORT_MIME_TYPE_LIST, h as VOICE_RECORDER_AUDIO_BITS, b as VOICE_MESSAGE_FILE_NAME, c as VOICE_MESSAGE_MIME_TYPE } from '../consts-95d8566e.js';\nimport useSendbirdStateContext from '../useSendbirdStateContext.js';\nimport '../withSendbird.js';\nimport '../_rollupPluginBabelHelpers-6bb0305c.js';\n\n// Input props of VoiceRecorder\n\n// Output of VoiceRecorder\n\nconst noop = () => {/* noop */};\nconst Context = /*#__PURE__*/createContext({\n  start: noop,\n  stop: noop,\n  isRecordable: false\n});\nconst VoiceRecorderProvider = props => {\n  var _BROWSER_SUPPORT_MIME;\n  const {\n    children\n  } = props;\n  const {\n    config\n  } = useSendbirdStateContext();\n  const {\n    logger,\n    isVoiceMessageEnabled\n  } = config;\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [isRecordable, setIsRecordable] = useState(false);\n  const browserSupportMimeType = (_BROWSER_SUPPORT_MIME = BROWSER_SUPPORT_MIME_TYPE_LIST.find(mimeType => MediaRecorder.isTypeSupported(mimeType))) !== null && _BROWSER_SUPPORT_MIME !== void 0 ? _BROWSER_SUPPORT_MIME : '';\n  if (!browserSupportMimeType) {\n    logger.error('VoiceRecorder: Browser does not support mimeType', {\n      mimmeTypes: BROWSER_SUPPORT_MIME_TYPE_LIST\n    });\n  }\n  const [webAudioUtils, setWebAudioUtils] = useState(null);\n  useEffect(() => {\n    if (isVoiceMessageEnabled && !webAudioUtils) {\n      import('../WebAudioUtils-6df19fcc.js').then(data => {\n        setWebAudioUtils(data);\n      });\n    }\n  }, []);\n  const start = useCallback(eventHandler => {\n    var _navigator, _navigator$mediaDevic, _navigator$mediaDevic2;\n    if (isVoiceMessageEnabled && !webAudioUtils) {\n      logger.error('VoiceRecorder: Recording audio processor is being loaded.');\n      return;\n    }\n    logger.info('VoiceRecorder: Start recording.');\n    if (mediaRecorder) {\n      stop();\n      logger.info('VoiceRecorder: Previous mediaRecorder is stopped.');\n    }\n    (_navigator = navigator) === null || _navigator === void 0 ? void 0 : (_navigator$mediaDevic = _navigator.mediaDevices) === null || _navigator$mediaDevic === void 0 ? void 0 : (_navigator$mediaDevic2 = _navigator$mediaDevic.getUserMedia) === null || _navigator$mediaDevic2 === void 0 ? void 0 : _navigator$mediaDevic2.call(_navigator$mediaDevic, {\n      audio: true\n    }).then(stream => {\n      logger.info('VoiceRecorder: Succeeded getting media stream.', stream);\n      setIsRecordable(true);\n      const mediaRecorder = new MediaRecorder(stream, {\n        mimeType: browserSupportMimeType,\n        audioBitsPerSecond: VOICE_RECORDER_AUDIO_BITS\n      });\n      mediaRecorder.ondataavailable = e => {\n        var _stream$getAudioTrack, _stream$getAudioTrack2, _stream$getAudioTrack3;\n        // when recording stops\n        logger.info('VoiceRecorder: Succeeded getting an available data.', e.data);\n        const audioFile = new File([e.data], VOICE_MESSAGE_FILE_NAME, {\n          lastModified: new Date().getTime(),\n          type: VOICE_MESSAGE_MIME_TYPE\n        });\n        webAudioUtils === null || webAudioUtils === void 0 ? void 0 : webAudioUtils.downsampleToWav(audioFile, buffer => {\n          const mp3Buffer = webAudioUtils === null || webAudioUtils === void 0 ? void 0 : webAudioUtils.encodeMp3(buffer);\n          const mp3blob = new Blob(mp3Buffer, {\n            type: VOICE_MESSAGE_MIME_TYPE\n          });\n          const convertedAudioFile = new File([mp3blob], VOICE_MESSAGE_FILE_NAME, {\n            lastModified: new Date().getTime(),\n            type: VOICE_MESSAGE_MIME_TYPE\n          });\n          eventHandler === null || eventHandler === void 0 ? void 0 : eventHandler.onRecordingEnded(convertedAudioFile);\n          logger.info('VoiceRecorder: Succeeded converting audio file.', convertedAudioFile);\n        });\n        stream === null || stream === void 0 ? void 0 : (_stream$getAudioTrack = stream.getAudioTracks) === null || _stream$getAudioTrack === void 0 ? void 0 : (_stream$getAudioTrack2 = (_stream$getAudioTrack3 = _stream$getAudioTrack.call(stream)).forEach) === null || _stream$getAudioTrack2 === void 0 ? void 0 : _stream$getAudioTrack2.call(_stream$getAudioTrack3, track => track === null || track === void 0 ? void 0 : track.stop());\n        setIsRecordable(false);\n      };\n      mediaRecorder === null || mediaRecorder === void 0 ? void 0 : mediaRecorder.start();\n      setMediaRecorder(mediaRecorder);\n      eventHandler === null || eventHandler === void 0 ? void 0 : eventHandler.onRecordingStarted();\n    }).catch(err => {\n      logger.error('VoiceRecorder: Failed getting media stream.', err);\n      setMediaRecorder(null);\n    });\n  }, [mediaRecorder, webAudioUtils]);\n  const stop = useCallback(() => {\n    // Stop recording\n    mediaRecorder === null || mediaRecorder === void 0 ? void 0 : mediaRecorder.stop();\n    setMediaRecorder(null);\n    setIsRecordable(false);\n    logger.info('VoiceRecorder: Stop recording.');\n  }, [mediaRecorder]);\n  return /*#__PURE__*/React__default.createElement(Context.Provider, {\n    value: {\n      start,\n      stop,\n      isRecordable\n    }\n  }, children);\n};\nconst useVoiceRecorderContext = () => useContext(Context);\nvar index = {\n  VoiceRecorderProvider,\n  useVoiceRecorderContext\n};\nexport { VoiceRecorderProvider, index as default, useVoiceRecorderContext };","map":{"version":3,"mappings":"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","names":["noop","Context","createContext","start","stop","isRecordable","VoiceRecorderProvider","props","children","config","useSendbirdStateContext","logger","isVoiceMessageEnabled","mediaRecorder","setMediaRecorder","useState","setIsRecordable","browserSupportMimeType","BROWSER_SUPPORT_MIME_TYPE_LIST","find","mimeType","MediaRecorder","isTypeSupported","error","mimmeTypes","webAudioUtils","setWebAudioUtils","useEffect","then","data","useCallback","eventHandler","info","_navigator","mediaDevices","_navigator$mediaDevic","getUserMedia","_navigator$mediaDevic2","audio","stream","audioBitsPerSecond","VOICE_RECORDER_AUDIO_BITS","ondataavailable","e","audioFile","File","VOICE_MESSAGE_FILE_NAME","lastModified","Date","getTime","type","VOICE_MESSAGE_MIME_TYPE","downsampleToWav","buffer","mp3Buffer","encodeMp3","mp3blob","Blob","convertedAudioFile","onRecordingEnded","getAudioTracks","forEach","_stream$getAudioTrack2","track","onRecordingStarted","catch","err","React","Provider","value","useVoiceRecorderContext","useContext"],"sources":["C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\hooks\\VoiceRecorder\\index.tsx"],"sourcesContent":["import React, { createContext, useCallback, useContext, useEffect, useState } from 'react';\nimport {\n  BROWSER_SUPPORT_MIME_TYPE_LIST,\n  VOICE_MESSAGE_FILE_NAME,\n  VOICE_MESSAGE_MIME_TYPE,\n  VOICE_RECORDER_AUDIO_BITS,\n} from '../../utils/consts';\nimport useSendbirdStateContext from '../useSendbirdStateContext';\n\n// Input props of VoiceRecorder\nexport interface VoiceRecorderProps {\n  children: React.ReactElement;\n}\n\nexport interface VoiceRecorderEventHandler {\n  onRecordingStarted?: () => void;\n  onRecordingEnded?: (props: null | File) => void;\n}\n\n// Output of VoiceRecorder\nexport interface VoiceRecorderContext {\n  start: (eventHandler?: VoiceRecorderEventHandler) => void,\n  stop: () => void,\n  isRecordable: boolean;\n}\nconst noop = () => { /* noop */ };\nconst Context = createContext<VoiceRecorderContext>({\n  start: noop,\n  stop: noop,\n  isRecordable: false,\n});\n\nexport const VoiceRecorderProvider = (props: VoiceRecorderProps): React.ReactElement => {\n  const { children } = props;\n  const { config } = useSendbirdStateContext();\n  const { logger, isVoiceMessageEnabled } = config;\n  const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder>(null);\n  const [isRecordable, setIsRecordable] = useState<boolean>(false);\n\n  const browserSupportMimeType = BROWSER_SUPPORT_MIME_TYPE_LIST.find((mimeType) => MediaRecorder.isTypeSupported(mimeType)) ?? '';\n  if (!browserSupportMimeType) {\n    logger.error('VoiceRecorder: Browser does not support mimeType', { mimmeTypes: BROWSER_SUPPORT_MIME_TYPE_LIST });\n  }\n\n  const [webAudioUtils, setWebAudioUtils] = useState(null);\n  useEffect(() => {\n    if (isVoiceMessageEnabled && !webAudioUtils) {\n      import('./WebAudioUtils').then((data) => {\n        setWebAudioUtils(data);\n      });\n    }\n  }, []);\n\n  const start = useCallback((eventHandler: VoiceRecorderEventHandler): void => {\n    if (isVoiceMessageEnabled && !webAudioUtils) {\n      logger.error('VoiceRecorder: Recording audio processor is being loaded.');\n      return;\n    }\n\n    logger.info('VoiceRecorder: Start recording.');\n    if (mediaRecorder) {\n      stop();\n      logger.info('VoiceRecorder: Previous mediaRecorder is stopped.');\n    }\n    navigator?.mediaDevices?.getUserMedia?.({ audio: true })\n      .then((stream) => {\n        logger.info('VoiceRecorder: Succeeded getting media stream.', stream);\n        setIsRecordable(true);\n        const mediaRecorder = new MediaRecorder(stream, {\n          mimeType: browserSupportMimeType,\n          audioBitsPerSecond: VOICE_RECORDER_AUDIO_BITS,\n        });\n        mediaRecorder.ondataavailable = (e) => { // when recording stops\n          logger.info('VoiceRecorder: Succeeded getting an available data.', e.data);\n          const audioFile = new File([e.data], VOICE_MESSAGE_FILE_NAME, {\n            lastModified: new Date().getTime(),\n            type: VOICE_MESSAGE_MIME_TYPE,\n          });\n          webAudioUtils?.downsampleToWav(audioFile, (buffer) => {\n            const mp3Buffer = webAudioUtils?.encodeMp3(buffer);\n            const mp3blob = new Blob(mp3Buffer, { type: VOICE_MESSAGE_MIME_TYPE });\n            const convertedAudioFile = new File([mp3blob], VOICE_MESSAGE_FILE_NAME, {\n              lastModified: new Date().getTime(),\n              type: VOICE_MESSAGE_MIME_TYPE,\n            });\n            eventHandler?.onRecordingEnded(convertedAudioFile);\n            logger.info('VoiceRecorder: Succeeded converting audio file.', convertedAudioFile);\n          });\n          stream?.getAudioTracks?.().forEach?.(track => track?.stop());\n          setIsRecordable(false);\n        };\n        mediaRecorder?.start();\n        setMediaRecorder(mediaRecorder);\n        eventHandler?.onRecordingStarted();\n      })\n      .catch((err) => {\n        logger.error('VoiceRecorder: Failed getting media stream.', err);\n        setMediaRecorder(null);\n      });\n  }, [mediaRecorder, webAudioUtils]);\n\n  const stop = useCallback((): void => {\n    // Stop recording\n    mediaRecorder?.stop();\n    setMediaRecorder(null);\n    setIsRecordable(false);\n    logger.info('VoiceRecorder: Stop recording.');\n  }, [mediaRecorder]);\n\n  return (\n    <Context.Provider value={{\n      start,\n      stop,\n      isRecordable,\n    }}>\n      {children}\n    </Context.Provider>\n  );\n};\n\nexport const useVoiceRecorderContext = (): VoiceRecorderContext => useContext(Context);\n\nexport default {\n  VoiceRecorderProvider,\n  useVoiceRecorderContext,\n};\n"]},"metadata":{},"sourceType":"module"}