{"ast":null,"code":"import { useState, useEffect, useCallback } from 'react';\nimport { useVoiceRecorderContext } from './context.js';\nimport useSendbirdStateContext from '../useSendbirdStateContext.js';\nimport '../consts-95d8566e.js';\nimport '../withSendbird.js';\nimport '../_rollupPluginBabelHelpers-6bb0305c.js';\n\n// export interface UseVoiceRecorderProps extends VoiceRecorderEventHandler {\n//   /**\n//    * onRecordingStarted\n//    * onRecordingEnded\n//    */\n// }\n/* eslint-disable no-redeclare */\nconst VoiceRecorderStatus = {\n  PREPARING: 'PREPARING',\n  READY_TO_RECORD: 'READY_TO_RECORD',\n  RECORDING: 'RECORDING',\n  COMPLETED: 'COMPLETED'\n};\nconst noop = () => {/* noop */};\nconst useVoiceRecorder = _ref => {\n  let {\n    onRecordingStarted = noop,\n    onRecordingEnded = noop\n  } = _ref;\n  const {\n    config\n  } = useSendbirdStateContext();\n  const {\n    voiceRecord\n  } = config;\n  const {\n    maxRecordingTime\n  } = voiceRecord;\n  const voiceRecorder = useVoiceRecorderContext();\n  const {\n    isRecordable\n  } = voiceRecorder;\n  const [recordedFile, setRecordedFile] = useState(null);\n  const [recordingStatus, setRecordingStatus] = useState(VoiceRecorderStatus.PREPARING);\n  useEffect(() => {\n    if (isRecordable && recordingStatus === VoiceRecorderStatus.PREPARING) {\n      setRecordingStatus(VoiceRecorderStatus.READY_TO_RECORD);\n    }\n  }, [isRecordable]);\n  const start = useCallback(() => {\n    voiceRecorder === null || voiceRecorder === void 0 ? void 0 : voiceRecorder.start({\n      onRecordingStarted: () => {\n        setRecordingStatus(VoiceRecorderStatus.RECORDING);\n        onRecordingStarted();\n        startTimer();\n      },\n      onRecordingEnded: audioFile => {\n        setRecordingStatus(VoiceRecorderStatus.COMPLETED);\n        onRecordingEnded(audioFile);\n        setRecordedFile(audioFile);\n        stopTimer();\n      }\n    });\n  }, [onRecordingStarted, onRecordingEnded]);\n  const stop = useCallback(() => {\n    voiceRecorder === null || voiceRecorder === void 0 ? void 0 : voiceRecorder.stop();\n    stopTimer();\n  }, [voiceRecorder]);\n  const cancel = useCallback(() => {\n    stop();\n    setRecordedFile(null);\n  }, [voiceRecorder]);\n\n  // Timer\n  const [recordingTime, setRecordingTime] = useState(0);\n  let timer = null;\n  function startTimer() {\n    stopTimer();\n    setRecordingTime(0);\n    const interval = setInterval(() => {\n      setRecordingTime(prevTime => {\n        const newTime = prevTime + 100;\n        if (newTime > maxRecordingTime) {\n          stopTimer();\n        }\n        return newTime;\n      });\n    }, 100);\n    timer = interval;\n  }\n  function stopTimer() {\n    clearInterval(timer);\n    timer = null;\n  }\n  useEffect(() => {\n    if (recordingTime > maxRecordingTime) {\n      stop();\n    }\n  }, [recordingTime, maxRecordingTime, stop]);\n  return {\n    start,\n    stop,\n    cancel,\n    recordingStatus,\n    recordingTime,\n    recordedFile,\n    recordingLimit: maxRecordingTime\n  };\n};\nexport { VoiceRecorderStatus, useVoiceRecorder };","map":{"version":3,"mappings":"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","names":["VoiceRecorderStatus","PREPARING","READY_TO_RECORD","RECORDING","COMPLETED","noop","useVoiceRecorder","_ref","onRecordingStarted","onRecordingEnded","config","useSendbirdStateContext","voiceRecord","maxRecordingTime","voiceRecorder","useVoiceRecorderContext","isRecordable","recordedFile","setRecordedFile","useState","recordingStatus","setRecordingStatus","useEffect","start","useCallback","startTimer","audioFile","stopTimer","stop","cancel","recordingTime","setRecordingTime","timer","interval","setInterval","prevTime","newTime","clearInterval","recordingLimit"],"sources":["C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\hooks\\VoiceRecorder\\useVoiceRecorder.tsx"],"sourcesContent":["import { useCallback, useEffect, useState } from 'react';\nimport { VoiceRecorderEventHandler, useVoiceRecorderContext } from '.';\nimport useSendbirdStateContext from '../useSendbirdStateContext';\n\n// export interface UseVoiceRecorderProps extends VoiceRecorderEventHandler {\n//   /**\n//    * onRecordingStarted\n//    * onRecordingEnded\n//    */\n// }\n/* eslint-disable no-redeclare */\nexport const VoiceRecorderStatus = {\n  PREPARING: 'PREPARING',\n  READY_TO_RECORD: 'READY_TO_RECORD',\n  RECORDING: 'RECORDING',\n  COMPLETED: 'COMPLETED',\n} as const;\nexport type VoiceRecorderStatus = typeof VoiceRecorderStatus[keyof typeof VoiceRecorderStatus];\nexport interface UseVoiceRecorderContext {\n  start: () => void;\n  stop: () => void;\n  cancel: () => void;\n  recordingLimit: number;\n  recordingTime: number;\n  recordedFile: File;\n  recordingStatus: VoiceRecorderStatus;\n}\n\nconst noop = () => { /* noop */ };\n\nexport const useVoiceRecorder = ({\n  onRecordingStarted = noop,\n  onRecordingEnded = noop,\n}: VoiceRecorderEventHandler): UseVoiceRecorderContext => {\n  const { config } = useSendbirdStateContext();\n  const { voiceRecord } = config;\n  const { maxRecordingTime } = voiceRecord;\n  const voiceRecorder = useVoiceRecorderContext();\n  const { isRecordable } = voiceRecorder;\n\n  const [recordedFile, setRecordedFile] = useState<File>(null);\n  const [recordingStatus, setRecordingStatus] = useState<VoiceRecorderStatus>(VoiceRecorderStatus.PREPARING);\n  useEffect(() => {\n    if (isRecordable && recordingStatus === VoiceRecorderStatus.PREPARING) {\n      setRecordingStatus(VoiceRecorderStatus.READY_TO_RECORD);\n    }\n  }, [isRecordable]);\n\n  const start = useCallback(() => {\n    voiceRecorder?.start({\n      onRecordingStarted: () => {\n        setRecordingStatus(VoiceRecorderStatus.RECORDING);\n        onRecordingStarted();\n        startTimer();\n      },\n      onRecordingEnded: (audioFile) => {\n        setRecordingStatus(VoiceRecorderStatus.COMPLETED);\n        onRecordingEnded(audioFile);\n        setRecordedFile(audioFile);\n        stopTimer();\n      },\n    });\n  }, [onRecordingStarted, onRecordingEnded]);\n  const stop = useCallback(() => {\n    voiceRecorder?.stop();\n    stopTimer();\n  }, [voiceRecorder]);\n  const cancel = useCallback(() => {\n    stop();\n    setRecordedFile(null);\n  }, [voiceRecorder]);\n\n  // Timer\n  const [recordingTime, setRecordingTime] = useState<number>(0);\n  let timer: ReturnType<typeof setInterval> = null;\n  function startTimer() {\n    stopTimer();\n    setRecordingTime(0);\n    const interval = setInterval(() => {\n      setRecordingTime(prevTime => {\n        const newTime = prevTime + 100;\n        if (newTime > maxRecordingTime) {\n          stopTimer();\n        }\n        return newTime;\n      });\n    }, 100);\n    timer = interval;\n  }\n  function stopTimer() {\n    clearInterval(timer);\n    timer = null;\n  }\n  useEffect(() => {\n    if (recordingTime > maxRecordingTime) {\n      stop();\n    }\n  }, [recordingTime, maxRecordingTime, stop]);\n\n  return ({\n    start,\n    stop,\n    cancel,\n    recordingStatus,\n    recordingTime,\n    recordedFile,\n    recordingLimit: maxRecordingTime,\n  });\n};\n"]},"metadata":{},"sourceType":"module"}