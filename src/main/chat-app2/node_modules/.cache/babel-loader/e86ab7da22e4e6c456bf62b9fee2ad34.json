{"ast":null,"code":"import React__default, { useEffect, useCallback, useRef, useState, useReducer, useMemo } from 'react';\nimport { U as UserProfileProvider } from './UserProfileContext-9cfbab4d.js';\nimport useSendbirdStateContext from './useSendbirdStateContext.js';\nimport { f as format } from './index-7cdd58b8.js';\nimport { P as PUBSUB_TOPICS } from './topics-b2b77fb9.js';\nimport { a as getSendingMessageStatus, b as isReadMessage, c as filterMessageListParams } from './index-7eb65acf.js';\nimport { _ as _objectSpread2 } from './_rollupPluginBabelHelpers-6bb0305c.js';\nimport { c as compareIds } from './compareIds-defe2bb3.js';\nimport { N as NEXT_RESULT_SIZE, P as PREV_RESULT_SIZE } from './const-b3f02313.js';\nimport { GroupChannelHandler } from '@sendbird/chat/groupChannel';\nimport { u as uuidv4 } from './uuid-1adedf62.js';\nimport { ReplyType, MessageMetaArray } from '@sendbird/chat/message';\nimport { b as VOICE_MESSAGE_FILE_NAME, c as VOICE_MESSAGE_MIME_TYPE, M as META_ARRAY_VOICE_DURATION_KEY, d as META_ARRAY_MESSAGE_TYPE_KEY, e as META_ARRAY_MESSAGE_TYPE_VALUE__VOICE } from './consts-95d8566e.js';\nconst RESET_MESSAGES = 'RESET_MESSAGES';\nconst FETCH_INITIAL_MESSAGES_START = 'FETCH_INITIAL_MESSAGES_START';\nconst FETCH_INITIAL_MESSAGES_SUCCESS = 'FETCH_INITIAL_MESSAGES_SUCCESS';\nconst FETCH_INITIAL_MESSAGES_FAILURE = 'FETCH_INITIAL_MESSAGES_FAILURE';\nconst FETCH_PREV_MESSAGES_SUCCESS = 'FETCH_PREV_MESSAGES_SUCCESS';\nconst FETCH_PREV_MESSAGES_FAILURE = 'FETCH_PREV_MESSAGES_FAILURE';\nconst FETCH_NEXT_MESSAGES_SUCCESS = 'FETCH_NEXT_MESSAGES_SUCCESS';\nconst FETCH_NEXT_MESSAGES_FAILURE = 'FETCH_NEXT_MESSAGES_FAILURE';\nconst SEND_MESSAGEGE_START = 'SEND_MESSAGEGE_START';\nconst SEND_MESSAGEGE_SUCESS = 'SEND_MESSAGEGE_SUCESS';\nconst SEND_MESSAGEGE_FAILURE = 'SEND_MESSAGEGE_FAILURE';\nconst RESEND_MESSAGEGE_START = 'RESEND_MESSAGEGE_START';\nconst ON_MESSAGE_RECEIVED = 'ON_MESSAGE_RECEIVED';\nconst ON_MESSAGE_UPDATED = 'ON_MESSAGE_UPDATED';\nconst ON_MESSAGE_THREAD_INFO_UPDATED = 'ON_MESSAGE_THREAD_INFO_UPDATED';\nconst ON_MESSAGE_DELETED = 'ON_MESSAGE_DELETED';\nconst ON_MESSAGE_DELETED_BY_REQ_ID = 'ON_MESSAGE_DELETED_BY_REQ_ID';\nconst SET_CURRENT_CHANNEL = 'SET_CURRENT_CHANNEL';\nconst SET_CHANNEL_INVALID = 'SET_CHANNEL_INVALID';\nconst MARK_AS_READ = 'MARK_AS_READ';\nconst ON_REACTION_UPDATED = 'ON_REACTION_UPDATED';\nconst SET_EMOJI_CONTAINER = 'SET_EMOJI_CONTAINER';\nconst MESSAGE_LIST_PARAMS_CHANGED = 'MESSAGE_LIST_PARAMS_CHANGED';\nvar messageActionTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  RESET_MESSAGES: RESET_MESSAGES,\n  FETCH_INITIAL_MESSAGES_START: FETCH_INITIAL_MESSAGES_START,\n  FETCH_INITIAL_MESSAGES_SUCCESS: FETCH_INITIAL_MESSAGES_SUCCESS,\n  FETCH_INITIAL_MESSAGES_FAILURE: FETCH_INITIAL_MESSAGES_FAILURE,\n  FETCH_PREV_MESSAGES_SUCCESS: FETCH_PREV_MESSAGES_SUCCESS,\n  FETCH_PREV_MESSAGES_FAILURE: FETCH_PREV_MESSAGES_FAILURE,\n  FETCH_NEXT_MESSAGES_SUCCESS: FETCH_NEXT_MESSAGES_SUCCESS,\n  FETCH_NEXT_MESSAGES_FAILURE: FETCH_NEXT_MESSAGES_FAILURE,\n  SEND_MESSAGEGE_START: SEND_MESSAGEGE_START,\n  SEND_MESSAGEGE_SUCESS: SEND_MESSAGEGE_SUCESS,\n  SEND_MESSAGEGE_FAILURE: SEND_MESSAGEGE_FAILURE,\n  RESEND_MESSAGEGE_START: RESEND_MESSAGEGE_START,\n  ON_MESSAGE_RECEIVED: ON_MESSAGE_RECEIVED,\n  ON_MESSAGE_UPDATED: ON_MESSAGE_UPDATED,\n  ON_MESSAGE_THREAD_INFO_UPDATED: ON_MESSAGE_THREAD_INFO_UPDATED,\n  ON_MESSAGE_DELETED: ON_MESSAGE_DELETED,\n  ON_MESSAGE_DELETED_BY_REQ_ID: ON_MESSAGE_DELETED_BY_REQ_ID,\n  SET_CURRENT_CHANNEL: SET_CURRENT_CHANNEL,\n  SET_CHANNEL_INVALID: SET_CHANNEL_INVALID,\n  MARK_AS_READ: MARK_AS_READ,\n  ON_REACTION_UPDATED: ON_REACTION_UPDATED,\n  SET_EMOJI_CONTAINER: SET_EMOJI_CONTAINER,\n  MESSAGE_LIST_PARAMS_CHANGED: MESSAGE_LIST_PARAMS_CHANGED\n});\nconst UNDEFINED = 'undefined';\nconst {\n  SUCCEEDED: SUCCEEDED$1,\n  FAILED,\n  PENDING\n} = getSendingMessageStatus();\nconst scrollToRenderedMessage = (scrollRef, initialTimeStamp) => {\n  try {\n    var _container$querySelec;\n    const container = scrollRef.current;\n    // scroll into the message with initialTimeStamp\n    const element = (_container$querySelec = container.querySelectorAll(`[data-sb-created-at=\"${initialTimeStamp}\"]`)) === null || _container$querySelec === void 0 ? void 0 : _container$querySelec[0];\n    if (element) {\n      // Calculate the offset of the element from the top of the container\n      const containerHeight = container.offsetHeight;\n      const elementHeight = element.offsetHeight;\n      const elementOffset = (containerHeight - elementHeight) / 2;\n      // Set the scroll position of the container to bring the element to the middle\n      container.scrollTop = element.offsetTop - elementOffset;\n    }\n  } catch (_unused) {\n    // do nothing\n  }\n};\n\n/* eslint-disable default-param-last */\nconst scrollIntoLast = function () {\n  let initialTry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let scrollRef = arguments.length > 1 ? arguments[1] : undefined;\n  const MAX_TRIES = 10;\n  const currentTry = initialTry;\n  if (currentTry > MAX_TRIES) {\n    return;\n  }\n  try {\n    const scrollDOM = (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current) || document.querySelector('.sendbird-conversation__messages-padding');\n    // eslint-disable-next-line no-multi-assign\n    scrollDOM.scrollTop = scrollDOM.scrollHeight;\n  } catch (error) {\n    setTimeout(() => {\n      scrollIntoLast(currentTry + 1, scrollRef);\n    }, 500 * currentTry);\n  }\n};\nconst pubSubHandleRemover = subscriber => {\n  subscriber.forEach(s => {\n    try {\n      s.remove();\n    } catch (_unused2) {\n      //\n    }\n  });\n};\nconst pubSubHandler = _ref => {\n  let {\n    channelUrl,\n    pubSub,\n    dispatcher,\n    scrollRef\n  } = _ref;\n  const subscriber = new Map();\n  if (!pubSub || !pubSub.subscribe) return subscriber;\n  subscriber.set(PUBSUB_TOPICS.SEND_USER_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.SEND_USER_MESSAGE, msg => {\n    const {\n      channel,\n      message\n    } = msg;\n    scrollIntoLast(0, scrollRef);\n    if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n      dispatcher({\n        type: SEND_MESSAGEGE_SUCESS,\n        payload: message\n      });\n    }\n  }));\n  subscriber.set(PUBSUB_TOPICS.SEND_MESSAGE_START, pubSub.subscribe(PUBSUB_TOPICS.SEND_MESSAGE_START, msg => {\n    const {\n      channel,\n      message\n    } = msg;\n    if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n      dispatcher({\n        type: SEND_MESSAGEGE_START,\n        payload: message\n      });\n    }\n  }));\n  subscriber.set(PUBSUB_TOPICS.SEND_FILE_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.SEND_FILE_MESSAGE, msg => {\n    const {\n      channel,\n      message\n    } = msg;\n    scrollIntoLast(0, scrollRef);\n    if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n      dispatcher({\n        type: SEND_MESSAGEGE_SUCESS,\n        payload: message\n      });\n    }\n  }));\n  subscriber.set(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, msg => {\n    const {\n      channel,\n      message,\n      fromSelector\n    } = msg;\n    if (fromSelector && channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n      dispatcher({\n        type: ON_MESSAGE_UPDATED,\n        payload: {\n          channel,\n          message\n        }\n      });\n    }\n  }));\n  subscriber.set(PUBSUB_TOPICS.DELETE_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.DELETE_MESSAGE, msg => {\n    const {\n      channel,\n      messageId\n    } = msg;\n    if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n      dispatcher({\n        type: ON_MESSAGE_DELETED,\n        payload: messageId\n      });\n    }\n  }));\n  return subscriber;\n};\nconst isOperator = function () {\n  let groupChannel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const myRole = groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.myRole;\n  return myRole === 'operator';\n};\nconst isDisabledBecauseFrozen = function () {\n  let groupChannel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const isFrozen = groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.isFrozen;\n  return isFrozen && !isOperator(groupChannel);\n};\nconst isDisabledBecauseMuted = function () {\n  let groupChannel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const myMutedState = groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.myMutedState;\n  return myMutedState === 'muted';\n};\nconst getAllEmojisMapFromEmojiContainer = function () {\n  let emojiContainer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    emojiCategories = []\n  } = emojiContainer;\n  const allEmojisMap = new Map();\n  for (let categoryIndex = 0; categoryIndex < emojiCategories.length; categoryIndex += 1) {\n    const {\n      emojis\n    } = emojiCategories[categoryIndex];\n    for (let emojiIndex = 0; emojiIndex < emojis.length; emojiIndex += 1) {\n      const {\n        key,\n        url\n      } = emojis[emojiIndex];\n      allEmojisMap.set(key, url);\n    }\n  }\n  return allEmojisMap;\n};\nconst getNicknamesMapFromMembers = function () {\n  let members = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  const nicknamesMap = new Map();\n  for (let memberIndex = 0; memberIndex < members.length; memberIndex += 1) {\n    const {\n      userId,\n      nickname\n    } = members[memberIndex];\n    nicknamesMap.set(userId, nickname);\n  }\n  return nicknamesMap;\n};\nconst getUniqueListBy = (arr, key) => [...new Map(arr.map(item => [item[key], item])).values()];\nconst getUniqueListByMessageId = arr => getUniqueListBy(arr, 'messageId');\nconst sortByCreatedAt = messages => messages.sort((a, b) => a.createdAt - b.createdAt);\nconst mergeAndSortMessages = (oldMessages, newMessages) => {\n  const lastOldMessage = oldMessages[oldMessages.length - 1];\n  const firstNewMessage = newMessages[0];\n  // If the last message of oldMessages is older than the first message of newMessages,\n  // then we can safely append newMessages to oldMessages.\n  if ((lastOldMessage === null || lastOldMessage === void 0 ? void 0 : lastOldMessage.createdAt) < (firstNewMessage === null || firstNewMessage === void 0 ? void 0 : firstNewMessage.createdAt)) {\n    return [...oldMessages, ...newMessages];\n  }\n\n  // todo: optimize this\n  // If the last message of oldMessages is newer than the first message of newMessages,\n  // then we need to merge the two arrays and sort them by createdAt.\n  const mergedMessages = [...oldMessages, ...newMessages];\n  const unique = getUniqueListByMessageId(mergedMessages);\n  return sortByCreatedAt(unique);\n};\nconst getMessageCreatedAt = message => format(message.createdAt, 'p');\nconst isSameGroup = (message, comparingMessage, currentChannel) => {\n  var _message$sender, _comparingMessage$sen, _message$sender2, _comparingMessage$sen2;\n  if (!(message && comparingMessage && message.messageType && message.messageType !== 'admin' && comparingMessage.messageType && (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.messageType) !== 'admin' && message !== null && message !== void 0 && message.sender && comparingMessage !== null && comparingMessage !== void 0 && comparingMessage.sender && message !== null && message !== void 0 && message.createdAt && comparingMessage !== null && comparingMessage !== void 0 && comparingMessage.createdAt && message !== null && message !== void 0 && (_message$sender = message.sender) !== null && _message$sender !== void 0 && _message$sender.userId && comparingMessage !== null && comparingMessage !== void 0 && (_comparingMessage$sen = comparingMessage.sender) !== null && _comparingMessage$sen !== void 0 && _comparingMessage$sen.userId)) {\n    return false;\n  }\n  return (message === null || message === void 0 ? void 0 : message.sendingStatus) === (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sendingStatus) && (message === null || message === void 0 ? void 0 : (_message$sender2 = message.sender) === null || _message$sender2 === void 0 ? void 0 : _message$sender2.userId) === (comparingMessage === null || comparingMessage === void 0 ? void 0 : (_comparingMessage$sen2 = comparingMessage.sender) === null || _comparingMessage$sen2 === void 0 ? void 0 : _comparingMessage$sen2.userId) && getMessageCreatedAt(message) === getMessageCreatedAt(comparingMessage) && isReadMessage(currentChannel, message) === isReadMessage(currentChannel, comparingMessage);\n};\nconst compareMessagesForGrouping = (prevMessage, currMessage, nextMessage, currentChannel, replyType) => {\n  if (replyType === 'THREAD' && currMessage !== null && currMessage !== void 0 && currMessage.threadInfo) {\n    return [false, false];\n  }\n  const sendingStatus = (currMessage === null || currMessage === void 0 ? void 0 : currMessage.sendingStatus) || '';\n  const isAcceptable = sendingStatus !== 'pending' && sendingStatus !== 'failed';\n  return [isSameGroup(prevMessage, currMessage, currentChannel) && isAcceptable, isSameGroup(currMessage, nextMessage, currentChannel) && isAcceptable];\n};\nconst passUnsuccessfullMessages = (allMessages, newMessage) => {\n  const {\n    sendingStatus = UNDEFINED\n  } = newMessage;\n  if (sendingStatus === SUCCEEDED$1 || sendingStatus === PENDING) {\n    const lastIndexOfSucceededMessage = allMessages.map(message => message.sendingStatus || (message.isAdminMessage && message.isAdminMessage() ? SUCCEEDED$1 : UNDEFINED)).lastIndexOf(SUCCEEDED$1);\n    if (lastIndexOfSucceededMessage + 1 < allMessages.length) {\n      const messages = [...allMessages];\n      messages.splice(lastIndexOfSucceededMessage + 1, 0, newMessage);\n      return messages;\n    }\n  }\n  return [...allMessages, newMessage];\n};\nconst pxToNumber = px => {\n  if (typeof px === 'number') {\n    return px;\n  }\n  if (typeof px === 'string') {\n    const parsed = Number.parseFloat(px);\n    if (!Number.isNaN(parsed)) {\n      return parsed;\n    }\n  }\n  return null;\n};\nconst isAboutSame = (a, b, px) => Math.abs(a - b) <= px;\n\n/**\n * This function helps consider the every condition\n * related to enabling emoji reaction feature.\n */\n\nfunction getIsReactionEnabled(_ref) {\n  let {\n    isBroadcast = false,\n    isSuper = false,\n    globalLevel = true,\n    moduleLevel\n  } = _ref;\n  return !(isBroadcast || isSuper) && (moduleLevel !== null && moduleLevel !== void 0 ? moduleLevel : globalLevel);\n}\nvar messagesInitialState = {\n  initialized: false,\n  loading: true,\n  allMessages: [],\n  currentGroupChannel: {\n    members: []\n  },\n  // for scrollup\n  hasMorePrev: false,\n  oldestMessageTimeStamp: 0,\n  // for scroll down\n  // onScrollDownCallback is added for navigation to different timestamps on messageSearch\n  // hasMorePrev, onScrollCallback -> scroll up(default behavior)\n  // hasMoreNext, onScrollDownCallback -> scroll down\n  hasMoreNext: false,\n  latestMessageTimeStamp: 0,\n  emojiContainer: {},\n  unreadSince: null,\n  isInvalid: false,\n  messageListParams: null\n};\nconst {\n  SUCCEEDED\n} = getSendingMessageStatus();\nconst getOldestMessageTimeStamp = function () {\n  let messages = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  const oldestMessage = messages[0];\n  return oldestMessage && oldestMessage.createdAt || null;\n};\nconst getLatestMessageTimeStamp = function () {\n  let messages = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  const latestMessage = messages[messages.length - 1];\n  return latestMessage && latestMessage.createdAt || null;\n};\nfunction reducer(state, action) {\n  var _state$currentGroupCh7, _action$payload, _action$payload$chann;\n  switch (action.type) {\n    case RESET_MESSAGES:\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        // when user switches channel, if the previous channel `hasMorePrev`\n        // the onScroll gets called twice, setting hasMorePrev false prevents this\n        hasMorePrev: false,\n        hasMoreNext: false,\n        allMessages: []\n      });\n    case FETCH_INITIAL_MESSAGES_START:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          loading: true,\n          allMessages: [...state.allMessages.filter(m => m.sendingStatus !== SUCCEEDED)]\n        });\n      }\n    case FETCH_INITIAL_MESSAGES_SUCCESS:\n      {\n        var _state$currentGroupCh;\n        const {\n          currentGroupChannel,\n          messages\n        } = action.payload;\n        if (!((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) === ((_state$currentGroupCh = state.currentGroupChannel) === null || _state$currentGroupCh === void 0 ? void 0 : _state$currentGroupCh.url))) {\n          return state;\n        }\n        const oldestMessageTimeStamp = getOldestMessageTimeStamp(messages);\n        const latestMessageTimeStamp = getLatestMessageTimeStamp(messages);\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          loading: false,\n          initialized: true,\n          hasMorePrev: true,\n          hasMoreNext: true,\n          oldestMessageTimeStamp,\n          latestMessageTimeStamp,\n          allMessages: [...messages]\n        });\n      }\n    case FETCH_PREV_MESSAGES_SUCCESS:\n      {\n        var _state$currentGroupCh2;\n        const {\n          currentGroupChannel,\n          messages\n        } = action.payload;\n        if (!((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) === ((_state$currentGroupCh2 = state.currentGroupChannel) === null || _state$currentGroupCh2 === void 0 ? void 0 : _state$currentGroupCh2.url))) {\n          return state;\n        }\n        const hasMorePrev = messages && messages.length === PREV_RESULT_SIZE + 1;\n        const oldestMessageTimeStamp = getOldestMessageTimeStamp(messages);\n\n        // Remove duplicated messages\n        const duplicatedMessageIds = [];\n        const updatedOldMessages = state.allMessages.map(msg => {\n          const duplicatedMessage = messages.find(_ref => {\n            let {\n              messageId\n            } = _ref;\n            return compareIds(messageId, msg.messageId);\n          });\n          if (!duplicatedMessage) {\n            return msg;\n          }\n          duplicatedMessageIds.push(duplicatedMessage.messageId);\n          return duplicatedMessage.updatedAt > msg.updatedAt ? duplicatedMessage : msg;\n        });\n        const filteredNewMessages = duplicatedMessageIds.length > 0 ? messages.filter(msg => !duplicatedMessageIds.find(messageId => compareIds(messageId, msg.messageId))) : messages;\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          hasMorePrev,\n          oldestMessageTimeStamp,\n          allMessages: [...filteredNewMessages, ...updatedOldMessages]\n        });\n      }\n    case FETCH_NEXT_MESSAGES_SUCCESS:\n      {\n        var _state$currentGroupCh3;\n        const {\n          currentGroupChannel,\n          messages\n        } = action.payload;\n        if (!((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) === ((_state$currentGroupCh3 = state.currentGroupChannel) === null || _state$currentGroupCh3 === void 0 ? void 0 : _state$currentGroupCh3.url))) {\n          return state;\n        }\n        const hasMoreNext = messages && messages.length === NEXT_RESULT_SIZE + 1;\n        const latestMessageTimeStamp = getLatestMessageTimeStamp(messages);\n\n        // sort ~\n        const sortedMessages = mergeAndSortMessages(state.allMessages, messages);\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          hasMoreNext,\n          latestMessageTimeStamp,\n          allMessages: sortedMessages\n        });\n      }\n    case FETCH_INITIAL_MESSAGES_FAILURE:\n    case FETCH_PREV_MESSAGES_FAILURE:\n    case FETCH_NEXT_MESSAGES_FAILURE:\n      {\n        var _state$currentGroupCh4;\n        const {\n          currentGroupChannel\n        } = action.payload;\n        if ((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) !== (state === null || state === void 0 ? void 0 : (_state$currentGroupCh4 = state.currentGroupChannel) === null || _state$currentGroupCh4 === void 0 ? void 0 : _state$currentGroupCh4.url)) {\n          return state;\n        }\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          loading: false,\n          initialized: false,\n          allMessages: [],\n          hasMorePrev: false,\n          hasMoreNext: false,\n          oldestMessageTimeStamp: null,\n          latestMessageTimeStamp: null\n        });\n      }\n    case SEND_MESSAGEGE_START:\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        allMessages: [...state.allMessages, _objectSpread2({}, action.payload)]\n      });\n    case SEND_MESSAGEGE_SUCESS:\n      {\n        const message = action.payload;\n        const filteredMessages = state.allMessages.filter(m => (m === null || m === void 0 ? void 0 : m.reqId) !== (message === null || message === void 0 ? void 0 : message.reqId));\n        const pendingIndex = filteredMessages.findIndex(msg => (msg === null || msg === void 0 ? void 0 : msg.sendingStatus) === 'pending' || (msg === null || msg === void 0 ? void 0 : msg.sendingStatus) === 'failed');\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allMessages: pendingIndex > -1 ? [...filteredMessages.slice(0, pendingIndex), message, ...filteredMessages.slice(pendingIndex)] : [...filteredMessages, message]\n        });\n      }\n    case SEND_MESSAGEGE_FAILURE:\n      {\n        // eslint-disable-next-line no-param-reassign\n        action.payload.failed = true;\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allMessages: state.allMessages.map(m => compareIds(m.reqId, action.payload.reqId) ? action.payload : m)\n        });\n      }\n    case SET_CURRENT_CHANNEL:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          currentGroupChannel: action.payload,\n          isInvalid: false\n        });\n      }\n    case SET_CHANNEL_INVALID:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          currentGroupChannel: null,\n          isInvalid: true\n        });\n      }\n    case ON_MESSAGE_RECEIVED:\n      {\n        const {\n          channel,\n          message\n        } = action.payload;\n        const {\n          members\n        } = channel;\n        const {\n          sender\n        } = message;\n        const {\n          currentGroupChannel = {},\n          unreadSince\n        } = state;\n        const currentGroupChannelUrl = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url;\n        if (!compareIds(channel === null || channel === void 0 ? void 0 : channel.url, currentGroupChannelUrl)) {\n          return state;\n        }\n        // Excluded overlapping messages\n        if (state.allMessages.some(msg => msg.messageId === message.messageId)) {\n          return state;\n        }\n        // Filter by userFilledQuery\n        if (state.messageListParams && !filterMessageListParams(state.messageListParams, message)) {\n          return state;\n        }\n        if (message.isAdminMessage && message.isAdminMessage()) {\n          return _objectSpread2(_objectSpread2({}, state), {}, {\n            allMessages: passUnsuccessfullMessages(state.allMessages, message)\n          });\n        }\n\n        // Update members when sender profileUrl, nickname, friendName has been changed\n        const senderMember = members === null || members === void 0 ? void 0 : members.find(m => (m === null || m === void 0 ? void 0 : m.userId) === (sender === null || sender === void 0 ? void 0 : sender.userId));\n        if ((senderMember === null || senderMember === void 0 ? void 0 : senderMember.profileUrl) !== (sender === null || sender === void 0 ? void 0 : sender.profileUrl) || (senderMember === null || senderMember === void 0 ? void 0 : senderMember.friendName) !== (sender === null || sender === void 0 ? void 0 : sender.friendName) || (senderMember === null || senderMember === void 0 ? void 0 : senderMember.nickname) !== (sender === null || sender === void 0 ? void 0 : sender.nickname)) {\n          channel.members = members.map(member => {\n            if (member.userId === sender.userId) {\n              return sender;\n            }\n            return member;\n          });\n        }\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          currentGroupChannel: channel,\n          unreadSince: state !== null && state !== void 0 && state.unreadSince ? unreadSince : format(new Date(), 'p MMM dd'),\n          allMessages: passUnsuccessfullMessages(state.allMessages, message)\n        });\n      }\n    case ON_MESSAGE_UPDATED:\n      {\n        var _state$currentGroupCh5;\n        const {\n          channel,\n          message\n        } = action.payload;\n        const currentGroupChannelUrl = (state === null || state === void 0 ? void 0 : (_state$currentGroupCh5 = state.currentGroupChannel) === null || _state$currentGroupCh5 === void 0 ? void 0 : _state$currentGroupCh5.url) || '';\n        if (!compareIds(channel === null || channel === void 0 ? void 0 : channel.url, currentGroupChannelUrl)) {\n          return state; // Ignore event when it is not for the current channel\n        }\n\n        if (state.messageListParams && !filterMessageListParams(state.messageListParams, message)) {\n          // Delete the message if it doesn't match to the params anymore\n          return _objectSpread2(_objectSpread2({}, state), {}, {\n            allMessages: state.allMessages.filter(m => !compareIds(m.messageId, message === null || message === void 0 ? void 0 : message.messageId))\n          });\n        }\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allMessages: state.allMessages.map(m => {\n            if (compareIds(m.messageId, message.messageId)) {\n              return message;\n            }\n            if (compareIds(m.parentMessageId, message.messageId)) {\n              m.parentMessage = message; // eslint-disable-line no-param-reassign\n            }\n\n            return m;\n          })\n        });\n      }\n    case ON_MESSAGE_THREAD_INFO_UPDATED:\n      {\n        var _state$currentGroupCh6;\n        const {\n          channel,\n          event\n        } = action.payload;\n        const {\n          channelUrl,\n          threadInfo,\n          targetMessageId\n        } = event;\n        const currentGroupChannelUrl = (state === null || state === void 0 ? void 0 : (_state$currentGroupCh6 = state.currentGroupChannel) === null || _state$currentGroupCh6 === void 0 ? void 0 : _state$currentGroupCh6.url) || '';\n        if (!compareIds(channel === null || channel === void 0 ? void 0 : channel.url, currentGroupChannelUrl) || !compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n          return state; // Ignore event when it is not for the current channel\n        }\n\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allMessages: state.allMessages.map(m => {\n            if (compareIds(m.messageId, targetMessageId)) {\n              // eslint-disable-next-line no-param-reassign\n              m.threadInfo = threadInfo; // Upsert threadInfo to the target message\n            }\n\n            return m;\n          })\n        });\n      }\n    case RESEND_MESSAGEGE_START:\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        allMessages: state.allMessages.map(m => compareIds(m.reqId, action.payload.reqId) ? action.payload : m)\n      });\n    case MARK_AS_READ:\n      if (((_state$currentGroupCh7 = state.currentGroupChannel) === null || _state$currentGroupCh7 === void 0 ? void 0 : _state$currentGroupCh7.url) !== ((_action$payload = action.payload) === null || _action$payload === void 0 ? void 0 : (_action$payload$chann = _action$payload.channel) === null || _action$payload$chann === void 0 ? void 0 : _action$payload$chann.url)) {\n        return state;\n      }\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        unreadSince: null\n      });\n    case ON_MESSAGE_DELETED:\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        allMessages: state.allMessages.filter(m => !compareIds(m.messageId, action.payload))\n      });\n    case ON_MESSAGE_DELETED_BY_REQ_ID:\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        allMessages: state.allMessages.filter(m => !compareIds(m.reqId, action.payload))\n      });\n    case SET_EMOJI_CONTAINER:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          emojiContainer: action.payload\n        });\n      }\n    case ON_REACTION_UPDATED:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allMessages: state.allMessages.map(m => {\n            if (compareIds(m.messageId, action.payload.messageId)) {\n              if (m.applyReactionEvent && typeof m.applyReactionEvent === 'function') {\n                m.applyReactionEvent(action.payload);\n              }\n              return m;\n            }\n            return m;\n          })\n        });\n      }\n    case MESSAGE_LIST_PARAMS_CHANGED:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          messageListParams: action.payload\n        });\n      }\n    default:\n      return state;\n  }\n}\n\n/**\n * Handles ChannelEvents and send values to dispatcher using messagesDispatcher\n * messagesDispatcher: Dispatcher\n * sdk: sdkInstance\n * logger: loggerInstance\n * channelUrl: string\n * sdkInit: bool\n */\n\nconst DELIVERY_RECIPT = 'delivery_receipt';\nfunction useHandleChannelEvents(_ref, _ref2) {\n  var _store$stores$sdkStor, _store$stores$sdkStor2, _store$stores$sdkStor3;\n  let {\n    sdkInit,\n    currentUserId,\n    currentGroupChannel,\n    disableMarkAsRead\n  } = _ref;\n  let {\n    sdk,\n    logger,\n    scrollRef,\n    setQuoteMessage,\n    messagesDispatcher\n  } = _ref2;\n  const store = useSendbirdStateContext();\n  const {\n    markAsReadScheduler,\n    markAsDeliveredScheduler,\n    disableMarkAsDelivered\n  } = store.config;\n  const canSetMarkAsDelivered = (_store$stores$sdkStor = store.stores.sdkStore.sdk) === null || _store$stores$sdkStor === void 0 ? void 0 : (_store$stores$sdkStor2 = _store$stores$sdkStor.appInfo) === null || _store$stores$sdkStor2 === void 0 ? void 0 : (_store$stores$sdkStor3 = _store$stores$sdkStor2.premiumFeatureList) === null || _store$stores$sdkStor3 === void 0 ? void 0 : _store$stores$sdkStor3.find(feature => feature === DELIVERY_RECIPT);\n  useEffect(() => {\n    const channelUrl = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url;\n    const channelHandlerId = uuidv4();\n    if (channelUrl && sdkInit) {\n      var _sdk$groupChannel;\n      const channelHandler = {\n        onMessageReceived: (channel, message) => {\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            var _document$getElementB, _document$getElementB2;\n            let scrollToEnd = false;\n            try {\n              const {\n                current\n              } = scrollRef;\n              scrollToEnd = current.offsetHeight + current.scrollTop >= current.scrollHeight - 10;\n              // 10 is a buffer\n            } catch (error) {\n              //\n            }\n            logger.info('Channel | useHandleChannelEvents: onMessageReceived', message);\n            messagesDispatcher({\n              type: ON_MESSAGE_RECEIVED,\n              payload: {\n                channel,\n                message\n              }\n            });\n            if (scrollToEnd && ((_document$getElementB = document.getElementById('sendbird-dropdown-portal')) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.childElementCount) === 0 && ((_document$getElementB2 = document.getElementById('sendbird-emoji-list-portal')) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.childElementCount) === 0) {\n              // and !openContextMenu\n              try {\n                setTimeout(() => {\n                  scrollIntoLast(0, scrollRef);\n                });\n                if (!disableMarkAsRead) {\n                  markAsReadScheduler.push(currentGroupChannel);\n                }\n                if (canSetMarkAsDelivered && !disableMarkAsDelivered) {\n                  markAsDeliveredScheduler.push(currentGroupChannel);\n                }\n              } catch (error) {\n                logger.warning('Channel | onMessageReceived | scroll to end failed');\n              }\n            }\n          }\n        },\n        onUnreadMemberStatusUpdated: channel => {\n          logger.info('Channel | useHandleChannelEvents: onUnreadMemberStatusUpdated', channel);\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        // before(onDeliveryReceiptUpdated)\n        onUndeliveredMemberStatusUpdated: channel => {\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onDeliveryReceiptUpdated', channel);\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        onMessageUpdated: (channel, message) => {\n          logger.info('Channel | useHandleChannelEvents: onMessageUpdated', message);\n          messagesDispatcher({\n            type: ON_MESSAGE_UPDATED,\n            payload: {\n              channel,\n              message\n            }\n          });\n        },\n        onThreadInfoUpdated: (channel, threadInfoUpdateEvent) => {\n          logger.info('Channel | useHandleChannelEvents: onThreadInfoUpdated', {\n            channel,\n            threadInfoUpdateEvent\n          });\n          messagesDispatcher({\n            type: ON_MESSAGE_THREAD_INFO_UPDATED,\n            payload: {\n              channel,\n              event: threadInfoUpdateEvent\n            }\n          });\n        },\n        onMessageDeleted: (channel, messageId) => {\n          logger.info('Channel | useHandleChannelEvents: onMessageDeleted', {\n            channel,\n            messageId\n          });\n          setQuoteMessage(null);\n          messagesDispatcher({\n            type: ON_MESSAGE_DELETED,\n            payload: messageId\n          });\n        },\n        onReactionUpdated: (channel, reactionEvent) => {\n          logger.info('Channel | useHandleChannelEvents: onReactionUpdated', {\n            channel,\n            reactionEvent\n          });\n          messagesDispatcher({\n            type: ON_REACTION_UPDATED,\n            payload: reactionEvent\n          });\n        },\n        onChannelChanged: channel => {\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onChannelChanged', channel);\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        onChannelFrozen: channel => {\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onChannelFrozen', channel);\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        onChannelUnfrozen: channel => {\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onChannelUnFrozen', channel);\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        onUserMuted: (channel, user) => {\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onUserMuted', {\n              channel,\n              user\n            });\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        onUserUnmuted: (channel, user) => {\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onUserUnmuted', {\n              channel,\n              user\n            });\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        onUserBanned: (channel, user) => {\n          var _sdk$currentUser;\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl) && (user === null || user === void 0 ? void 0 : user.userId) === (sdk === null || sdk === void 0 ? void 0 : (_sdk$currentUser = sdk.currentUser) === null || _sdk$currentUser === void 0 ? void 0 : _sdk$currentUser.userId)) {\n            logger.info('Channel | useHandleChannelEvents: onUserBanned', {\n              channel,\n              user\n            });\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: null\n            });\n          }\n        },\n        onOperatorUpdated: (channel, users) => {\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onOperatorUpdated', {\n              channel,\n              users\n            });\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        onUserLeft: (channel, user) => {\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onUserLeft', {\n              channel,\n              user\n            });\n            if ((user === null || user === void 0 ? void 0 : user.userId) === currentUserId) {\n              messagesDispatcher({\n                type: SET_CURRENT_CHANNEL,\n                payload: null\n              });\n            }\n          }\n        }\n      };\n      logger.info('Channel | useHandleChannelEvents: Setup event handler', {\n        channelHandlerId,\n        channelHandler\n      });\n      // Add this group channel handler to the Sendbird chat instance\n      (_sdk$groupChannel = sdk.groupChannel) === null || _sdk$groupChannel === void 0 ? void 0 : _sdk$groupChannel.addGroupChannelHandler(channelHandlerId, new GroupChannelHandler(channelHandler));\n    }\n    return () => {\n      var _sdk$groupChannel2;\n      if (sdk !== null && sdk !== void 0 && (_sdk$groupChannel2 = sdk.groupChannel) !== null && _sdk$groupChannel2 !== void 0 && _sdk$groupChannel2.removeGroupChannelHandler) {\n        logger.info('Channel | useHandleChannelEvents: Removing message reciver handler', channelHandlerId);\n        sdk.groupChannel.removeGroupChannelHandler(channelHandlerId);\n      } else if (sdk !== null && sdk !== void 0 && sdk.groupChannel) {\n        logger.error('Channel | useHandleChannelEvents: Not found the removeGroupChannelHandler');\n      }\n    };\n  }, [currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url, sdkInit]);\n}\nfunction useSetChannel(_ref, _ref2) {\n  let {\n    channelUrl,\n    sdkInit,\n    disableMarkAsRead\n  } = _ref;\n  let {\n    messagesDispatcher,\n    sdk,\n    logger,\n    markAsReadScheduler\n  } = _ref2;\n  useEffect(() => {\n    if (channelUrl && sdkInit && sdk && sdk.groupChannel) {\n      logger.info('Channel | useSetChannel fetching channel', channelUrl);\n      sdk.groupChannel.getChannel(channelUrl).then(groupChannel => {\n        logger.info('Channel | useSetChannel fetched channel', groupChannel);\n        messagesDispatcher({\n          type: SET_CURRENT_CHANNEL,\n          payload: groupChannel\n        });\n        logger.info('Channel: Mark as read', groupChannel);\n        if (!disableMarkAsRead) {\n          markAsReadScheduler.push(groupChannel);\n        }\n      }).catch(e => {\n        logger.warning('Channel | useSetChannel fetch channel failed', {\n          channelUrl,\n          e\n        });\n        messagesDispatcher({\n          type: SET_CHANNEL_INVALID\n        });\n      });\n      sdk.getAllEmoji().then(emojiContainer_ => {\n        logger.info('Channel: Getting emojis success', emojiContainer_);\n        messagesDispatcher({\n          type: SET_EMOJI_CONTAINER,\n          payload: emojiContainer_\n        });\n      }).catch(err => {\n        logger.error('Channel: Getting emojis failed', err);\n      });\n      sdk.getAllEmoji();\n    }\n  }, [channelUrl, sdkInit]);\n}\nfunction useInitialMessagesFetch(_ref, _ref2) {\n  let {\n    currentGroupChannel,\n    userFilledMessageListQuery,\n    initialTimeStamp,\n    replyType\n  } = _ref;\n  let {\n    logger,\n    scrollRef,\n    messagesDispatcher\n  } = _ref2;\n  const channelUrl = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url;\n  useEffect(() => {\n    logger.info('Channel useInitialMessagesFetch: Setup started', currentGroupChannel);\n    messagesDispatcher({\n      type: RESET_MESSAGES,\n      payload: null\n    });\n    if (currentGroupChannel && currentGroupChannel !== null && currentGroupChannel !== void 0 && currentGroupChannel.getMessagesByTimestamp) {\n      const messageListParams = {};\n      messageListParams.prevResultSize = PREV_RESULT_SIZE;\n      if (initialTimeStamp) {\n        messageListParams.nextResultSize = NEXT_RESULT_SIZE;\n      }\n      messageListParams.isInclusive = true;\n      messageListParams.includeReactions = true;\n      messageListParams.includeMetaArray = true;\n      if (replyType && (replyType === 'QUOTE_REPLY' || replyType === 'THREAD')) {\n        messageListParams.includeThreadInfo = true;\n        messageListParams.includeParentMessageInfo = true;\n        messageListParams.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n      }\n      if (userFilledMessageListQuery) {\n        Object.keys(userFilledMessageListQuery).forEach(key => {\n          messageListParams[key] = userFilledMessageListQuery[key];\n        });\n      }\n      if (replyType && (replyType === 'QUOTE_REPLY' || replyType === 'THREAD') || userFilledMessageListQuery) {\n        logger.info('Channel useInitialMessagesFetch: Setup messageListParams', messageListParams);\n        messagesDispatcher({\n          type: MESSAGE_LIST_PARAMS_CHANGED,\n          payload: messageListParams\n        });\n      }\n      logger.info('Channel: Fetching messages', {\n        currentGroupChannel,\n        userFilledMessageListQuery\n      });\n      messagesDispatcher({\n        type: FETCH_INITIAL_MESSAGES_START,\n        payload: null\n      });\n      currentGroupChannel.getMessagesByTimestamp(initialTimeStamp || new Date().getTime(), messageListParams).then(messages => {\n        messagesDispatcher({\n          type: FETCH_INITIAL_MESSAGES_SUCCESS,\n          payload: {\n            currentGroupChannel,\n            messages\n          }\n        });\n      }).catch(error => {\n        logger.error('Channel: Fetching messages failed', error);\n        messagesDispatcher({\n          type: FETCH_INITIAL_MESSAGES_FAILURE,\n          payload: {\n            currentGroupChannel\n          }\n        });\n      }).finally(() => {\n        if (!initialTimeStamp) {\n          setTimeout(() => scrollIntoLast(0, scrollRef));\n        } else {\n          setTimeout(() => {\n            scrollToRenderedMessage(scrollRef, initialTimeStamp);\n          }, 500);\n        }\n      });\n    }\n  }, [channelUrl, userFilledMessageListQuery, initialTimeStamp]);\n  /**\n   * Note - useEffect(() => {}, [currentGroupChannel])\n   * was buggy, that is why we did\n   * const channelUrl = currentGroupChannel && currentGroupChannel.url;\n   * useEffect(() => {}, [channelUrl])\n   * Again, this hook is supposed to execute when currentGroupChannel changes\n   * The 'channelUrl' here is not the same memory reference from Conversation.props\n   */\n}\n\nfunction useHandleReconnect(_ref, _ref2) {\n  let {\n    isOnline,\n    replyType,\n    disableMarkAsRead\n  } = _ref;\n  let {\n    logger,\n    sdk,\n    scrollRef,\n    currentGroupChannel,\n    messagesDispatcher,\n    markAsReadScheduler,\n    userFilledMessageListQuery\n  } = _ref2;\n  useEffect(() => {\n    const wasOffline = !isOnline;\n    return () => {\n      // state changed from offline to online\n      if (wasOffline && currentGroupChannel !== null && currentGroupChannel !== void 0 && currentGroupChannel.url) {\n        var _sdk$appInfo, _sdk$groupChannel;\n        logger.info('Refreshing conversation state');\n        const isReactionEnabled = (sdk === null || sdk === void 0 ? void 0 : (_sdk$appInfo = sdk.appInfo) === null || _sdk$appInfo === void 0 ? void 0 : _sdk$appInfo.useReaction) || false;\n        const messageListParams = {\n          prevResultSize: PREV_RESULT_SIZE,\n          isInclusive: true,\n          includeReactions: isReactionEnabled,\n          nextResultSize: NEXT_RESULT_SIZE\n        };\n        if (replyType && replyType === 'QUOTE_REPLY') {\n          messageListParams.includeThreadInfo = true;\n          messageListParams.includeParentMessageInfo = true;\n          messageListParams.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n        }\n        if (userFilledMessageListQuery) {\n          Object.keys(userFilledMessageListQuery).forEach(key => {\n            messageListParams[key] = userFilledMessageListQuery[key];\n          });\n        }\n        logger.info('Channel: Fetching messages', {\n          currentGroupChannel,\n          userFilledMessageListQuery\n        });\n        messagesDispatcher({\n          type: FETCH_INITIAL_MESSAGES_START,\n          payload: null\n        });\n        sdk === null || sdk === void 0 ? void 0 : (_sdk$groupChannel = sdk.groupChannel) === null || _sdk$groupChannel === void 0 ? void 0 : _sdk$groupChannel.getChannel(currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url).then(groupChannel => {\n          const lastMessageTime = new Date().getTime();\n          groupChannel.getMessagesByTimestamp(lastMessageTime, messageListParams).then(messages => {\n            messagesDispatcher({\n              type: FETCH_INITIAL_MESSAGES_SUCCESS,\n              payload: {\n                currentGroupChannel,\n                messages\n              }\n            });\n            setTimeout(() => scrollIntoLast(0, scrollRef));\n          }).catch(error => {\n            logger.error('Channel: Fetching messages failed', error);\n            messagesDispatcher({\n              type: FETCH_INITIAL_MESSAGES_FAILURE,\n              payload: {\n                currentGroupChannel\n              }\n            });\n          });\n          if (!disableMarkAsRead) {\n            markAsReadScheduler.push(currentGroupChannel);\n          }\n        });\n      }\n    };\n  }, [isOnline, replyType]);\n}\nfunction useScrollCallback(_ref, _ref2) {\n  let {\n    currentGroupChannel,\n    oldestMessageTimeStamp,\n    userFilledMessageListQuery,\n    replyType\n  } = _ref;\n  let {\n    hasMorePrev,\n    logger,\n    messagesDispatcher,\n    sdk\n  } = _ref2;\n  return useCallback(cb => {\n    if (!hasMorePrev) {\n      return;\n    }\n    const {\n      appInfo = {}\n    } = sdk;\n    const isReactionEnabled = appInfo.useReaction || false;\n    const messageListParams = {\n      prevResultSize: PREV_RESULT_SIZE,\n      isInclusive: true,\n      includeReactions: isReactionEnabled\n    };\n    messageListParams.includeMetaArray = true;\n    if (replyType === 'QUOTE_REPLY' || replyType === 'THREAD') {\n      messageListParams.includeThreadInfo = true;\n      messageListParams.includeParentMessageInfo = true;\n      messageListParams.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n    }\n    if (userFilledMessageListQuery) {\n      Object.keys(userFilledMessageListQuery).forEach(key => {\n        messageListParams[key] = userFilledMessageListQuery[key];\n      });\n    }\n    logger.info('Channel: Fetching messages', {\n      currentGroupChannel,\n      userFilledMessageListQuery\n    });\n    currentGroupChannel.getMessagesByTimestamp(oldestMessageTimeStamp || new Date().getTime(), messageListParams).then(messages => {\n      messagesDispatcher({\n        type: FETCH_PREV_MESSAGES_SUCCESS,\n        payload: {\n          currentGroupChannel,\n          messages\n        }\n      });\n      cb([messages, null]);\n    }).catch(error => {\n      logger.error('Channel: Fetching messages failed', error);\n      messagesDispatcher({\n        type: FETCH_PREV_MESSAGES_FAILURE,\n        payload: {\n          currentGroupChannel\n        }\n      });\n      cb([null, error]);\n    });\n  }, [currentGroupChannel, oldestMessageTimeStamp, replyType]);\n}\nfunction useScrollDownCallback(_ref, _ref2) {\n  let {\n    currentGroupChannel,\n    latestMessageTimeStamp,\n    userFilledMessageListQuery,\n    hasMoreNext,\n    replyType\n  } = _ref;\n  let {\n    logger,\n    messagesDispatcher,\n    sdk\n  } = _ref2;\n  return useCallback(cb => {\n    if (!hasMoreNext) {\n      return;\n    }\n    const {\n      appInfo = {}\n    } = sdk;\n    const isReactionEnabled = appInfo.useReaction || false;\n    const messageListParams = {\n      nextResultSize: NEXT_RESULT_SIZE,\n      isInclusive: true,\n      includeReactions: isReactionEnabled\n    };\n    messageListParams.includeMetaArray = true;\n    if (replyType && (replyType === 'QUOTE_REPLY' || replyType === 'THREAD')) {\n      messageListParams.includeThreadInfo = true;\n      messageListParams.includeParentMessageInfo = true;\n      messageListParams.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n    }\n    if (userFilledMessageListQuery) {\n      Object.keys(userFilledMessageListQuery).forEach(key => {\n        messageListParams[key] = userFilledMessageListQuery[key];\n      });\n    }\n    logger.info('Channel: Fetching later messages', {\n      currentGroupChannel,\n      userFilledMessageListQuery\n    });\n    currentGroupChannel.getMessagesByTimestamp(latestMessageTimeStamp || new Date().getTime(), messageListParams).then(messages => {\n      messagesDispatcher({\n        type: FETCH_NEXT_MESSAGES_SUCCESS,\n        payload: {\n          currentGroupChannel,\n          messages\n        }\n      });\n      cb([messages, null]);\n    }).catch(error => {\n      logger.error('Channel: Fetching later messages failed', error);\n      messagesDispatcher({\n        type: FETCH_NEXT_MESSAGES_FAILURE,\n        payload: {\n          currentGroupChannel\n        }\n      });\n      cb([null, error]);\n    });\n  }, [currentGroupChannel, latestMessageTimeStamp, hasMoreNext, replyType]);\n}\nfunction useDeleteMessageCallback(_ref, _ref2) {\n  let {\n    currentGroupChannel,\n    messagesDispatcher\n  } = _ref;\n  let {\n    logger\n  } = _ref2;\n  return useCallback(message => {\n    logger.info('Channel | useDeleteMessageCallback: Deleting message', message);\n    const {\n      requestState\n    } = message;\n    return new Promise((resolve, reject) => {\n      logger.info('Channel | useDeleteMessageCallback: Deleting message requestState:', requestState);\n      // Message is only on local\n      if (requestState === 'failed' || requestState === 'pending') {\n        logger.info('Channel | useDeleteMessageCallback: Deleted message from local:', message);\n        messagesDispatcher({\n          type: ON_MESSAGE_DELETED_BY_REQ_ID,\n          payload: message.reqId\n        });\n        resolve(message);\n      }\n      logger.info('Channel | useDeleteMessageCallback: Deleting message from remote:', requestState);\n      currentGroupChannel.deleteMessage(message).then(() => {\n        logger.info('Channel | useDeleteMessageCallback: Deleting message success!', message);\n        messagesDispatcher({\n          type: ON_MESSAGE_DELETED,\n          payload: message.messageId\n        });\n        resolve(message);\n      }).catch(err => {\n        logger.warning('Channel | useDeleteMessageCallback: Deleting message failed!', err);\n        reject(err);\n      });\n    });\n  }, [currentGroupChannel, messagesDispatcher]);\n}\nfunction useUpdateMessageCallback(_ref, _ref2) {\n  let {\n    currentGroupChannel,\n    messagesDispatcher,\n    onBeforeUpdateUserMessage,\n    isMentionEnabled\n  } = _ref;\n  let {\n    logger,\n    pubSub\n  } = _ref2;\n  return useCallback((props, callback) => {\n    const {\n      messageId,\n      message,\n      mentionedUsers,\n      mentionTemplate\n    } = props;\n    const createParamsDefault = () => {\n      const params = {};\n      params.message = message;\n      if (isMentionEnabled && (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) > 0) {\n        params.mentionedUsers = mentionedUsers;\n      }\n      if (isMentionEnabled && mentionTemplate) {\n        params.mentionedMessageTemplate = mentionTemplate;\n      } else {\n        params.mentionedMessageTemplate = message;\n      }\n      return params;\n    };\n    const createCustomPrams = onBeforeUpdateUserMessage && typeof onBeforeUpdateUserMessage === 'function';\n    if (createCustomPrams) {\n      logger.info('Channel: creating params using onBeforeUpdateUserMessage', onBeforeUpdateUserMessage);\n    }\n    const params = onBeforeUpdateUserMessage ? onBeforeUpdateUserMessage(message) : createParamsDefault();\n    logger.info('Channel: Updating message!', params);\n    currentGroupChannel.updateUserMessage(messageId, params).then((msg, err) => {\n      if (callback) {\n        callback(err, msg);\n      }\n      logger.info('Channel: Updating message success!', msg);\n      messagesDispatcher({\n        type: ON_MESSAGE_UPDATED,\n        payload: {\n          channel: currentGroupChannel,\n          message: msg\n        }\n      });\n      pubSub.publish(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, {\n        message: msg,\n        channel: currentGroupChannel\n      });\n    });\n  }, [currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url, messagesDispatcher, onBeforeUpdateUserMessage]);\n}\nfunction useResendMessageCallback(_ref, _ref2) {\n  let {\n    currentGroupChannel,\n    messagesDispatcher\n  } = _ref;\n  let {\n    logger\n  } = _ref2;\n  return useCallback(failedMessage => {\n    logger.info('Channel: Resending message has started', failedMessage);\n    const {\n      messageType,\n      file\n    } = failedMessage;\n    if (failedMessage !== null && failedMessage !== void 0 && failedMessage.isResendable) {\n      // Move the logic setting sendingStatus to pending into the reducer\n      // eslint-disable-next-line no-param-reassign\n      failedMessage.requestState = 'pending';\n      // eslint-disable-next-line no-param-reassign\n      failedMessage.sendingStatus = 'pending';\n      messagesDispatcher({\n        type: RESEND_MESSAGEGE_START,\n        payload: failedMessage\n      });\n\n      // userMessage\n      if (messageType === 'user') {\n        currentGroupChannel.resendUserMessage(failedMessage).then(message => {\n          logger.info('Channel: Resending message success!', message);\n          messagesDispatcher({\n            type: SEND_MESSAGEGE_SUCESS,\n            payload: message\n          });\n        }).catch(e => {\n          logger.warning('Channel: Resending message failed!', e);\n          // eslint-disable-next-line no-param-reassign\n          failedMessage.requestState = 'failed';\n          // eslint-disable-next-line no-param-reassign\n          failedMessage.sendingStatus = 'failed';\n          messagesDispatcher({\n            type: SEND_MESSAGEGE_FAILURE,\n            payload: failedMessage\n          });\n        });\n\n        // eslint-disable-next-line no-param-reassign\n        failedMessage.requestState = 'pending';\n        // eslint-disable-next-line no-param-reassign\n        failedMessage.sendingStatus = 'pending';\n        messagesDispatcher({\n          type: RESEND_MESSAGEGE_START,\n          payload: failedMessage\n        });\n        return;\n      }\n      if (messageType === 'file') {\n        currentGroupChannel.resendFileMessage(failedMessage, file).then(message => {\n          logger.info('Channel: Resending file message success!', message);\n          messagesDispatcher({\n            type: SEND_MESSAGEGE_SUCESS,\n            payload: message\n          });\n        }).catch(e => {\n          logger.warning('Channel: Resending file message failed!', e);\n          // eslint-disable-next-line no-param-reassign\n          failedMessage.requestState = 'failed';\n          // eslint-disable-next-line no-param-reassign\n          failedMessage.sendingStatus = 'failed';\n          messagesDispatcher({\n            type: SEND_MESSAGEGE_FAILURE,\n            payload: failedMessage\n          });\n        });\n\n        // eslint-disable-next-line no-param-reassign\n        failedMessage.requestState = 'pending';\n        // eslint-disable-next-line no-param-reassign\n        failedMessage.sendingStatus = 'pending';\n        messagesDispatcher({\n          type: RESEND_MESSAGEGE_START,\n          payload: failedMessage\n        });\n      }\n    } else {\n      // to alert user on console\n      // eslint-disable-next-line no-console\n      console.error('Message is not resendable');\n      logger.warning('Message is not resendable', failedMessage);\n    }\n  }, [currentGroupChannel, messagesDispatcher]);\n}\nfunction useSendMessageCallback(_ref, _ref2) {\n  let {\n    isMentionEnabled,\n    currentGroupChannel,\n    onBeforeSendUserMessage\n  } = _ref;\n  let {\n    logger,\n    pubSub,\n    scrollRef,\n    messagesDispatcher\n  } = _ref2;\n  const messageInputRef = useRef(null);\n  const sendMessage = useCallback(props => {\n    const {\n      quoteMessage = null,\n      message,\n      mentionTemplate,\n      // mentionedUserIds,\n      mentionedUsers\n    } = props;\n    const createParamsDefault = () => {\n      const params = {};\n      params.message = message;\n      // if (isMentionEnabled && mentionedUserIds?.length > 0) {\n      if (isMentionEnabled && (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) > 0) {\n        // params.mentionedUserIds = mentionedUserIds;\n        params.mentionedUsers = mentionedUsers;\n      }\n      // if (isMentionEnabled && mentionTemplate && mentionedUserIds?.length > 0) {\n      if (isMentionEnabled && mentionTemplate && (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) > 0) {\n        params.mentionedMessageTemplate = mentionTemplate;\n      }\n      if (quoteMessage) {\n        params.isReplyToChannel = true;\n        params.parentMessageId = quoteMessage.messageId;\n      }\n      return params;\n    };\n    const createCustomPrams = onBeforeSendUserMessage && typeof onBeforeSendUserMessage === 'function';\n    if (createCustomPrams) {\n      logger.info('Channel: creating params using onBeforeSendUserMessage', onBeforeSendUserMessage);\n    }\n    const params = onBeforeSendUserMessage ? onBeforeSendUserMessage(message, quoteMessage) : createParamsDefault();\n    logger.info('Channel: Sending message has started', params);\n    currentGroupChannel.sendUserMessage(params).onPending(pendingMsg => {\n      pubSub.publish(PUBSUB_TOPICS.SEND_MESSAGE_START, {\n        /* pubSub is used instead of messagesDispatcher\n          to avoid redundantly calling `messageActionTypes.SEND_MESSAGEGE_START` */\n        message: pendingMsg,\n        channel: currentGroupChannel\n      });\n      setTimeout(() => scrollIntoLast(0, scrollRef));\n    }).onFailed((err, msg) => {\n      logger.warning('Channel: Sending message failed!', {\n        message: msg,\n        error: err\n      });\n      messagesDispatcher({\n        type: SEND_MESSAGEGE_FAILURE,\n        payload: msg\n      });\n    }).onSucceeded(msg => {\n      logger.info('Channel: Sending message success!', msg);\n      messagesDispatcher({\n        type: SEND_MESSAGEGE_SUCESS,\n        payload: msg\n      });\n    });\n  }, [currentGroupChannel, onBeforeSendUserMessage]);\n  return [messageInputRef, sendMessage];\n}\nfunction useSendFileMessageCallback(_ref, _ref2) {\n  let {\n    currentGroupChannel,\n    onBeforeSendFileMessage,\n    imageCompression = {}\n  } = _ref;\n  let {\n    logger,\n    pubSub,\n    scrollRef,\n    messagesDispatcher\n  } = _ref2;\n  const sendMessage = useCallback(function (file) {\n    let quoteMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const {\n      compressionRate,\n      resizingWidth,\n      resizingHeight\n    } = imageCompression;\n    const createCustomParams = onBeforeSendFileMessage && typeof onBeforeSendFileMessage === 'function';\n    const compressibleFileType = file.type === 'image/jpg' || file.type === 'image/png' || file.type === 'image/jpeg';\n    const compressibleRatio = compressionRate > 0 && compressionRate < 1;\n    // pxToNumber returns null if values are invalid\n    const compressibleDiamensions = pxToNumber(resizingWidth) || pxToNumber(resizingHeight);\n    const canCompressImage = compressibleFileType && (compressibleRatio || compressibleDiamensions);\n    const createParamsDefault = file_ => {\n      const params = {};\n      params.file = file_;\n      if (quoteMessage) {\n        params.isReplyToChannel = true;\n        params.parentMessageId = quoteMessage.messageId;\n      }\n      return params;\n    };\n    if (canCompressImage) {\n      // Using image compression\n      try {\n        const image = document.createElement('img');\n        image.src = URL.createObjectURL(file);\n        image.onload = () => {\n          URL.revokeObjectURL(image.src);\n          const canvas = document.createElement('canvas');\n          const imageWdith = image.naturalWidth || image.width;\n          const imageHeight = image.naturalHeight || image.height;\n          let targetWidth = pxToNumber(resizingWidth) || imageWdith;\n          let targetHeight = pxToNumber(resizingHeight) || imageHeight;\n\n          // In canvas.toBlob(callback, mimeType, qualityArgument)\n          // qualityArgument doesnt work\n          // so in case compressibleDiamensions are not present, we use ratio\n          if (file.type === 'image/png' && !compressibleDiamensions) {\n            targetWidth *= compressionRate;\n            targetHeight *= compressionRate;\n          }\n          canvas.width = targetWidth;\n          canvas.height = targetHeight;\n          const context = canvas.getContext('2d');\n          context.drawImage(image, 0, 0, targetWidth, targetHeight);\n          context.canvas.toBlob(newImageBlob => {\n            const compressedFile = new File([newImageBlob], file.name, {\n              type: file.type\n            });\n            if (createCustomParams) {\n              logger.info('Channel: Creating params using onBeforeSendFileMessage', onBeforeSendFileMessage);\n            }\n            const params = createCustomParams ? onBeforeSendFileMessage(compressedFile, quoteMessage) : createParamsDefault(compressedFile);\n            logger.info('Channel: Uploading file message start!', params);\n            currentGroupChannel.sendFileMessage(params).onPending(pendingMessage => {\n              pubSub.publish(PUBSUB_TOPICS.SEND_MESSAGE_START, {\n                /* pubSub is used instead of messagesDispatcher\n                  to avoid redundantly calling `messageActionTypes.SEND_MESSAGEGE_START` */\n                message: _objectSpread2(_objectSpread2({}, pendingMessage), {}, {\n                  url: URL.createObjectURL(compressedFile),\n                  // pending thumbnail message seems to be failed\n                  requestState: 'pending'\n                }),\n                channel: currentGroupChannel\n              });\n              setTimeout(() => scrollIntoLast(0, scrollRef), 1000);\n            }).onFailed((err, failedMessage) => {\n              logger.error('Channel: Sending file message failed!', {\n                failedMessage,\n                err\n              });\n              // eslint-disable-next-line no-param-reassign\n              failedMessage.localUrl = URL.createObjectURL(compressedFile);\n              // eslint-disable-next-line no-param-reassign\n              failedMessage.file = compressedFile;\n              messagesDispatcher({\n                type: SEND_MESSAGEGE_FAILURE,\n                payload: failedMessage\n              });\n            }).onSucceeded(succeededMessage => {\n              logger.info('Channel: Sending file message success!', succeededMessage);\n              messagesDispatcher({\n                type: SEND_MESSAGEGE_SUCESS,\n                payload: succeededMessage\n              });\n            });\n          }, file.type, compressionRate);\n        };\n      } catch (error) {\n        logger.error('Channel: Sending file message failed!', error);\n      }\n    } else {\n      // Not using image compression\n      if (createCustomParams) {\n        logger.info('Channel: creating params using onBeforeSendFileMessage', onBeforeSendFileMessage);\n      }\n      const params = onBeforeSendFileMessage ? onBeforeSendFileMessage(file, quoteMessage) : createParamsDefault(file);\n      logger.info('Channel: Uploading file message start!', params);\n      currentGroupChannel.sendFileMessage(params).onPending(pendingMsg => {\n        pubSub.publish(PUBSUB_TOPICS.SEND_MESSAGE_START, {\n          /* pubSub is used instead of messagesDispatcher\n            to avoid redundantly calling `messageActionTypes.SEND_MESSAGEGE_START` */\n          message: _objectSpread2(_objectSpread2({}, pendingMsg), {}, {\n            url: URL.createObjectURL(file),\n            // pending thumbnail message seems to be failed\n            requestState: 'pending'\n          }),\n          channel: currentGroupChannel\n        });\n        setTimeout(() => scrollIntoLast(0, scrollRef), 1000);\n      }).onFailed((error, message) => {\n        logger.error('Channel: Sending file message failed!', {\n          message,\n          error\n        });\n        // eslint-disable-next-line no-param-reassign\n        message.localUrl = URL.createObjectURL(file);\n        // eslint-disable-next-line no-param-reassign\n        message.file = file;\n        messagesDispatcher({\n          type: SEND_MESSAGEGE_FAILURE,\n          payload: message\n        });\n      }).onSucceeded(message => {\n        logger.info('Channel: Sending message success!', message);\n        messagesDispatcher({\n          type: SEND_MESSAGEGE_SUCESS,\n          payload: message\n        });\n      });\n    }\n  }, [currentGroupChannel, onBeforeSendFileMessage, imageCompression]);\n  return [sendMessage];\n}\nfunction useToggleReactionCallback(_ref, _ref2) {\n  let {\n    currentGroupChannel\n  } = _ref;\n  let {\n    logger\n  } = _ref2;\n  return useCallback((message, key, isReacted) => {\n    if (isReacted) {\n      currentGroupChannel.deleteReaction(message, key).then(res => {\n        logger.info('Delete reaction success', res);\n      }).catch(err => {\n        logger.warning('Delete reaction failed', err);\n      });\n      return;\n    }\n    currentGroupChannel.addReaction(message, key).then(res => {\n      logger.info('Add reaction success', res);\n    }).catch(err => {\n      logger.warning('Add reaction failed', err);\n    });\n  }, [currentGroupChannel]);\n}\nfunction useScrollToMessage(_ref, _ref2) {\n  let {\n    setInitialTimeStamp,\n    setAnimatedMessageId,\n    allMessages,\n    scrollRef\n  } = _ref;\n  let {\n    logger\n  } = _ref2;\n  return useCallback((createdAt, messageId) => {\n    const isPresent = allMessages.find(m => m.messageId === messageId);\n    setAnimatedMessageId(null);\n    setTimeout(() => {\n      if (isPresent) {\n        logger.info('Channel: scroll to message - message is present');\n        setAnimatedMessageId(messageId);\n        scrollToRenderedMessage(scrollRef, createdAt);\n      } else {\n        logger.info('Channel: scroll to message - fetching older messages');\n        setInitialTimeStamp(null);\n        setInitialTimeStamp(createdAt);\n        setAnimatedMessageId(messageId);\n      }\n    });\n  }, [setInitialTimeStamp, setAnimatedMessageId, allMessages]);\n}\nconst useSendVoiceMessageCallback = (_ref, _ref2) => {\n  let {\n    currentGroupChannel,\n    onBeforeSendVoiceMessage\n  } = _ref;\n  let {\n    logger,\n    pubSub,\n    scrollRef,\n    messagesDispatcher\n  } = _ref2;\n  const sendMessage = useCallback((file, duration, quoteMessage) => {\n    const messageParams = onBeforeSendVoiceMessage && typeof onBeforeSendVoiceMessage === 'function' ? onBeforeSendVoiceMessage(file, quoteMessage) : {\n      file,\n      fileName: VOICE_MESSAGE_FILE_NAME,\n      mimeType: VOICE_MESSAGE_MIME_TYPE,\n      metaArrays: [new MessageMetaArray({\n        key: META_ARRAY_VOICE_DURATION_KEY,\n        value: [`${duration}`]\n      }), new MessageMetaArray({\n        key: META_ARRAY_MESSAGE_TYPE_KEY,\n        value: [META_ARRAY_MESSAGE_TYPE_VALUE__VOICE]\n      })]\n    };\n    if (quoteMessage) {\n      messageParams.isReplyToChannel = true;\n      messageParams.parentMessageId = quoteMessage.messageId;\n    }\n    logger.info('Channel: Start sending voice message', messageParams);\n    currentGroupChannel.sendFileMessage(messageParams).onPending(pendingMessage => {\n      pubSub.publish(PUBSUB_TOPICS.SEND_MESSAGE_START, {\n        /* pubSub is used instead of messagesDispatcher\n          to avoid redundantly calling `messageActionTypes.SEND_MESSAGEGE_START` */\n        message: pendingMessage,\n        channel: currentGroupChannel\n      });\n      setTimeout(() => scrollIntoLast(0, scrollRef), 1000);\n    }).onFailed((err, failedMessage) => {\n      logger.error('Channel: Sending voice message failed!', {\n        failedMessage,\n        err\n      });\n      messagesDispatcher({\n        type: SEND_MESSAGEGE_FAILURE,\n        payload: failedMessage\n      });\n    }).onSucceeded(succeededMessage => {\n      logger.info('Channel: Sending voice message success!', succeededMessage);\n      messagesDispatcher({\n        type: SEND_MESSAGEGE_SUCESS,\n        payload: succeededMessage\n      });\n    });\n  }, [currentGroupChannel, onBeforeSendVoiceMessage]);\n  return [sendMessage];\n};\nlet ThreadReplySelectType = /*#__PURE__*/function (ThreadReplySelectType) {\n  ThreadReplySelectType[\"PARENT\"] = \"PARENT\";\n  ThreadReplySelectType[\"THREAD\"] = \"THREAD\";\n  return ThreadReplySelectType;\n}({});\nconst ChannelContext = /*#__PURE__*/React__default.createContext(undefined);\nconst ChannelProvider = props => {\n  var _globalStore$stores, _globalStore$stores$s, _globalStore$stores2, _globalStore$stores2$;\n  const {\n    channelUrl,\n    children,\n    isReactionEnabled,\n    isMessageGroupingEnabled = true,\n    showSearchIcon,\n    animatedMessage,\n    highlightedMessage,\n    startingPoint,\n    onBeforeSendUserMessage,\n    onBeforeSendFileMessage,\n    onBeforeUpdateUserMessage,\n    onBeforeSendVoiceMessage,\n    onChatHeaderActionClick,\n    onSearchClick,\n    onBackClick,\n    replyType,\n    threadReplySelectType = ThreadReplySelectType.THREAD,\n    queries,\n    filterMessageList,\n    disableMarkAsRead = false,\n    onReplyInThread,\n    onQuoteMessageClick,\n    onMessageAnimated,\n    onMessageHighlighted\n  } = props;\n  const globalStore = useSendbirdStateContext();\n  const {\n    config\n  } = globalStore;\n  const {\n    pubSub,\n    logger,\n    userId,\n    isOnline,\n    imageCompression,\n    isMentionEnabled,\n    isVoiceMessageEnabled,\n    onUserProfileMessage,\n    markAsReadScheduler\n  } = config;\n  const sdk = globalStore === null || globalStore === void 0 ? void 0 : (_globalStore$stores = globalStore.stores) === null || _globalStore$stores === void 0 ? void 0 : (_globalStore$stores$s = _globalStore$stores.sdkStore) === null || _globalStore$stores$s === void 0 ? void 0 : _globalStore$stores$s.sdk;\n  const sdkInit = globalStore === null || globalStore === void 0 ? void 0 : (_globalStore$stores2 = globalStore.stores) === null || _globalStore$stores2 === void 0 ? void 0 : (_globalStore$stores2$ = _globalStore$stores2.sdkStore) === null || _globalStore$stores2$ === void 0 ? void 0 : _globalStore$stores2$.initialized;\n  const [initialTimeStamp, setInitialTimeStamp] = useState(startingPoint);\n  useEffect(() => {\n    setInitialTimeStamp(startingPoint);\n  }, [startingPoint, channelUrl]);\n  const [animatedMessageId, setAnimatedMessageId] = useState(0);\n  const [highLightedMessageId, setHighLightedMessageId] = useState(highlightedMessage);\n  useEffect(() => {\n    setHighLightedMessageId(highlightedMessage);\n  }, [highlightedMessage]);\n  const userFilledMessageListQuery = queries === null || queries === void 0 ? void 0 : queries.messageListParams;\n  const [quoteMessage, setQuoteMessage] = useState(null);\n  const [messagesStore, messagesDispatcher] = useReducer(reducer, messagesInitialState);\n  const scrollRef = useRef(null);\n  const {\n    allMessages,\n    loading,\n    initialized,\n    unreadSince,\n    isInvalid,\n    currentGroupChannel,\n    hasMorePrev,\n    oldestMessageTimeStamp,\n    hasMoreNext,\n    latestMessageTimeStamp,\n    emojiContainer,\n    readStatus\n  } = messagesStore;\n  const isSuper = (currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.isSuper) || false;\n  const isBroadcast = (currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.isBroadcast) || false;\n  const usingReaction = getIsReactionEnabled({\n    isBroadcast,\n    isSuper,\n    globalLevel: config === null || config === void 0 ? void 0 : config.isReactionEnabled,\n    moduleLevel: isReactionEnabled\n  });\n  const emojiAllMap = useMemo(() => usingReaction ? getAllEmojisMapFromEmojiContainer(emojiContainer) : new Map(), [emojiContainer]);\n  const nicknamesMap = useMemo(() => usingReaction && currentGroupChannel ? getNicknamesMapFromMembers(currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.members) : new Map(), [currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.members]);\n\n  // Animate message\n  useEffect(() => {\n    if (animatedMessage) {\n      setAnimatedMessageId(animatedMessage);\n    }\n  }, [animatedMessage]);\n\n  // Scrollup is default scroll for channel\n  const onScrollCallback = useScrollCallback({\n    currentGroupChannel,\n    oldestMessageTimeStamp,\n    userFilledMessageListQuery,\n    replyType,\n    isVoiceMessageEnabled\n  }, {\n    hasMorePrev,\n    logger,\n    messagesDispatcher,\n    sdk\n  });\n  const scrollToMessage = useScrollToMessage({\n    setInitialTimeStamp,\n    setAnimatedMessageId,\n    allMessages,\n    scrollRef\n  }, {\n    logger\n  });\n\n  // onScrollDownCallback is added for navigation to different timestamps on messageSearch\n  // hasMorePrev, onScrollCallback -> scroll up(default behavior)\n  // hasMoreNext, onScrollDownCallback -> scroll down\n  const onScrollDownCallback = useScrollDownCallback({\n    currentGroupChannel,\n    latestMessageTimeStamp,\n    userFilledMessageListQuery,\n    hasMoreNext,\n    replyType,\n    isVoiceMessageEnabled\n  }, {\n    logger,\n    messagesDispatcher,\n    sdk\n  });\n  const toggleReaction = useToggleReactionCallback({\n    currentGroupChannel\n  }, {\n    logger\n  });\n\n  // to create message-datasource\n  // this hook sets currentGroupChannel asynchronously\n  useSetChannel({\n    channelUrl,\n    sdkInit,\n    disableMarkAsRead\n  }, {\n    messagesDispatcher,\n    sdk,\n    logger,\n    markAsReadScheduler\n  });\n\n  // to set quote message as null\n  useEffect(() => {\n    setQuoteMessage(null);\n  }, [channelUrl]);\n\n  // Hook to handle ChannelEvents and send values to useReducer using messagesDispatcher\n  useHandleChannelEvents({\n    currentGroupChannel,\n    sdkInit,\n    currentUserId: userId,\n    disableMarkAsRead\n  }, {\n    messagesDispatcher,\n    sdk,\n    logger,\n    scrollRef,\n    setQuoteMessage\n  });\n\n  // hook that fetches messages when channel changes\n  // to be clear here useGetChannel sets currentGroupChannel\n  // and useInitialMessagesFetch executes when currentGroupChannel changes\n  // p.s This one executes on initialTimeStamp change too\n  useInitialMessagesFetch({\n    currentGroupChannel,\n    userFilledMessageListQuery,\n    initialTimeStamp,\n    latestMessageTimeStamp,\n    replyType,\n    isVoiceMessageEnabled\n  }, {\n    logger,\n    scrollRef,\n    messagesDispatcher\n  });\n\n  // handles API calls from withSendbird\n  useEffect(() => {\n    const subscriber = pubSubHandler({\n      channelUrl,\n      pubSub,\n      dispatcher: messagesDispatcher,\n      scrollRef\n    });\n    return () => {\n      pubSubHandleRemover(subscriber);\n    };\n  }, [channelUrl, sdkInit]);\n\n  // handling connection breaks\n  useHandleReconnect({\n    isOnline,\n    replyType,\n    disableMarkAsRead\n  }, {\n    logger,\n    sdk,\n    scrollRef,\n    currentGroupChannel,\n    messagesDispatcher,\n    userFilledMessageListQuery,\n    markAsReadScheduler\n  });\n\n  // callbacks for Message CURD actions\n  const deleteMessage = useDeleteMessageCallback({\n    currentGroupChannel,\n    messagesDispatcher\n  }, {\n    logger\n  });\n  const updateMessage = useUpdateMessageCallback({\n    currentGroupChannel,\n    messagesDispatcher,\n    onBeforeUpdateUserMessage,\n    isMentionEnabled\n  }, {\n    logger,\n    pubSub\n  });\n  const resendMessage = useResendMessageCallback({\n    currentGroupChannel,\n    messagesDispatcher\n  }, {\n    logger\n  });\n  const [messageInputRef, sendMessage] = useSendMessageCallback({\n    currentGroupChannel,\n    onBeforeSendUserMessage,\n    isMentionEnabled\n  }, {\n    logger,\n    pubSub,\n    scrollRef,\n    messagesDispatcher\n  });\n  const [sendFileMessage] = useSendFileMessageCallback({\n    currentGroupChannel,\n    onBeforeSendFileMessage,\n    imageCompression\n  }, {\n    logger,\n    pubSub,\n    scrollRef,\n    messagesDispatcher\n  });\n  const [sendVoiceMessage] = useSendVoiceMessageCallback({\n    currentGroupChannel,\n    onBeforeSendVoiceMessage\n  }, {\n    logger,\n    pubSub,\n    scrollRef,\n    messagesDispatcher\n  });\n  return /*#__PURE__*/React__default.createElement(ChannelContext.Provider, {\n    value: {\n      // props\n      channelUrl,\n      isReactionEnabled: usingReaction,\n      isMessageGroupingEnabled,\n      showSearchIcon,\n      highlightedMessage,\n      startingPoint,\n      onBeforeSendUserMessage,\n      onBeforeSendFileMessage,\n      onBeforeUpdateUserMessage,\n      onChatHeaderActionClick,\n      onSearchClick,\n      onBackClick,\n      replyType,\n      threadReplySelectType,\n      queries,\n      filterMessageList,\n      disableMarkAsRead,\n      onReplyInThread,\n      onQuoteMessageClick,\n      onMessageAnimated,\n      onMessageHighlighted,\n      // messagesStore\n      allMessages,\n      loading,\n      initialized,\n      unreadSince,\n      isInvalid,\n      currentGroupChannel,\n      hasMorePrev,\n      hasMoreNext,\n      oldestMessageTimeStamp,\n      latestMessageTimeStamp,\n      emojiContainer,\n      readStatus,\n      // utils\n      scrollToMessage,\n      quoteMessage,\n      setQuoteMessage,\n      deleteMessage,\n      updateMessage,\n      resendMessage,\n      messageInputRef,\n      sendMessage,\n      sendFileMessage,\n      sendVoiceMessage,\n      initialTimeStamp,\n      messageActionTypes,\n      messagesDispatcher,\n      setInitialTimeStamp,\n      setAnimatedMessageId,\n      setHighLightedMessageId,\n      animatedMessageId,\n      highLightedMessageId,\n      nicknamesMap,\n      emojiAllMap,\n      onScrollCallback,\n      onScrollDownCallback,\n      scrollRef,\n      toggleReaction\n    }\n  }, /*#__PURE__*/React__default.createElement(UserProfileProvider, {\n    disableUserProfile: props === null || props === void 0 ? void 0 : props.disableUserProfile,\n    renderUserProfile: props === null || props === void 0 ? void 0 : props.renderUserProfile,\n    onUserProfileMessage: onUserProfileMessage\n  }, children));\n};\nconst useChannelContext = () => React__default.useContext(ChannelContext);\nexport { ChannelProvider as C, ThreadReplySelectType as T, isDisabledBecauseFrozen as a, isDisabledBecauseMuted as b, compareMessagesForGrouping as c, isOperator as d, getIsReactionEnabled as g, isAboutSame as i, useChannelContext as u };","map":{"version":3,"mappings":"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","names":["RESET_MESSAGES","FETCH_INITIAL_MESSAGES_START","FETCH_INITIAL_MESSAGES_SUCCESS","FETCH_INITIAL_MESSAGES_FAILURE","FETCH_PREV_MESSAGES_SUCCESS","FETCH_PREV_MESSAGES_FAILURE","FETCH_NEXT_MESSAGES_SUCCESS","FETCH_NEXT_MESSAGES_FAILURE","SEND_MESSAGEGE_START","SEND_MESSAGEGE_SUCESS","SEND_MESSAGEGE_FAILURE","RESEND_MESSAGEGE_START","ON_MESSAGE_RECEIVED","ON_MESSAGE_UPDATED","ON_MESSAGE_THREAD_INFO_UPDATED","ON_MESSAGE_DELETED","ON_MESSAGE_DELETED_BY_REQ_ID","SET_CURRENT_CHANNEL","SET_CHANNEL_INVALID","MARK_AS_READ","ON_REACTION_UPDATED","SET_EMOJI_CONTAINER","MESSAGE_LIST_PARAMS_CHANGED","UNDEFINED","SUCCEEDED","FAILED","PENDING","getSendingMessageStatus","scrollToRenderedMessage","scrollRef","initialTimeStamp","container","current","element","querySelectorAll","_container$querySelec","containerHeight","offsetHeight","elementHeight","elementOffset","scrollTop","offsetTop","scrollIntoLast","initialTry","MAX_TRIES","currentTry","scrollDOM","document","querySelector","scrollHeight","error","setTimeout","pubSubHandleRemover","subscriber","forEach","s","remove","pubSubHandler","_ref","channelUrl","pubSub","dispatcher","Map","subscribe","set","topics","SEND_USER_MESSAGE","msg","channel","message","url","type","channelActions","payload","SEND_MESSAGE_START","SEND_FILE_MESSAGE","UPDATE_USER_MESSAGE","fromSelector","DELETE_MESSAGE","messageId","isOperator","groupChannel","myRole","isDisabledBecauseFrozen","isFrozen","isDisabledBecauseMuted","myMutedState","getAllEmojisMapFromEmojiContainer","emojiContainer","emojiCategories","allEmojisMap","categoryIndex","length","emojis","emojiIndex","key","getNicknamesMapFromMembers","members","nicknamesMap","memberIndex","userId","nickname","getUniqueListBy","arr","map","item","values","getUniqueListByMessageId","sortByCreatedAt","messages","sort","a","b","createdAt","mergeAndSortMessages","oldMessages","newMessages","lastOldMessage","firstNewMessage","mergedMessages","unique","getMessageCreatedAt","format","isSameGroup","comparingMessage","currentChannel","messageType","sender","_message$sender","_comparingMessage$sen","sendingStatus","_message$sender2","_comparingMessage$sen2","isReadMessage","compareMessagesForGrouping","prevMessage","currMessage","nextMessage","replyType","threadInfo","isAcceptable","passUnsuccessfullMessages","allMessages","newMessage","lastIndexOfSucceededMessage","isAdminMessage","lastIndexOf","splice","pxToNumber","px","parsed","Number","parseFloat","isNaN","isAboutSame","Math","abs","getIsReactionEnabled","isBroadcast","isSuper","globalLevel","moduleLevel","initialized","loading","currentGroupChannel","hasMorePrev","oldestMessageTimeStamp","hasMoreNext","latestMessageTimeStamp","unreadSince","isInvalid","messageListParams","getOldestMessageTimeStamp","oldestMessage","getLatestMessageTimeStamp","latestMessage","reducer","state","action","actionTypes","filter","m","_state$currentGroupCh","_state$currentGroupCh2","PREV_RESULT_SIZE","duplicatedMessageIds","updatedOldMessages","duplicatedMessage","find","compareIds","push","updatedAt","filteredNewMessages","_state$currentGroupCh3","NEXT_RESULT_SIZE","sortedMessages","_state$currentGroupCh4","filteredMessages","reqId","pendingIndex","findIndex","slice","failed","currentGroupChannelUrl","some","filterMessageListParams","senderMember","profileUrl","friendName","member","Date","_state$currentGroupCh5","parentMessageId","parentMessage","event","targetMessageId","_state$currentGroupCh6","_state$currentGroupCh7","_action$payload","_action$payload$chann","applyReactionEvent","DELIVERY_RECIPT","useHandleChannelEvents","sdkInit","currentUserId","disableMarkAsRead","sdk","logger","setQuoteMessage","messagesDispatcher","store","useSendbirdStateContext","markAsReadScheduler","markAsDeliveredScheduler","disableMarkAsDelivered","config","canSetMarkAsDelivered","stores","sdkStore","_store$stores$sdkStor","appInfo","_store$stores$sdkStor2","premiumFeatureList","_store$stores$sdkStor3","feature","useEffect","channelHandlerId","uuidv4","channelHandler","onMessageReceived","scrollToEnd","info","messageActions","getElementById","_document$getElementB","childElementCount","_document$getElementB2","warning","onUnreadMemberStatusUpdated","onUndeliveredMemberStatusUpdated","onMessageUpdated","onThreadInfoUpdated","threadInfoUpdateEvent","onMessageDeleted","onReactionUpdated","reactionEvent","onChannelChanged","onChannelFrozen","onChannelUnfrozen","onUserMuted","user","onUserUnmuted","onUserBanned","currentUser","_sdk$currentUser","onOperatorUpdated","users","onUserLeft","_sdk$groupChannel","addGroupChannelHandler","GroupChannelHandler","_sdk$groupChannel2","removeGroupChannelHandler","useSetChannel","getChannel","then","messageActionTypes","catch","e","getAllEmoji","emojiContainer_","err","useInitialMessagesFetch","userFilledMessageListQuery","getMessagesByTimestamp","prevResultSize","nextResultSize","isInclusive","includeReactions","includeMetaArray","includeThreadInfo","includeParentMessageInfo","ReplyType","ONLY_REPLY_TO_CHANNEL","Object","keys","getTime","finally","utils","useHandleReconnect","isOnline","wasOffline","isReactionEnabled","_sdk$appInfo","useReaction","lastMessageTime","useScrollCallback","useCallback","cb","useScrollDownCallback","useDeleteMessageCallback","requestState","Promise","resolve","reject","deleteMessage","useUpdateMessageCallback","onBeforeUpdateUserMessage","isMentionEnabled","props","callback","mentionedUsers","mentionTemplate","createParamsDefault","params","mentionedMessageTemplate","createCustomPrams","updateUserMessage","publish","useResendMessageCallback","failedMessage","file","isResendable","resendUserMessage","resendFileMessage","console","useSendMessageCallback","onBeforeSendUserMessage","messageInputRef","useRef","sendMessage","quoteMessage","isReplyToChannel","sendUserMessage","onPending","pendingMsg","onFailed","onSucceeded","useSendFileMessageCallback","onBeforeSendFileMessage","imageCompression","compressionRate","resizingWidth","resizingHeight","createCustomParams","compressibleFileType","compressibleRatio","compressibleDiamensions","canCompressImage","file_","image","createElement","src","URL","createObjectURL","onload","revokeObjectURL","canvas","imageWdith","naturalWidth","width","imageHeight","naturalHeight","height","targetWidth","targetHeight","context","getContext","drawImage","toBlob","newImageBlob","compressedFile","File","name","sendFileMessage","pendingMessage","localUrl","succeededMessage","useToggleReactionCallback","isReacted","deleteReaction","res","addReaction","useScrollToMessage","setInitialTimeStamp","setAnimatedMessageId","isPresent","useSendVoiceMessageCallback","onBeforeSendVoiceMessage","duration","messageParams","fileName","VOICE_MESSAGE_FILE_NAME","mimeType","VOICE_MESSAGE_MIME_TYPE","metaArrays","MessageMetaArray","META_ARRAY_VOICE_DURATION_KEY","value","META_ARRAY_MESSAGE_TYPE_KEY","META_ARRAY_MESSAGE_TYPE_VALUE__VOICE","ThreadReplySelectType","ChannelContext","React","createContext","undefined","ChannelProvider","children","isMessageGroupingEnabled","showSearchIcon","animatedMessage","highlightedMessage","startingPoint","onChatHeaderActionClick","onSearchClick","onBackClick","threadReplySelectType","THREAD","queries","filterMessageList","onReplyInThread","onQuoteMessageClick","onMessageAnimated","onMessageHighlighted","globalStore","isVoiceMessageEnabled","onUserProfileMessage","_globalStore$stores","_globalStore$stores$s","_globalStore$stores2","_globalStore$stores2$","useState","animatedMessageId","highLightedMessageId","setHighLightedMessageId","messagesStore","useReducer","messagesReducer","messagesInitialState","readStatus","usingReaction","emojiAllMap","useMemo","onScrollCallback","scrollToMessage","onScrollDownCallback","toggleReaction","useGetChannel","updateMessage","resendMessage","sendVoiceMessage","Provider","UserProfileProvider","disableUserProfile","renderUserProfile","useChannelContext","useContext"],"sources":["C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\dux\\actionTypes.js","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\utils.js","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\utils\\getIsReactionEnabled.ts","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\dux\\initialState.js","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\dux\\reducers.js","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\hooks\\useHandleChannelEvents.ts","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\hooks\\useGetChannel.js","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\hooks\\useInitialMessagesFetch.js","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\hooks\\useHandleReconnect.ts","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\hooks\\useScrollCallback.js","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\hooks\\useScrollDownCallback.js","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\hooks\\useDeleteMessageCallback.js","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\hooks\\useUpdateMessageCallback.js","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\hooks\\useResendMessageCallback.js","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\hooks\\useSendMessageCallback.js","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\hooks\\useSendFileMessageCallback.js","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\hooks\\useToggleReactionCallback.js","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\hooks\\useScrollToMessage.ts","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\hooks\\useSendVoiceMessageCallback.ts","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Channel\\context\\ChannelProvider.tsx"],"sourcesContent":["export const RESET_MESSAGES = 'RESET_MESSAGES';\n\nexport const FETCH_INITIAL_MESSAGES_START = 'FETCH_INITIAL_MESSAGES_START';\nexport const FETCH_INITIAL_MESSAGES_SUCCESS = 'FETCH_INITIAL_MESSAGES_SUCCESS';\nexport const FETCH_INITIAL_MESSAGES_FAILURE = 'FETCH_INITIAL_MESSAGES_FAILURE';\nexport const FETCH_PREV_MESSAGES_SUCCESS = 'FETCH_PREV_MESSAGES_SUCCESS';\nexport const FETCH_PREV_MESSAGES_FAILURE = 'FETCH_PREV_MESSAGES_FAILURE';\nexport const FETCH_NEXT_MESSAGES_SUCCESS = 'FETCH_NEXT_MESSAGES_SUCCESS';\nexport const FETCH_NEXT_MESSAGES_FAILURE = 'FETCH_NEXT_MESSAGES_FAILURE';\n\nexport const SEND_MESSAGEGE_START = 'SEND_MESSAGEGE_START';\nexport const SEND_MESSAGEGE_SUCESS = 'SEND_MESSAGEGE_SUCESS';\nexport const SEND_MESSAGEGE_FAILURE = 'SEND_MESSAGEGE_FAILURE';\n\nexport const RESEND_MESSAGEGE_START = 'RESEND_MESSAGEGE_START';\n\nexport const ON_MESSAGE_RECEIVED = 'ON_MESSAGE_RECEIVED';\nexport const ON_MESSAGE_UPDATED = 'ON_MESSAGE_UPDATED';\nexport const ON_MESSAGE_THREAD_INFO_UPDATED = 'ON_MESSAGE_THREAD_INFO_UPDATED';\nexport const ON_MESSAGE_DELETED = 'ON_MESSAGE_DELETED';\nexport const ON_MESSAGE_DELETED_BY_REQ_ID = 'ON_MESSAGE_DELETED_BY_REQ_ID';\n\nexport const SET_CURRENT_CHANNEL = 'SET_CURRENT_CHANNEL';\nexport const SET_CHANNEL_INVALID = 'SET_CHANNEL_INVALID';\nexport const MARK_AS_READ = 'MARK_AS_READ';\n\nexport const ON_REACTION_UPDATED = 'ON_REACTION_UPDATED';\nexport const SET_EMOJI_CONTAINER = 'SET_EMOJI_CONTAINER';\n\nexport const MESSAGE_LIST_PARAMS_CHANGED = 'MESSAGE_LIST_PARAMS_CHANGED';\n","import format from 'date-fns/format';\nimport * as channelActions from './dux/actionTypes';\nimport topics from '../../../lib/pubSub/topics';\n\nimport { getSendingMessageStatus, isReadMessage } from '../../../utils';\nimport { OutgoingMessageStates } from '../../../utils/exports/getOutgoingMessageState';\n\nconst UNDEFINED = 'undefined';\nconst { SUCCEEDED, FAILED, PENDING } = getSendingMessageStatus();\n\nexport const scrollToRenderedMessage = (scrollRef, initialTimeStamp) => {\n  try {\n    const container = scrollRef.current;\n    // scroll into the message with initialTimeStamp\n    const element = container.querySelectorAll(`[data-sb-created-at=\"${initialTimeStamp}\"]`)?.[0];\n    if (element) {\n      // Calculate the offset of the element from the top of the container\n      const containerHeight = container.offsetHeight;\n      const elementHeight = element.offsetHeight;\n      const elementOffset = (containerHeight - elementHeight) / 2;\n      // Set the scroll position of the container to bring the element to the middle\n      container.scrollTop = element.offsetTop - elementOffset;\n    }\n  } catch {\n    // do nothing\n  }\n};\n\n/* eslint-disable default-param-last */\nexport const scrollIntoLast = (initialTry = 0, scrollRef) => {\n  const MAX_TRIES = 10;\n  const currentTry = initialTry;\n  if (currentTry > MAX_TRIES) {\n    return;\n  }\n  try {\n    const scrollDOM = scrollRef?.current || document.querySelector('.sendbird-conversation__messages-padding');\n    // eslint-disable-next-line no-multi-assign\n    scrollDOM.scrollTop = scrollDOM.scrollHeight;\n  } catch (error) {\n    setTimeout(() => {\n      scrollIntoLast(currentTry + 1, scrollRef);\n    }, 500 * currentTry);\n  }\n};\n\nexport const pubSubHandleRemover = (subscriber) => {\n  subscriber.forEach((s) => {\n    try {\n      s.remove();\n    } catch {\n      //\n    }\n  });\n};\n\nexport const pubSubHandler = ({\n  channelUrl,\n  pubSub,\n  dispatcher,\n  scrollRef,\n}) => {\n  const subscriber = new Map();\n  if (!pubSub || !pubSub.subscribe) return subscriber;\n  subscriber.set(topics.SEND_USER_MESSAGE, pubSub.subscribe(topics.SEND_USER_MESSAGE, (msg) => {\n    const { channel, message } = msg;\n    scrollIntoLast(0, scrollRef);\n    if (channelUrl === channel?.url) {\n      dispatcher({\n        type: channelActions.SEND_MESSAGEGE_SUCESS,\n        payload: message,\n      });\n    }\n  }));\n  subscriber.set(topics.SEND_MESSAGE_START, pubSub.subscribe(topics.SEND_MESSAGE_START, (msg) => {\n    const { channel, message } = msg;\n    if (channelUrl === channel?.url) {\n      dispatcher({\n        type: channelActions.SEND_MESSAGEGE_START,\n        payload: message,\n      });\n    }\n  }));\n  subscriber.set(topics.SEND_FILE_MESSAGE, pubSub.subscribe(topics.SEND_FILE_MESSAGE, (msg) => {\n    const { channel, message } = msg;\n    scrollIntoLast(0, scrollRef);\n    if (channelUrl === channel?.url) {\n      dispatcher({\n        type: channelActions.SEND_MESSAGEGE_SUCESS,\n        payload: message,\n      });\n    }\n  }));\n  subscriber.set(topics.UPDATE_USER_MESSAGE, pubSub.subscribe(topics.UPDATE_USER_MESSAGE, (msg) => {\n    const { channel, message, fromSelector } = msg;\n    if (fromSelector && (channelUrl === channel?.url)) {\n      dispatcher({\n        type: channelActions.ON_MESSAGE_UPDATED,\n        payload: { channel, message },\n      });\n    }\n  }));\n  subscriber.set(topics.DELETE_MESSAGE, pubSub.subscribe(topics.DELETE_MESSAGE, (msg) => {\n    const { channel, messageId } = msg;\n    if (channelUrl === channel?.url) {\n      dispatcher({\n        type: channelActions.ON_MESSAGE_DELETED,\n        payload: messageId,\n      });\n    }\n  }));\n\n  return subscriber;\n};\n\nexport const getParsedStatus = (message, currentGroupChannel) => {\n  if (message.requestState === FAILED) {\n    return OutgoingMessageStates.FAILED;\n  }\n\n  if (message.requestState === PENDING) {\n    return OutgoingMessageStates.PENDING;\n  }\n\n  if (message.requestState === SUCCEEDED) {\n    if (!currentGroupChannel) {\n      return OutgoingMessageStates.SENT;\n    }\n\n    const unreadMemberCount = currentGroupChannel?.getUnreadMemberCount(message);\n    if (unreadMemberCount === 0) {\n      return OutgoingMessageStates.READ;\n    }\n\n    const isDelivered = currentGroupChannel?.getUndeliveredMemberCount(message) === 0;\n    if (isDelivered) {\n      return OutgoingMessageStates.DELIVERED;\n    }\n\n    return OutgoingMessageStates.SENT;\n  }\n\n  return null;\n};\n\nexport const isOperator = (groupChannel = {}) => {\n  const myRole = groupChannel?.myRole;\n  return myRole === 'operator';\n};\n\nexport const isDisabledBecauseFrozen = (groupChannel = {}) => {\n  const isFrozen = groupChannel?.isFrozen;\n  return isFrozen && !isOperator(groupChannel);\n};\n\nexport const isDisabledBecauseMuted = (groupChannel = {}) => {\n  const myMutedState = groupChannel?.myMutedState;\n  return myMutedState === 'muted';\n};\n\nexport const getEmojiCategoriesFromEmojiContainer = (emojiContainer = {}) => (\n  emojiContainer.emojiCategories ? emojiContainer.emojiCategories : []\n);\n\nexport const getAllEmojisFromEmojiContainer = (emojiContainer = {}) => {\n  const { emojiCategories = [] } = emojiContainer;\n  const allEmojis = [];\n\n  for (let categoryIndex = 0; categoryIndex < emojiCategories.length; categoryIndex += 1) {\n    const { emojis } = emojiCategories[categoryIndex];\n    for (let emojiIndex = 0; emojiIndex < emojis.length; emojiIndex += 1) {\n      allEmojis.push(emojis[emojiIndex]);\n    }\n  }\n  return allEmojis;\n};\n\nexport const getEmojisFromEmojiContainer = (emojiContainer = {}, emojiCategoryId = '') => (\n  emojiContainer.emojiCategories\n    ? emojiContainer.emojiCategories\n      .filter((emojiCategory) => emojiCategory.id === emojiCategoryId)[0].emojis\n    : []\n);\n\nexport const getAllEmojisMapFromEmojiContainer = (emojiContainer = {}) => {\n  const { emojiCategories = [] } = emojiContainer;\n  const allEmojisMap = new Map();\n\n  for (let categoryIndex = 0; categoryIndex < emojiCategories.length; categoryIndex += 1) {\n    const { emojis } = emojiCategories[categoryIndex];\n    for (let emojiIndex = 0; emojiIndex < emojis.length; emojiIndex += 1) {\n      const { key, url } = emojis[emojiIndex];\n      allEmojisMap.set(key, url);\n    }\n  }\n  return allEmojisMap;\n};\n\nexport const getNicknamesMapFromMembers = (members = []) => {\n  const nicknamesMap = new Map();\n  for (let memberIndex = 0; memberIndex < members.length; memberIndex += 1) {\n    const { userId, nickname } = members[memberIndex];\n    nicknamesMap.set(userId, nickname);\n  }\n  return nicknamesMap;\n};\n\nconst getUniqueListBy = (arr, key) => [...new Map(arr.map((item) => [item[key], item])).values()];\nconst getUniqueListByMessageId = (arr) => getUniqueListBy(arr, 'messageId');\nconst sortByCreatedAt = (messages) => messages.sort((a, b) => a.createdAt - b.createdAt);\n\nexport const mergeAndSortMessages = (oldMessages, newMessages) => {\n  const lastOldMessage = oldMessages[oldMessages.length - 1];\n  const firstNewMessage = newMessages[0];\n  // If the last message of oldMessages is older than the first message of newMessages,\n  // then we can safely append newMessages to oldMessages.\n  if (lastOldMessage?.createdAt < firstNewMessage?.createdAt) {\n    return [...oldMessages, ...newMessages];\n  }\n\n  // todo: optimize this\n  // If the last message of oldMessages is newer than the first message of newMessages,\n  // then we need to merge the two arrays and sort them by createdAt.\n  const mergedMessages = [...oldMessages, ...newMessages];\n  const unique = getUniqueListByMessageId(mergedMessages);\n  return sortByCreatedAt(unique);\n};\n\nexport const getMessageCreatedAt = (message) => format(message.createdAt, 'p');\n\nexport const isSameGroup = (message, comparingMessage, currentChannel) => {\n  if (!(message\n    && comparingMessage\n    && message.messageType\n    && message.messageType !== 'admin'\n    && comparingMessage.messageType\n    && comparingMessage?.messageType !== 'admin'\n    && message?.sender\n    && comparingMessage?.sender\n    && message?.createdAt\n    && comparingMessage?.createdAt\n    && message?.sender?.userId\n    && comparingMessage?.sender?.userId\n  )) {\n    return false;\n  }\n  return (\n    message?.sendingStatus === comparingMessage?.sendingStatus\n    && message?.sender?.userId === comparingMessage?.sender?.userId\n    && getMessageCreatedAt(message) === getMessageCreatedAt(comparingMessage)\n    && isReadMessage(currentChannel, message) === isReadMessage(currentChannel, comparingMessage)\n  );\n};\n\nexport const compareMessagesForGrouping = (\n  prevMessage,\n  currMessage,\n  nextMessage,\n  currentChannel,\n  replyType,\n) => {\n  if (replyType === 'THREAD' && currMessage?.threadInfo) {\n    return [false, false];\n  }\n  const sendingStatus = currMessage?.sendingStatus || '';\n  const isAcceptable = sendingStatus !== 'pending' && sendingStatus !== 'failed';\n  return [\n    isSameGroup(prevMessage, currMessage, currentChannel) && isAcceptable,\n    isSameGroup(currMessage, nextMessage, currentChannel) && isAcceptable,\n  ];\n};\n\nexport const hasOwnProperty = (property) => (payload) => {\n  // eslint-disable-next-line no-prototype-builtins\n  if (payload && payload.hasOwnProperty && payload.hasOwnProperty(property)) {\n    return true;\n  }\n  return false;\n};\n\nexport const passUnsuccessfullMessages = (allMessages, newMessage) => {\n  const { sendingStatus = UNDEFINED } = newMessage;\n  if (sendingStatus === SUCCEEDED || sendingStatus === PENDING) {\n    const lastIndexOfSucceededMessage = allMessages\n      .map((message) => (\n        message.sendingStatus\n        || ((message.isAdminMessage && message.isAdminMessage()) ? SUCCEEDED : UNDEFINED)\n      ))\n      .lastIndexOf(SUCCEEDED);\n    if (lastIndexOfSucceededMessage + 1 < allMessages.length) {\n      const messages = [...allMessages];\n      messages.splice(lastIndexOfSucceededMessage + 1, 0, newMessage);\n      return messages;\n    }\n  }\n  return [\n    ...allMessages,\n    newMessage,\n  ];\n};\n\nexport const pxToNumber = (px) => {\n  if (typeof px === 'number') {\n    return px;\n  }\n  if (typeof px === 'string') {\n    const parsed = Number.parseFloat(px);\n    if (!Number.isNaN(parsed)) {\n      return parsed;\n    }\n  }\n  return null;\n};\n\nexport const isAboutSame = (a, b, px) => (Math.abs(a - b) <= px);\n\nexport default getParsedStatus;\n","/**\n * This function helps consider the every condition\n * related to enabling emoji reaction feature.\n */\n\nexport interface IsReactionEnabledProps {\n  isBroadcast?: boolean;\n  isSuper?: boolean;\n  globalLevel?: boolean;\n  moduleLevel?: boolean;\n}\n\nexport function getIsReactionEnabled({\n  isBroadcast = false,\n  isSuper = false,\n  globalLevel = true,\n  moduleLevel,\n}: IsReactionEnabledProps): boolean {\n  return !(isBroadcast || isSuper) && (moduleLevel ?? globalLevel);\n}\n","export default {\n  initialized: false,\n  loading: true,\n  allMessages: [],\n  currentGroupChannel: { members: [] },\n  // for scrollup\n  hasMorePrev: false,\n  oldestMessageTimeStamp: 0,\n  // for scroll down\n  // onScrollDownCallback is added for navigation to different timestamps on messageSearch\n  // hasMorePrev, onScrollCallback -> scroll up(default behavior)\n  // hasMoreNext, onScrollDownCallback -> scroll down\n  hasMoreNext: false,\n  latestMessageTimeStamp: 0,\n  emojiContainer: {},\n  unreadSince: null,\n  isInvalid: false,\n  messageListParams: null,\n};\n","import format from 'date-fns/format';\n\nimport * as actionTypes from './actionTypes';\nimport compareIds from '../../../../utils/compareIds';\nimport { PREV_RESULT_SIZE, NEXT_RESULT_SIZE } from '../const';\nimport { passUnsuccessfullMessages, mergeAndSortMessages } from '../utils';\nimport { filterMessageListParams, getSendingMessageStatus } from '../../../../utils';\n\nconst {\n  SUCCEEDED,\n} = getSendingMessageStatus();\nconst getOldestMessageTimeStamp = (messages = []) => {\n  const oldestMessage = messages[0];\n  return (oldestMessage && oldestMessage.createdAt) || null;\n};\nconst getLatestMessageTimeStamp = (messages = []) => {\n  const latestMessage = messages[messages.length - 1];\n  return (latestMessage && latestMessage.createdAt) || null;\n};\n\nexport default function reducer(state, action) {\n  switch (action.type) {\n    case actionTypes.RESET_MESSAGES:\n      return {\n        ...state,\n        // when user switches channel, if the previous channel `hasMorePrev`\n        // the onScroll gets called twice, setting hasMorePrev false prevents this\n        hasMorePrev: false,\n        hasMoreNext: false,\n        allMessages: [],\n      };\n    case actionTypes.FETCH_INITIAL_MESSAGES_START: {\n      return {\n        ...state,\n        loading: true,\n        allMessages: [\n          ...state.allMessages.filter((m) => (\n            m.sendingStatus !== SUCCEEDED\n          )),\n        ],\n      };\n    }\n    case actionTypes.FETCH_INITIAL_MESSAGES_SUCCESS: {\n      const {\n        currentGroupChannel,\n        messages,\n      } = action.payload;\n      if (!(currentGroupChannel?.url === state.currentGroupChannel?.url)) {\n        return state;\n      }\n      const oldestMessageTimeStamp = getOldestMessageTimeStamp(messages);\n      const latestMessageTimeStamp = getLatestMessageTimeStamp(messages);\n      return {\n        ...state,\n        loading: false,\n        initialized: true,\n        hasMorePrev: true,\n        hasMoreNext: true,\n        oldestMessageTimeStamp,\n        latestMessageTimeStamp,\n        allMessages: [...messages],\n      };\n    }\n    case actionTypes.FETCH_PREV_MESSAGES_SUCCESS: {\n      const {\n        currentGroupChannel,\n        messages,\n      } = action.payload;\n      if (!(currentGroupChannel?.url === state.currentGroupChannel?.url)) {\n        return state;\n      }\n      const hasMorePrev = messages && messages.length === PREV_RESULT_SIZE + 1;\n      const oldestMessageTimeStamp = getOldestMessageTimeStamp(messages);\n\n      // Remove duplicated messages\n      const duplicatedMessageIds = [];\n      const updatedOldMessages = state.allMessages.map((msg) => {\n        const duplicatedMessage = messages.find(({ messageId }) => (\n          compareIds(messageId, msg.messageId)\n        ));\n        if (!duplicatedMessage) {\n          return msg;\n        }\n        duplicatedMessageIds.push(duplicatedMessage.messageId);\n        return (duplicatedMessage.updatedAt > msg.updatedAt) ? duplicatedMessage : msg;\n      });\n      const filteredNewMessages = (duplicatedMessageIds.length > 0)\n        ? messages.filter((msg) => (\n          !duplicatedMessageIds.find((messageId) => compareIds(messageId, msg.messageId))\n        ))\n        : messages;\n\n      return {\n        ...state,\n        hasMorePrev,\n        oldestMessageTimeStamp,\n        allMessages: [\n          ...filteredNewMessages,\n          ...updatedOldMessages,\n        ],\n      };\n    }\n    case actionTypes.FETCH_NEXT_MESSAGES_SUCCESS: {\n      const {\n        currentGroupChannel,\n        messages,\n      } = action.payload;\n      if (!(currentGroupChannel?.url === state.currentGroupChannel?.url)) {\n        return state;\n      }\n      const hasMoreNext = messages && messages.length === NEXT_RESULT_SIZE + 1;\n      const latestMessageTimeStamp = getLatestMessageTimeStamp(messages);\n\n      // sort ~\n      const sortedMessages = mergeAndSortMessages(state.allMessages, messages);\n\n      return {\n        ...state,\n        hasMoreNext,\n        latestMessageTimeStamp,\n        allMessages: sortedMessages,\n      };\n    }\n    case actionTypes.FETCH_INITIAL_MESSAGES_FAILURE:\n    case actionTypes.FETCH_PREV_MESSAGES_FAILURE:\n    case actionTypes.FETCH_NEXT_MESSAGES_FAILURE: {\n      const { currentGroupChannel } = action.payload;\n      if (currentGroupChannel?.url !== state?.currentGroupChannel?.url) {\n        return state;\n      }\n      return {\n        ...state,\n        loading: false,\n        initialized: false,\n        allMessages: [],\n        hasMorePrev: false,\n        hasMoreNext: false,\n        oldestMessageTimeStamp: null,\n        latestMessageTimeStamp: null,\n      };\n    }\n    case actionTypes.SEND_MESSAGEGE_START:\n      return {\n        ...state,\n        allMessages: [\n          ...state.allMessages,\n          { ...action.payload },\n        ],\n      };\n    case actionTypes.SEND_MESSAGEGE_SUCESS: {\n      const message = action.payload;\n      const filteredMessages = state.allMessages.filter((m) => (\n        m?.reqId !== message?.reqId\n      ));\n      const pendingIndex = filteredMessages.findIndex((msg) => (\n        msg?.sendingStatus === 'pending' || msg?.sendingStatus === 'failed'\n      ));\n      return {\n        ...state,\n        allMessages: pendingIndex > -1\n          ? [\n            ...filteredMessages.slice(0, pendingIndex),\n            message,\n            ...filteredMessages.slice(pendingIndex),\n          ]\n          : [\n            ...filteredMessages,\n            message,\n          ],\n      };\n    }\n    case actionTypes.SEND_MESSAGEGE_FAILURE: {\n      // eslint-disable-next-line no-param-reassign\n      action.payload.failed = true;\n      return {\n        ...state,\n        allMessages: state.allMessages.map((m) => (\n          compareIds(m.reqId, action.payload.reqId)\n            ? action.payload\n            : m\n        )),\n      };\n    }\n    case actionTypes.SET_CURRENT_CHANNEL: {\n      return {\n        ...state,\n        currentGroupChannel: action.payload,\n        isInvalid: false,\n      };\n    }\n    case actionTypes.SET_CHANNEL_INVALID: {\n      return {\n        ...state,\n        currentGroupChannel: null,\n        isInvalid: true,\n      };\n    }\n    case actionTypes.ON_MESSAGE_RECEIVED: {\n      const { channel, message } = action.payload;\n      const { members } = channel;\n      const { sender } = message;\n      const { currentGroupChannel = {}, unreadSince } = state;\n      const currentGroupChannelUrl = currentGroupChannel?.url;\n\n      if (!compareIds(channel?.url, currentGroupChannelUrl)) {\n        return state;\n      }\n      // Excluded overlapping messages\n      if (state.allMessages.some((msg) => msg.messageId === message.messageId)) {\n        return state;\n      }\n      // Filter by userFilledQuery\n      if (state.messageListParams && !filterMessageListParams(state.messageListParams, message)) {\n        return state;\n      }\n\n      if (message.isAdminMessage && message.isAdminMessage()) {\n        return {\n          ...state,\n          allMessages: passUnsuccessfullMessages(state.allMessages, message),\n        };\n      }\n\n      // Update members when sender profileUrl, nickname, friendName has been changed\n      const senderMember = members?.find((m) => (m?.userId === sender?.userId));\n      if ((senderMember?.profileUrl !== sender?.profileUrl)\n        || (senderMember?.friendName !== sender?.friendName)\n        || (senderMember?.nickname !== sender?.nickname)) {\n        channel.members = members.map((member) => {\n          if (member.userId === sender.userId) {\n            return sender;\n          }\n          return member;\n        });\n      }\n      return {\n        ...state,\n        currentGroupChannel: channel,\n        unreadSince: state?.unreadSince ? unreadSince : format(new Date(), 'p MMM dd'),\n        allMessages: passUnsuccessfullMessages(state.allMessages, message),\n      };\n    }\n    case actionTypes.ON_MESSAGE_UPDATED: {\n      const { channel, message } = action.payload;\n      const currentGroupChannelUrl = state?.currentGroupChannel?.url || '';\n      if (!compareIds(channel?.url, currentGroupChannelUrl)) {\n        return state; // Ignore event when it is not for the current channel\n      }\n      if (state.messageListParams && !filterMessageListParams(state.messageListParams, message)) {\n        // Delete the message if it doesn't match to the params anymore\n        return {\n          ...state,\n          allMessages: state.allMessages.filter((m) => (\n            !compareIds(m.messageId, message?.messageId)\n          )),\n        };\n      }\n      return {\n        ...state,\n        allMessages: state.allMessages.map((m) => {\n          if (compareIds(m.messageId, message.messageId)) {\n            return message;\n          }\n          if (compareIds(m.parentMessageId, message.messageId)) {\n            m.parentMessage = message;// eslint-disable-line no-param-reassign\n          }\n          return m;\n        }),\n      };\n    }\n    case actionTypes.ON_MESSAGE_THREAD_INFO_UPDATED: {\n      const { channel, event } = action.payload;\n      const { channelUrl, threadInfo, targetMessageId } = event;\n      const currentGroupChannelUrl = state?.currentGroupChannel?.url || '';\n      if (\n        !compareIds(channel?.url, currentGroupChannelUrl)\n        || !compareIds(channel?.url, channelUrl)\n      ) {\n        return state; // Ignore event when it is not for the current channel\n      }\n      return {\n        ...state,\n        allMessages: state.allMessages.map((m) => {\n          if (compareIds(m.messageId, targetMessageId)) {\n            // eslint-disable-next-line no-param-reassign\n            m.threadInfo = threadInfo; // Upsert threadInfo to the target message\n          }\n          return m;\n        }),\n      };\n    }\n    case actionTypes.RESEND_MESSAGEGE_START:\n      return {\n        ...state,\n        allMessages: state.allMessages.map((m) => (\n          compareIds(m.reqId, action.payload.reqId)\n            ? action.payload\n            : m\n        )),\n      };\n    case actionTypes.MARK_AS_READ:\n      if (state.currentGroupChannel?.url !== action.payload?.channel?.url) {\n        return state;\n      }\n      return {\n        ...state,\n        unreadSince: null,\n      };\n    case actionTypes.ON_MESSAGE_DELETED:\n      return {\n        ...state,\n        allMessages: state.allMessages.filter((m) => (\n          !compareIds(m.messageId, action.payload)\n        )),\n      };\n    case actionTypes.ON_MESSAGE_DELETED_BY_REQ_ID:\n      return {\n        ...state,\n        allMessages: state.allMessages.filter((m) => (\n          !compareIds(m.reqId, action.payload)\n        )),\n      };\n    case actionTypes.SET_EMOJI_CONTAINER: {\n      return {\n        ...state,\n        emojiContainer: action.payload,\n      };\n    }\n    case actionTypes.ON_REACTION_UPDATED: {\n      return {\n        ...state,\n        allMessages: state.allMessages.map((m) => {\n          if (compareIds(m.messageId, action.payload.messageId)) {\n            if (m.applyReactionEvent && typeof m.applyReactionEvent === 'function') {\n              m.applyReactionEvent(action.payload);\n            }\n            return m;\n          }\n          return m;\n        }),\n      };\n    }\n    case actionTypes.MESSAGE_LIST_PARAMS_CHANGED: {\n      return {\n        ...state,\n        messageListParams: action.payload,\n      };\n    }\n    default:\n      return state;\n  }\n}\n","import { useEffect } from 'react';\nimport { GroupChannel, GroupChannelHandler, SendbirdGroupChat } from '@sendbird/chat/groupChannel';\nimport { FileMessage, UserMessage } from '@sendbird/chat/message';\n\nimport { scrollIntoLast } from '../utils';\n\nimport { CustomUseReducerDispatcher, Logger } from '../../../../lib/SendbirdState';\nimport uuidv4 from '../../../../utils/uuid';\nimport compareIds from '../../../../utils/compareIds';\nimport * as messageActions from '../dux/actionTypes';\nimport useSendbirdStateContext from '../../../../hooks/useSendbirdStateContext';\n\n/**\n * Handles ChannelEvents and send values to dispatcher using messagesDispatcher\n * messagesDispatcher: Dispatcher\n * sdk: sdkInstance\n * logger: loggerInstance\n * channelUrl: string\n * sdkInit: bool\n */\ninterface DynamicParams {\n  sdkInit: boolean;\n  currentUserId: string;\n  currentGroupChannel: GroupChannel;\n  disableMarkAsRead: boolean;\n}\ninterface StaticParams {\n  sdk: SendbirdGroupChat;\n  logger: Logger;\n  scrollRef: React.RefObject<HTMLDivElement>;\n  setQuoteMessage: React.Dispatch<React.SetStateAction<UserMessage | FileMessage>>;\n  messagesDispatcher: CustomUseReducerDispatcher;\n}\n\nconst DELIVERY_RECIPT = 'delivery_receipt';\n\nfunction useHandleChannelEvents({\n  sdkInit,\n  currentUserId,\n  currentGroupChannel,\n  disableMarkAsRead,\n}: DynamicParams, {\n  sdk,\n  logger,\n  scrollRef,\n  setQuoteMessage,\n  messagesDispatcher,\n}: StaticParams): void {\n  const store = useSendbirdStateContext();\n  const {\n    markAsReadScheduler,\n    markAsDeliveredScheduler,\n    disableMarkAsDelivered,\n  } = store.config;\n  const canSetMarkAsDelivered = store.stores.sdkStore.sdk?.appInfo?.premiumFeatureList\n    ?.find((feature) => (feature === DELIVERY_RECIPT));\n\n  useEffect(() => {\n    const channelUrl = currentGroupChannel?.url;\n    const channelHandlerId = uuidv4();\n    if (channelUrl && sdkInit) {\n      const channelHandler: GroupChannelHandler = {\n        onMessageReceived: (channel, message) => {\n          if (compareIds(channel?.url, channelUrl)) {\n            let scrollToEnd = false;\n            try {\n              const { current } = scrollRef;\n              scrollToEnd = current.offsetHeight + current.scrollTop >= current.scrollHeight - 10;\n              // 10 is a buffer\n            } catch (error) {\n              //\n            }\n\n            logger.info('Channel | useHandleChannelEvents: onMessageReceived', message);\n            messagesDispatcher({\n              type: messageActions.ON_MESSAGE_RECEIVED,\n              payload: { channel, message },\n            });\n            if (scrollToEnd\n              && document.getElementById('sendbird-dropdown-portal')?.childElementCount === 0\n              && document.getElementById('sendbird-emoji-list-portal')?.childElementCount === 0\n            ) {\n              // and !openContextMenu\n              try {\n                setTimeout(() => {\n                  scrollIntoLast(0, scrollRef);\n                });\n                if (!disableMarkAsRead) {\n                  markAsReadScheduler.push(currentGroupChannel);\n                }\n                if (canSetMarkAsDelivered && !disableMarkAsDelivered) {\n                  markAsDeliveredScheduler.push(currentGroupChannel);\n                }\n              } catch (error) {\n                logger.warning('Channel | onMessageReceived | scroll to end failed');\n              }\n            }\n          }\n        },\n        onUnreadMemberStatusUpdated: (channel) => {\n          logger.info('Channel | useHandleChannelEvents: onUnreadMemberStatusUpdated', channel);\n          if (compareIds(channel?.url, channelUrl)) {\n            messagesDispatcher({\n              type: messageActions.SET_CURRENT_CHANNEL,\n              payload: channel,\n            });\n          }\n        },\n        // before(onDeliveryReceiptUpdated)\n        onUndeliveredMemberStatusUpdated: (channel) => {\n          if (compareIds(channel?.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onDeliveryReceiptUpdated', channel);\n            messagesDispatcher({\n              type: messageActions.SET_CURRENT_CHANNEL,\n              payload: channel,\n            });\n          }\n        },\n        onMessageUpdated: (channel, message) => {\n          logger.info('Channel | useHandleChannelEvents: onMessageUpdated', message);\n          messagesDispatcher({\n            type: messageActions.ON_MESSAGE_UPDATED,\n            payload: { channel, message },\n          });\n        },\n        onThreadInfoUpdated: (channel, threadInfoUpdateEvent) => {\n          logger.info('Channel | useHandleChannelEvents: onThreadInfoUpdated', { channel, threadInfoUpdateEvent });\n          messagesDispatcher({\n            type: messageActions.ON_MESSAGE_THREAD_INFO_UPDATED,\n            payload: { channel, event: threadInfoUpdateEvent },\n          });\n        },\n        onMessageDeleted: (channel, messageId) => {\n          logger.info('Channel | useHandleChannelEvents: onMessageDeleted', { channel, messageId });\n          setQuoteMessage(null);\n          messagesDispatcher({\n            type: messageActions.ON_MESSAGE_DELETED,\n            payload: messageId,\n          });\n        },\n        onReactionUpdated: (channel, reactionEvent) => {\n          logger.info('Channel | useHandleChannelEvents: onReactionUpdated', { channel, reactionEvent });\n          messagesDispatcher({\n            type: messageActions.ON_REACTION_UPDATED,\n            payload: reactionEvent,\n          });\n        },\n        onChannelChanged: (channel) => {\n          if (compareIds(channel?.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onChannelChanged', channel);\n            messagesDispatcher({\n              type: messageActions.SET_CURRENT_CHANNEL,\n              payload: channel,\n            });\n          }\n        },\n        onChannelFrozen: (channel) => {\n          if (compareIds(channel?.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onChannelFrozen', channel);\n            messagesDispatcher({\n              type: messageActions.SET_CURRENT_CHANNEL,\n              payload: channel,\n            });\n          }\n        },\n        onChannelUnfrozen: (channel) => {\n          if (compareIds(channel?.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onChannelUnFrozen', channel);\n            messagesDispatcher({\n              type: messageActions.SET_CURRENT_CHANNEL,\n              payload: channel,\n            });\n          }\n        },\n        onUserMuted: (channel, user) => {\n          if (compareIds(channel?.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onUserMuted', { channel, user });\n            messagesDispatcher({\n              type: messageActions.SET_CURRENT_CHANNEL,\n              payload: channel,\n            });\n          }\n        },\n        onUserUnmuted: (channel, user) => {\n          if (compareIds(channel?.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onUserUnmuted', { channel, user });\n            messagesDispatcher({\n              type: messageActions.SET_CURRENT_CHANNEL,\n              payload: channel,\n            });\n          }\n        },\n        onUserBanned: (channel, user) => {\n          if (compareIds(channel?.url, channelUrl) && user?.userId === sdk?.currentUser?.userId) {\n            logger.info('Channel | useHandleChannelEvents: onUserBanned', { channel, user });\n            messagesDispatcher({\n              type: messageActions.SET_CURRENT_CHANNEL,\n              payload: null,\n            });\n          }\n        },\n        onOperatorUpdated: (channel, users) => {\n          if (compareIds(channel?.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onOperatorUpdated', { channel, users });\n            messagesDispatcher({\n              type: messageActions.SET_CURRENT_CHANNEL,\n              payload: channel,\n            });\n          }\n        },\n        onUserLeft: (channel, user) => {\n          if (compareIds(channel?.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onUserLeft', { channel, user });\n            if (user?.userId === currentUserId) {\n              messagesDispatcher({\n                type: messageActions.SET_CURRENT_CHANNEL,\n                payload: null,\n              });\n            }\n          }\n        },\n      };\n      logger.info('Channel | useHandleChannelEvents: Setup event handler', { channelHandlerId, channelHandler });\n      // Add this group channel handler to the Sendbird chat instance\n      sdk.groupChannel?.addGroupChannelHandler(channelHandlerId, new GroupChannelHandler(channelHandler));\n    }\n    return () => {\n      if (sdk?.groupChannel?.removeGroupChannelHandler) {\n        logger.info('Channel | useHandleChannelEvents: Removing message reciver handler', channelHandlerId);\n        sdk.groupChannel.removeGroupChannelHandler(channelHandlerId);\n      } else if (sdk?.groupChannel) {\n        logger.error('Channel | useHandleChannelEvents: Not found the removeGroupChannelHandler');\n      }\n    };\n  }, [currentGroupChannel?.url, sdkInit]);\n}\n\nexport default useHandleChannelEvents;\n","import { useEffect } from 'react';\n\nimport * as messageActionTypes from '../dux/actionTypes';\n\nfunction useSetChannel({ channelUrl, sdkInit, disableMarkAsRead }, {\n  messagesDispatcher,\n  sdk,\n  logger,\n  markAsReadScheduler,\n}) {\n  useEffect(() => {\n    if (channelUrl && sdkInit && sdk && sdk.groupChannel) {\n      logger.info('Channel | useSetChannel fetching channel', channelUrl);\n      sdk.groupChannel.getChannel(channelUrl)\n        .then((groupChannel) => {\n          logger.info('Channel | useSetChannel fetched channel', groupChannel);\n          messagesDispatcher({\n            type: messageActionTypes.SET_CURRENT_CHANNEL,\n            payload: groupChannel,\n          });\n\n          logger.info('Channel: Mark as read', groupChannel);\n          if (!disableMarkAsRead) {\n            markAsReadScheduler.push(groupChannel);\n          }\n        })\n        .catch((e) => {\n          logger.warning('Channel | useSetChannel fetch channel failed', { channelUrl, e });\n          messagesDispatcher({\n            type: messageActionTypes.SET_CHANNEL_INVALID,\n          });\n        });\n      sdk.getAllEmoji().then((emojiContainer_) => {\n        logger.info('Channel: Getting emojis success', emojiContainer_);\n        messagesDispatcher({\n          type: messageActionTypes.SET_EMOJI_CONTAINER,\n          payload: emojiContainer_,\n        });\n      }).catch((err) => {\n        logger.error('Channel: Getting emojis failed', err);\n      });\n      sdk.getAllEmoji();\n    }\n  }, [channelUrl, sdkInit]);\n}\n\nexport default useSetChannel;\n","import { useEffect } from 'react';\nimport { ReplyType } from '@sendbird/chat/message';\n\nimport * as utils from '../utils';\nimport * as messageActionTypes from '../dux/actionTypes';\nimport { PREV_RESULT_SIZE, NEXT_RESULT_SIZE } from '../const';\n\nfunction useInitialMessagesFetch({\n  currentGroupChannel,\n  userFilledMessageListQuery,\n  initialTimeStamp,\n  replyType,\n}, {\n  logger,\n  scrollRef,\n  messagesDispatcher,\n}) {\n  const channelUrl = currentGroupChannel?.url;\n  useEffect(() => {\n    logger.info('Channel useInitialMessagesFetch: Setup started', currentGroupChannel);\n    messagesDispatcher({\n      type: messageActionTypes.RESET_MESSAGES,\n      payload: null,\n    });\n\n    if (currentGroupChannel && currentGroupChannel?.getMessagesByTimestamp) {\n      const messageListParams = {};\n      messageListParams.prevResultSize = PREV_RESULT_SIZE;\n      if (initialTimeStamp) {\n        messageListParams.nextResultSize = NEXT_RESULT_SIZE;\n      }\n      messageListParams.isInclusive = true;\n      messageListParams.includeReactions = true;\n      messageListParams.includeMetaArray = true;\n      if (replyType && (replyType === 'QUOTE_REPLY' || replyType === 'THREAD')) {\n        messageListParams.includeThreadInfo = true;\n        messageListParams.includeParentMessageInfo = true;\n        messageListParams.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n      }\n      if (userFilledMessageListQuery) {\n        Object.keys(userFilledMessageListQuery).forEach((key) => {\n          messageListParams[key] = userFilledMessageListQuery[key];\n        });\n      }\n      if ((replyType && (replyType === 'QUOTE_REPLY' || replyType === 'THREAD')) || userFilledMessageListQuery) {\n        logger.info('Channel useInitialMessagesFetch: Setup messageListParams', messageListParams);\n        messagesDispatcher({\n          type: messageActionTypes.MESSAGE_LIST_PARAMS_CHANGED,\n          payload: messageListParams,\n        });\n      }\n\n      logger.info('Channel: Fetching messages', { currentGroupChannel, userFilledMessageListQuery });\n      messagesDispatcher({\n        type: messageActionTypes.FETCH_INITIAL_MESSAGES_START,\n        payload: null,\n      });\n\n      currentGroupChannel.getMessagesByTimestamp(\n        initialTimeStamp || new Date().getTime(),\n        messageListParams,\n      )\n        .then((messages) => {\n          messagesDispatcher({\n            type: messageActionTypes.FETCH_INITIAL_MESSAGES_SUCCESS,\n            payload: {\n              currentGroupChannel,\n              messages,\n            },\n          });\n        })\n        .catch((error) => {\n          logger.error('Channel: Fetching messages failed', error);\n          messagesDispatcher({\n            type: messageActionTypes.FETCH_INITIAL_MESSAGES_FAILURE,\n            payload: { currentGroupChannel },\n          });\n        })\n        .finally(() => {\n          if (!initialTimeStamp) {\n            setTimeout(() => utils.scrollIntoLast(0, scrollRef));\n          } else {\n            setTimeout(() => {\n              utils.scrollToRenderedMessage(scrollRef, initialTimeStamp);\n            }, 500);\n          }\n        });\n    }\n  }, [channelUrl, userFilledMessageListQuery, initialTimeStamp]);\n  /**\n   * Note - useEffect(() => {}, [currentGroupChannel])\n   * was buggy, that is why we did\n   * const channelUrl = currentGroupChannel && currentGroupChannel.url;\n   * useEffect(() => {}, [channelUrl])\n   * Again, this hook is supposed to execute when currentGroupChannel changes\n   * The 'channelUrl' here is not the same memory reference from Conversation.props\n   */\n}\n\nexport default useInitialMessagesFetch;\n","import { useEffect } from 'react';\n\nimport type { GroupChannel, SendbirdGroupChat } from '@sendbird/chat/groupChannel';\nimport { MessageListParams, ReplyType } from '@sendbird/chat/message';\nimport * as utils from '../utils';\nimport { PREV_RESULT_SIZE, NEXT_RESULT_SIZE } from '../const';\nimport * as messageActionTypes from '../dux/actionTypes';\nimport { Logger } from '../../../../lib/SendbirdState';\nimport { MarkAsReadSchedulerType } from '../../../../lib/hooks/useMarkAsReadScheduler';\n\ninterface DynamicParams {\n  isOnline: boolean;\n  replyType?: string;\n  disableMarkAsRead: boolean;\n}\n\ninterface StaticParams {\n  logger: Logger;\n  sdk: SendbirdGroupChat;\n  currentGroupChannel: GroupChannel;\n  scrollRef: React.RefObject<HTMLDivElement>;\n  markAsReadScheduler: MarkAsReadSchedulerType;\n  messagesDispatcher: (props: { type: string, payload: any }) => void;\n  userFilledMessageListQuery?: Record<string, any>;\n}\n\nfunction useHandleReconnect(\n  { isOnline, replyType, disableMarkAsRead }: DynamicParams,\n  {\n    logger,\n    sdk,\n    scrollRef,\n    currentGroupChannel,\n    messagesDispatcher,\n    markAsReadScheduler,\n    userFilledMessageListQuery,\n  }: StaticParams,\n): void {\n  useEffect(() => {\n    const wasOffline = !isOnline;\n    return () => {\n      // state changed from offline to online\n      if (wasOffline && currentGroupChannel?.url) {\n        logger.info('Refreshing conversation state');\n        const isReactionEnabled = sdk?.appInfo?.useReaction || false;\n\n        const messageListParams: MessageListParams = {\n          prevResultSize: PREV_RESULT_SIZE,\n          isInclusive: true,\n          includeReactions: isReactionEnabled,\n          nextResultSize: NEXT_RESULT_SIZE,\n        };\n        if (replyType && replyType === 'QUOTE_REPLY') {\n          messageListParams.includeThreadInfo = true;\n          messageListParams.includeParentMessageInfo = true;\n          messageListParams.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n        }\n        if (userFilledMessageListQuery) {\n          Object.keys(userFilledMessageListQuery).forEach((key) => {\n            messageListParams[key] = userFilledMessageListQuery[key];\n          });\n        }\n        logger.info('Channel: Fetching messages', { currentGroupChannel, userFilledMessageListQuery });\n        messagesDispatcher({\n          type: messageActionTypes.FETCH_INITIAL_MESSAGES_START,\n          payload: null,\n        });\n\n        sdk?.groupChannel?.getChannel(currentGroupChannel?.url)\n          .then((groupChannel) => {\n            const lastMessageTime = new Date().getTime();\n\n            groupChannel.getMessagesByTimestamp(\n              lastMessageTime,\n              messageListParams,\n            )\n              .then((messages) => {\n                messagesDispatcher({\n                  type: messageActionTypes.FETCH_INITIAL_MESSAGES_SUCCESS,\n                  payload: {\n                    currentGroupChannel,\n                    messages,\n                  },\n                });\n                setTimeout(() => utils.scrollIntoLast(0, scrollRef));\n              })\n              .catch((error) => {\n                logger.error('Channel: Fetching messages failed', error);\n                messagesDispatcher({\n                  type: messageActionTypes.FETCH_INITIAL_MESSAGES_FAILURE,\n                  payload: { currentGroupChannel },\n                });\n              });\n            if (!disableMarkAsRead) {\n              markAsReadScheduler.push(currentGroupChannel);\n            }\n          });\n      }\n    };\n  }, [isOnline, replyType]);\n}\n\nexport default useHandleReconnect;\n","import { useCallback } from 'react';\nimport { ReplyType } from '@sendbird/chat/message';\n\nimport * as messageActionTypes from '../dux/actionTypes';\nimport { PREV_RESULT_SIZE } from '../const';\n\nfunction useScrollCallback({\n  currentGroupChannel,\n  oldestMessageTimeStamp,\n  userFilledMessageListQuery,\n  replyType,\n}, {\n  hasMorePrev,\n  logger,\n  messagesDispatcher,\n  sdk,\n}) {\n  return useCallback((cb) => {\n    if (!hasMorePrev) { return; }\n    const { appInfo = {} } = sdk;\n    const isReactionEnabled = appInfo.useReaction || false;\n\n    const messageListParams = {\n      prevResultSize: PREV_RESULT_SIZE,\n      isInclusive: true,\n      includeReactions: isReactionEnabled,\n    };\n    messageListParams.includeMetaArray = true;\n    if (replyType === 'QUOTE_REPLY' || replyType === 'THREAD') {\n      messageListParams.includeThreadInfo = true;\n      messageListParams.includeParentMessageInfo = true;\n      messageListParams.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n    }\n    if (userFilledMessageListQuery) {\n      Object.keys(userFilledMessageListQuery).forEach((key) => {\n        messageListParams[key] = userFilledMessageListQuery[key];\n      });\n    }\n    logger.info('Channel: Fetching messages', { currentGroupChannel, userFilledMessageListQuery });\n\n    currentGroupChannel.getMessagesByTimestamp(\n      oldestMessageTimeStamp || new Date().getTime(),\n      messageListParams,\n    )\n      .then((messages) => {\n        messagesDispatcher({\n          type: messageActionTypes.FETCH_PREV_MESSAGES_SUCCESS,\n          payload: { currentGroupChannel, messages },\n        });\n        cb([messages, null]);\n      })\n      .catch((error) => {\n        logger.error('Channel: Fetching messages failed', error);\n        messagesDispatcher({\n          type: messageActionTypes.FETCH_PREV_MESSAGES_FAILURE,\n          payload: { currentGroupChannel },\n        });\n        cb([null, error]);\n      });\n  }, [currentGroupChannel, oldestMessageTimeStamp, replyType]);\n}\n\nexport default useScrollCallback;\n","import { useCallback } from 'react';\nimport { ReplyType } from '@sendbird/chat/message';\n\nimport * as messageActionTypes from '../dux/actionTypes';\nimport { NEXT_RESULT_SIZE } from '../const';\n\nfunction useScrollDownCallback({\n  currentGroupChannel,\n  latestMessageTimeStamp,\n  userFilledMessageListQuery,\n  hasMoreNext,\n  replyType,\n}, {\n  logger,\n  messagesDispatcher,\n  sdk,\n}) {\n  return useCallback((cb) => {\n    if (!hasMoreNext) { return; }\n    const { appInfo = {} } = sdk;\n    const isReactionEnabled = appInfo.useReaction || false;\n    const messageListParams = {\n      nextResultSize: NEXT_RESULT_SIZE,\n      isInclusive: true,\n      includeReactions: isReactionEnabled,\n    };\n    messageListParams.includeMetaArray = true;\n    if (replyType && (replyType === 'QUOTE_REPLY' || replyType === 'THREAD')) {\n      messageListParams.includeThreadInfo = true;\n      messageListParams.includeParentMessageInfo = true;\n      messageListParams.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n    }\n    if (userFilledMessageListQuery) {\n      Object.keys(userFilledMessageListQuery).forEach((key) => {\n        messageListParams[key] = userFilledMessageListQuery[key];\n      });\n    }\n    logger.info('Channel: Fetching later messages', { currentGroupChannel, userFilledMessageListQuery });\n\n    currentGroupChannel.getMessagesByTimestamp(\n      latestMessageTimeStamp || new Date().getTime(),\n      messageListParams,\n    )\n      .then((messages) => {\n        messagesDispatcher({\n          type: messageActionTypes.FETCH_NEXT_MESSAGES_SUCCESS,\n          payload: { currentGroupChannel, messages },\n        });\n        cb([messages, null]);\n      })\n      .catch((error) => {\n        logger.error('Channel: Fetching later messages failed', error);\n        messagesDispatcher({\n          type: messageActionTypes.FETCH_NEXT_MESSAGES_FAILURE,\n          payload: { currentGroupChannel },\n        });\n        cb([null, error]);\n      });\n  }, [currentGroupChannel, latestMessageTimeStamp, hasMoreNext, replyType]);\n}\n\nexport default useScrollDownCallback;\n","import { useCallback } from 'react';\n\nimport * as messageActionTypes from '../dux/actionTypes';\n\nfunction useDeleteMessageCallback({ currentGroupChannel, messagesDispatcher }, { logger }) {\n  return useCallback((message) => {\n    logger.info('Channel | useDeleteMessageCallback: Deleting message', message);\n    const { requestState } = message;\n    return new Promise((resolve, reject) => {\n      logger.info('Channel | useDeleteMessageCallback: Deleting message requestState:', requestState);\n      // Message is only on local\n      if (requestState === 'failed' || requestState === 'pending') {\n        logger.info('Channel | useDeleteMessageCallback: Deleted message from local:', message);\n        messagesDispatcher({\n          type: messageActionTypes.ON_MESSAGE_DELETED_BY_REQ_ID,\n          payload: message.reqId,\n        });\n        resolve(message);\n      }\n\n      logger.info('Channel | useDeleteMessageCallback: Deleting message from remote:', requestState);\n      currentGroupChannel.deleteMessage(message)\n        .then(() => {\n          logger.info('Channel | useDeleteMessageCallback: Deleting message success!', message);\n          messagesDispatcher({\n            type: messageActionTypes.ON_MESSAGE_DELETED,\n            payload: message.messageId,\n          });\n          resolve(message);\n        })\n        .catch((err) => {\n          logger.warning('Channel | useDeleteMessageCallback: Deleting message failed!', err);\n          reject(err);\n        });\n    });\n  }, [currentGroupChannel, messagesDispatcher]);\n}\n\nexport default useDeleteMessageCallback;\n","import { useCallback } from 'react';\n\nimport * as messageActionTypes from '../dux/actionTypes';\nimport topics from '../../../../lib/pubSub/topics';\n\nfunction useUpdateMessageCallback({\n  currentGroupChannel,\n  messagesDispatcher,\n  onBeforeUpdateUserMessage,\n  isMentionEnabled,\n}, {\n  logger,\n  pubSub,\n}) {\n  return useCallback((props, callback) => {\n    const {\n      messageId,\n      message,\n      mentionedUsers,\n      mentionTemplate,\n    } = props;\n    const createParamsDefault = () => {\n      const params = {};\n      params.message = message;\n      if (isMentionEnabled && mentionedUsers?.length > 0) {\n        params.mentionedUsers = mentionedUsers;\n      }\n      if (isMentionEnabled && mentionTemplate) {\n        params.mentionedMessageTemplate = mentionTemplate;\n      } else {\n        params.mentionedMessageTemplate = message;\n      }\n      return params;\n    };\n\n    const createCustomPrams = onBeforeUpdateUserMessage\n      && typeof onBeforeUpdateUserMessage === 'function';\n\n    if (createCustomPrams) {\n      logger.info('Channel: creating params using onBeforeUpdateUserMessage', onBeforeUpdateUserMessage);\n    }\n\n    const params = onBeforeUpdateUserMessage\n      ? onBeforeUpdateUserMessage(message)\n      : createParamsDefault(message);\n\n    logger.info('Channel: Updating message!', params);\n    currentGroupChannel.updateUserMessage(messageId, params).then((msg, err) => {\n      if (callback) {\n        callback(err, msg);\n      }\n\n      logger.info('Channel: Updating message success!', msg);\n      messagesDispatcher({\n        type: messageActionTypes.ON_MESSAGE_UPDATED,\n        payload: {\n          channel: currentGroupChannel,\n          message: msg,\n        },\n      });\n      pubSub.publish(\n        topics.UPDATE_USER_MESSAGE,\n        {\n          message: msg,\n          channel: currentGroupChannel,\n        },\n      );\n    });\n  }, [currentGroupChannel?.url, messagesDispatcher, onBeforeUpdateUserMessage]);\n}\n\nexport default useUpdateMessageCallback;\n","import { useCallback } from 'react';\n\nimport * as messageActionTypes from '../dux/actionTypes';\n\nfunction useResendMessageCallback({\n  currentGroupChannel,\n  messagesDispatcher,\n}, {\n  logger,\n}) {\n  return useCallback((failedMessage) => {\n    logger.info('Channel: Resending message has started', failedMessage);\n    const { messageType, file } = failedMessage;\n    if (failedMessage?.isResendable) {\n      // Move the logic setting sendingStatus to pending into the reducer\n      // eslint-disable-next-line no-param-reassign\n      failedMessage.requestState = 'pending';\n      // eslint-disable-next-line no-param-reassign\n      failedMessage.sendingStatus = 'pending';\n      messagesDispatcher({\n        type: messageActionTypes.RESEND_MESSAGEGE_START,\n        payload: failedMessage,\n      });\n\n      // userMessage\n      if (messageType === 'user') {\n        currentGroupChannel.resendUserMessage(failedMessage)\n          .then((message) => {\n            logger.info('Channel: Resending message success!', message);\n            messagesDispatcher({\n              type: messageActionTypes.SEND_MESSAGEGE_SUCESS,\n              payload: message,\n            });\n          })\n          .catch((e) => {\n            logger.warning('Channel: Resending message failed!', e);\n            // eslint-disable-next-line no-param-reassign\n            failedMessage.requestState = 'failed';\n            // eslint-disable-next-line no-param-reassign\n            failedMessage.sendingStatus = 'failed';\n            messagesDispatcher({\n              type: messageActionTypes.SEND_MESSAGEGE_FAILURE,\n              payload: failedMessage,\n            });\n          });\n\n        // eslint-disable-next-line no-param-reassign\n        failedMessage.requestState = 'pending';\n        // eslint-disable-next-line no-param-reassign\n        failedMessage.sendingStatus = 'pending';\n        messagesDispatcher({\n          type: messageActionTypes.RESEND_MESSAGEGE_START,\n          payload: failedMessage,\n        });\n        return;\n      }\n\n      if (messageType === 'file') {\n        currentGroupChannel\n          .resendFileMessage(failedMessage, file)\n          .then((message) => {\n            logger.info('Channel: Resending file message success!', message);\n            messagesDispatcher({\n              type: messageActionTypes.SEND_MESSAGEGE_SUCESS,\n              payload: message,\n            });\n          })\n          .catch((e) => {\n            logger.warning('Channel: Resending file message failed!', e);\n            // eslint-disable-next-line no-param-reassign\n            failedMessage.requestState = 'failed';\n            // eslint-disable-next-line no-param-reassign\n            failedMessage.sendingStatus = 'failed';\n            messagesDispatcher({\n              type: messageActionTypes.SEND_MESSAGEGE_FAILURE,\n              payload: failedMessage,\n            });\n          });\n\n        // eslint-disable-next-line no-param-reassign\n        failedMessage.requestState = 'pending';\n        // eslint-disable-next-line no-param-reassign\n        failedMessage.sendingStatus = 'pending';\n        messagesDispatcher({\n          type: messageActionTypes.RESEND_MESSAGEGE_START,\n          payload: failedMessage,\n        });\n      }\n    } else {\n      // to alert user on console\n      // eslint-disable-next-line no-console\n      console.error('Message is not resendable');\n      logger.warning('Message is not resendable', failedMessage);\n    }\n  }, [currentGroupChannel, messagesDispatcher]);\n}\n\nexport default useResendMessageCallback;\n","import { useRef, useCallback } from 'react';\n\nimport * as messageActionTypes from '../dux/actionTypes';\nimport * as utils from '../utils';\nimport topics from '../../../../lib/pubSub/topics';\n\nexport default function useSendMessageCallback({\n  isMentionEnabled,\n  currentGroupChannel,\n  onBeforeSendUserMessage,\n}, {\n  logger,\n  pubSub,\n  scrollRef,\n  messagesDispatcher,\n}) {\n  const messageInputRef = useRef(null);\n\n  const sendMessage = useCallback(\n    (props) => {\n      const {\n        quoteMessage = null,\n        message,\n        mentionTemplate,\n        // mentionedUserIds,\n        mentionedUsers,\n      } = props;\n      const createParamsDefault = () => {\n        const params = {};\n        params.message = message;\n        // if (isMentionEnabled && mentionedUserIds?.length > 0) {\n        if (isMentionEnabled && mentionedUsers?.length > 0) {\n          // params.mentionedUserIds = mentionedUserIds;\n          params.mentionedUsers = mentionedUsers;\n        }\n        // if (isMentionEnabled && mentionTemplate && mentionedUserIds?.length > 0) {\n        if (isMentionEnabled && mentionTemplate && mentionedUsers?.length > 0) {\n          params.mentionedMessageTemplate = mentionTemplate;\n        }\n        if (quoteMessage) {\n          params.isReplyToChannel = true;\n          params.parentMessageId = quoteMessage.messageId;\n        }\n        return params;\n      };\n\n      const createCustomPrams = onBeforeSendUserMessage\n        && typeof onBeforeSendUserMessage === 'function';\n\n      if (createCustomPrams) {\n        logger.info('Channel: creating params using onBeforeSendUserMessage', onBeforeSendUserMessage);\n      }\n\n      const params = onBeforeSendUserMessage\n        ? onBeforeSendUserMessage(message, quoteMessage)\n        : createParamsDefault();\n\n      logger.info('Channel: Sending message has started', params);\n      currentGroupChannel.sendUserMessage(params)\n        .onPending((pendingMsg) => {\n          pubSub.publish(topics.SEND_MESSAGE_START, {\n            /* pubSub is used instead of messagesDispatcher\n              to avoid redundantly calling `messageActionTypes.SEND_MESSAGEGE_START` */\n            message: pendingMsg,\n            channel: currentGroupChannel,\n          });\n          setTimeout(() => utils.scrollIntoLast(0, scrollRef));\n        })\n        .onFailed((err, msg) => {\n          logger.warning('Channel: Sending message failed!', { message: msg, error: err });\n          messagesDispatcher({\n            type: messageActionTypes.SEND_MESSAGEGE_FAILURE,\n            payload: msg,\n          });\n        })\n        .onSucceeded((msg) => {\n          logger.info('Channel: Sending message success!', msg);\n          messagesDispatcher({\n            type: messageActionTypes.SEND_MESSAGEGE_SUCESS,\n            payload: msg,\n          });\n        });\n    },\n    [currentGroupChannel, onBeforeSendUserMessage],\n  );\n\n  return [messageInputRef, sendMessage];\n}\n","import { useCallback } from 'react';\n\nimport * as messageActionTypes from '../dux/actionTypes';\nimport * as utils from '../utils';\nimport topics from '../../../../lib/pubSub/topics';\n\nexport default function useSendFileMessageCallback({\n  currentGroupChannel,\n  onBeforeSendFileMessage,\n  imageCompression = {},\n}, {\n  logger,\n  pubSub,\n  scrollRef,\n  messagesDispatcher,\n}) {\n  const sendMessage = useCallback((file, quoteMessage = null) => {\n    const {\n      compressionRate,\n      resizingWidth,\n      resizingHeight,\n    } = imageCompression;\n    const createCustomParams = onBeforeSendFileMessage && typeof onBeforeSendFileMessage === 'function';\n\n    const compressibleFileType = (file.type === 'image/jpg' || file.type === 'image/png' || file.type === 'image/jpeg');\n    const compressibleRatio = (compressionRate > 0) && (compressionRate < 1);\n    // pxToNumber returns null if values are invalid\n    const compressibleDiamensions = utils.pxToNumber(resizingWidth)\n      || utils.pxToNumber(resizingHeight);\n\n    const canCompressImage = compressibleFileType && (compressibleRatio || compressibleDiamensions);\n\n    const createParamsDefault = (file_) => {\n      const params = {};\n      params.file = file_;\n      if (quoteMessage) {\n        params.isReplyToChannel = true;\n        params.parentMessageId = quoteMessage.messageId;\n      }\n      return params;\n    };\n\n    if (canCompressImage) { // Using image compression\n      try {\n        const image = document.createElement('img');\n        image.src = URL.createObjectURL(file);\n        image.onload = () => {\n          URL.revokeObjectURL(image.src);\n          const canvas = document.createElement('canvas');\n          const imageWdith = image.naturalWidth || image.width;\n          const imageHeight = image.naturalHeight || image.height;\n\n          let targetWidth = utils.pxToNumber(resizingWidth) || imageWdith;\n          let targetHeight = utils.pxToNumber(resizingHeight) || imageHeight;\n\n          // In canvas.toBlob(callback, mimeType, qualityArgument)\n          // qualityArgument doesnt work\n          // so in case compressibleDiamensions are not present, we use ratio\n          if (file.type === 'image/png' && !compressibleDiamensions) {\n            targetWidth *= compressionRate;\n            targetHeight *= compressionRate;\n          }\n\n          canvas.width = targetWidth;\n          canvas.height = targetHeight;\n          const context = canvas.getContext('2d');\n          context.drawImage(image, 0, 0, targetWidth, targetHeight);\n          context.canvas.toBlob(\n            (newImageBlob) => {\n              const compressedFile = new File([newImageBlob], file.name, { type: file.type });\n              if (createCustomParams) {\n                logger.info('Channel: Creating params using onBeforeSendFileMessage', onBeforeSendFileMessage);\n              }\n              const params = createCustomParams\n                ? onBeforeSendFileMessage(compressedFile, quoteMessage)\n                : createParamsDefault(compressedFile);\n              logger.info('Channel: Uploading file message start!', params);\n              currentGroupChannel.sendFileMessage(params)\n                .onPending((pendingMessage) => {\n                  pubSub.publish(topics.SEND_MESSAGE_START, {\n                    /* pubSub is used instead of messagesDispatcher\n                      to avoid redundantly calling `messageActionTypes.SEND_MESSAGEGE_START` */\n                    message: {\n                      ...pendingMessage,\n                      url: URL.createObjectURL(compressedFile),\n                      // pending thumbnail message seems to be failed\n                      requestState: 'pending',\n                    },\n                    channel: currentGroupChannel,\n                  });\n                  setTimeout(() => utils.scrollIntoLast(0, scrollRef), 1000);\n                })\n                .onFailed((err, failedMessage) => {\n                  logger.error('Channel: Sending file message failed!', { failedMessage, err });\n                  // eslint-disable-next-line no-param-reassign\n                  failedMessage.localUrl = URL.createObjectURL(compressedFile);\n                  // eslint-disable-next-line no-param-reassign\n                  failedMessage.file = compressedFile;\n                  messagesDispatcher({\n                    type: messageActionTypes.SEND_MESSAGEGE_FAILURE,\n                    payload: failedMessage,\n                  });\n                })\n                .onSucceeded((succeededMessage) => {\n                  logger.info('Channel: Sending file message success!', succeededMessage);\n                  messagesDispatcher({\n                    type: messageActionTypes.SEND_MESSAGEGE_SUCESS,\n                    payload: succeededMessage,\n                  });\n                });\n            },\n            file.type,\n            compressionRate,\n          );\n        };\n      } catch (error) {\n        logger.error('Channel: Sending file message failed!', error);\n      }\n    } else { // Not using image compression\n      if (createCustomParams) {\n        logger.info('Channel: creating params using onBeforeSendFileMessage', onBeforeSendFileMessage);\n      }\n      const params = onBeforeSendFileMessage\n        ? onBeforeSendFileMessage(file, quoteMessage)\n        : createParamsDefault(file);\n      logger.info('Channel: Uploading file message start!', params);\n\n      currentGroupChannel.sendFileMessage(params)\n        .onPending((pendingMsg) => {\n          pubSub.publish(topics.SEND_MESSAGE_START, {\n            /* pubSub is used instead of messagesDispatcher\n              to avoid redundantly calling `messageActionTypes.SEND_MESSAGEGE_START` */\n            message: {\n              ...pendingMsg,\n              url: URL.createObjectURL(file),\n              // pending thumbnail message seems to be failed\n              requestState: 'pending',\n            },\n            channel: currentGroupChannel,\n          });\n          setTimeout(() => utils.scrollIntoLast(0, scrollRef), 1000);\n        })\n        .onFailed((error, message) => {\n          logger.error('Channel: Sending file message failed!', { message, error });\n          // eslint-disable-next-line no-param-reassign\n          message.localUrl = URL.createObjectURL(file);\n          // eslint-disable-next-line no-param-reassign\n          message.file = file;\n          messagesDispatcher({\n            type: messageActionTypes.SEND_MESSAGEGE_FAILURE,\n            payload: message,\n          });\n        })\n        .onSucceeded((message) => {\n          logger.info('Channel: Sending message success!', message);\n          messagesDispatcher({\n            type: messageActionTypes.SEND_MESSAGEGE_SUCESS,\n            payload: message,\n          });\n        });\n    }\n  }, [currentGroupChannel, onBeforeSendFileMessage, imageCompression]);\n  return [sendMessage];\n}\n","import { useCallback } from 'react';\n\nexport default function useToggleReactionCallback({ currentGroupChannel }, { logger }) {\n  return useCallback((message, key, isReacted) => {\n    if (isReacted) {\n      currentGroupChannel.deleteReaction(message, key)\n        .then((res) => {\n          logger.info('Delete reaction success', res);\n        })\n        .catch((err) => {\n          logger.warning('Delete reaction failed', err);\n        });\n      return;\n    }\n    currentGroupChannel.addReaction(message, key)\n      .then((res) => {\n        logger.info('Add reaction success', res);\n      })\n      .catch((err) => {\n        logger.warning('Add reaction failed', err);\n      });\n  }, [currentGroupChannel]);\n}\n","import type { BaseMessage } from '@sendbird/chat/message';\nimport { useCallback } from 'react';\n\nimport { Logger } from '../../../../index';\nimport { scrollToRenderedMessage } from '../utils';\n\ninterface DynamicParams {\n  setInitialTimeStamp: React.Dispatch<React.SetStateAction<number>>;\n  setAnimatedMessageId: React.Dispatch<React.SetStateAction<number>>;\n  allMessages: BaseMessage[];\n  scrollRef: React.RefObject<HTMLDivElement>;\n}\n\ninterface StaticParams {\n  logger: Logger;\n}\n\nfunction useScrollToMessage({\n  setInitialTimeStamp,\n  setAnimatedMessageId,\n  allMessages,\n  scrollRef,\n}: DynamicParams,\n{ logger }: StaticParams,\n): (createdAt: number, messageId: number) => void {\n  return useCallback(\n    (createdAt: number, messageId: number) => {\n      const isPresent = allMessages.find((m) => (\n        m.messageId === messageId\n      ));\n      setAnimatedMessageId(null);\n      setTimeout(() => {\n        if (isPresent) {\n          logger.info('Channel: scroll to message - message is present');\n          setAnimatedMessageId(messageId);\n          scrollToRenderedMessage(scrollRef, createdAt);\n        } else {\n          logger.info('Channel: scroll to message - fetching older messages');\n          setInitialTimeStamp(null);\n          setInitialTimeStamp(createdAt);\n          setAnimatedMessageId(messageId);\n        }\n      });\n    }, [\n      setInitialTimeStamp,\n      setAnimatedMessageId,\n      allMessages,\n    ],\n  );\n}\n\nexport default useScrollToMessage;\n","import { useCallback } from 'react';\nimport { GroupChannel } from '@sendbird/chat/groupChannel';\nimport { FileMessage, FileMessageCreateParams, MessageMetaArray, UserMessage } from '@sendbird/chat/message';\nimport { Logger } from '../../../../lib/SendbirdState';\nimport * as messageActionTypes from '../dux/actionTypes';\nimport * as utils from '../utils';\nimport topics from '../../../../lib/pubSub/topics';\nimport {\n  META_ARRAY_MESSAGE_TYPE_KEY,\n  META_ARRAY_MESSAGE_TYPE_VALUE__VOICE,\n  META_ARRAY_VOICE_DURATION_KEY,\n  VOICE_MESSAGE_FILE_NAME,\n  VOICE_MESSAGE_MIME_TYPE,\n} from '../../../../utils/consts';\n\ninterface DynamicParams {\n  currentGroupChannel: GroupChannel;\n  onBeforeSendVoiceMessage?: (file: File, quoteMessage?: UserMessage | FileMessage) => FileMessageCreateParams;\n}\ninterface StaticParams {\n  logger: Logger;\n  pubSub: any;\n  scrollRef: React.RefObject<HTMLDivElement>;\n  messagesDispatcher: (props: { type: string, payload: any }) => void;\n}\ntype FuncType = (file: File, duration: number, quoteMessage: UserMessage | FileMessage) => void;\n\nexport const useSendVoiceMessageCallback = ({\n  currentGroupChannel,\n  onBeforeSendVoiceMessage,\n}: DynamicParams,\n{\n  logger,\n  pubSub,\n  scrollRef,\n  messagesDispatcher,\n}: StaticParams): Array<FuncType> => {\n  const sendMessage = useCallback((file: File, duration: number, quoteMessage: UserMessage | FileMessage) => {\n    const messageParams: FileMessageCreateParams = (\n      onBeforeSendVoiceMessage\n      && typeof onBeforeSendVoiceMessage === 'function'\n    )\n      ? onBeforeSendVoiceMessage(file, quoteMessage)\n      : {\n        file,\n        fileName: VOICE_MESSAGE_FILE_NAME,\n        mimeType: VOICE_MESSAGE_MIME_TYPE,\n        metaArrays: [\n          new MessageMetaArray({\n            key: META_ARRAY_VOICE_DURATION_KEY,\n            value: [`${duration}`],\n          }),\n          new MessageMetaArray({\n            key: META_ARRAY_MESSAGE_TYPE_KEY,\n            value: [META_ARRAY_MESSAGE_TYPE_VALUE__VOICE],\n          }),\n        ],\n      };\n    if (quoteMessage) {\n      messageParams.isReplyToChannel = true;\n      messageParams.parentMessageId = quoteMessage.messageId;\n    }\n    logger.info('Channel: Start sending voice message', messageParams);\n    currentGroupChannel.sendFileMessage(messageParams)\n      .onPending((pendingMessage) => {\n        pubSub.publish(topics.SEND_MESSAGE_START, {\n          /* pubSub is used instead of messagesDispatcher\n            to avoid redundantly calling `messageActionTypes.SEND_MESSAGEGE_START` */\n          message: pendingMessage,\n          channel: currentGroupChannel,\n        });\n        setTimeout(() => utils.scrollIntoLast(0, scrollRef), 1000);\n      })\n      .onFailed((err, failedMessage) => {\n        logger.error('Channel: Sending voice message failed!', { failedMessage, err });\n        messagesDispatcher({\n          type: messageActionTypes.SEND_MESSAGEGE_FAILURE,\n          payload: failedMessage,\n        });\n      })\n      .onSucceeded((succeededMessage) => {\n        logger.info('Channel: Sending voice message success!', succeededMessage);\n        messagesDispatcher({\n          type: messageActionTypes.SEND_MESSAGEGE_SUCESS,\n          payload: succeededMessage,\n        });\n      });\n  }, [\n    currentGroupChannel,\n    onBeforeSendVoiceMessage,\n  ]);\n  return [sendMessage];\n};\n\nexport default useSendVoiceMessageCallback;\n","import React, {\n  useEffect,\n  useState,\n  useReducer,\n  useRef,\n  useMemo,\n} from 'react';\n\nimport type { GroupChannel, SendbirdGroupChat } from '@sendbird/chat/groupChannel';\nimport type {\n  BaseMessage,\n  FileMessage,\n  FileMessageCreateParams,\n  UserMessage,\n  UserMessageCreateParams,\n  UserMessageUpdateParams,\n} from '@sendbird/chat/message';\nimport type { SendbirdError, User } from '@sendbird/chat';\n\nimport { ReplyType, RenderUserProfileProps, Nullable } from '../../../types';\nimport { UserProfileProvider } from '../../../lib/UserProfileContext';\nimport useSendbirdStateContext from '../../../hooks/useSendbirdStateContext';\nimport { CoreMessageType } from '../../../utils';\n\nimport * as utils from './utils';\nimport { getIsReactionEnabled } from '../../../utils/getIsReactionEnabled';\n\nimport messagesInitialState from './dux/initialState';\nimport messagesReducer from './dux/reducers';\nimport * as messageActionTypes from './dux/actionTypes';\n\nimport useHandleChannelEvents from './hooks/useHandleChannelEvents';\nimport useGetChannel from './hooks/useGetChannel';\nimport useInitialMessagesFetch from './hooks/useInitialMessagesFetch';\nimport useHandleReconnect from './hooks/useHandleReconnect';\nimport useScrollCallback from './hooks/useScrollCallback';\nimport useScrollDownCallback from './hooks/useScrollDownCallback';\nimport useDeleteMessageCallback from './hooks/useDeleteMessageCallback';\nimport useUpdateMessageCallback from './hooks/useUpdateMessageCallback';\nimport useResendMessageCallback from './hooks/useResendMessageCallback';\nimport useSendMessageCallback from './hooks/useSendMessageCallback';\nimport useSendFileMessageCallback from './hooks/useSendFileMessageCallback';\nimport useToggleReactionCallback from './hooks/useToggleReactionCallback';\nimport useScrollToMessage from './hooks/useScrollToMessage';\nimport { CustomUseReducerDispatcher } from '../../../lib/SendbirdState';\nimport useSendVoiceMessageCallback from './hooks/useSendVoiceMessageCallback';\n\nexport type MessageListParams = {\n  // https://sendbird.github.io/core-sdk-javascript/module-model_params_messageListParams-MessageListParams.html\n  replyType?: string,\n  messageType?: string,\n  prevResultSize?: number,\n  nextResultSize?: number,\n  reverse?: boolean,\n  isInclusive?: boolean,\n  includeMetaArray?: boolean,\n  includeReactions?: boolean,\n  includeThreadInfo?: boolean,\n  includeParentMessageInfo?: boolean,\n  showSubchannelMessagesOnly?: boolean,\n  customTypes?: Array<string>,\n  senderUserIds?: Array<string>,\n};\n\nexport type ChannelQueries = {\n  messageListParams?: MessageListParams;\n};\n\nexport enum ThreadReplySelectType {\n  PARENT = 'PARENT',\n  THREAD = 'THREAD',\n}\n\nexport type ChannelContextProps = {\n  children?: React.ReactElement;\n  channelUrl: string;\n  isReactionEnabled?: boolean;\n  isMessageGroupingEnabled?: boolean;\n  showSearchIcon?: boolean;\n  animatedMessage?: number | null;\n  highlightedMessage?: number | null;\n  startingPoint?: number | null;\n  onBeforeSendUserMessage?(text: string, quotedMessage?: UserMessage | FileMessage): UserMessageCreateParams;\n  onBeforeSendFileMessage?(file: File, quotedMessage?: UserMessage | FileMessage): FileMessageCreateParams;\n  onBeforeUpdateUserMessage?(text: string): UserMessageUpdateParams;\n  onChatHeaderActionClick?(event: React.MouseEvent<HTMLElement>): void;\n  onBeforeSendVoiceMessage?: (file: File, quotedMessage?: UserMessage | FileMessage) => FileMessageCreateParams;\n  onSearchClick?(): void;\n  onBackClick?(): void;\n  replyType?: ReplyType;\n  threadReplySelectType?: ThreadReplySelectType;\n  queries?: ChannelQueries;\n  renderUserProfile?: (props: RenderUserProfileProps) => React.ReactElement;\n  filterMessageList?(messages: BaseMessage): boolean;\n  disableUserProfile?: boolean;\n  disableMarkAsRead?: boolean;\n  onReplyInThread?: (props: { message: UserMessage | FileMessage }) => void;\n  onQuoteMessageClick?: (props: { message: UserMessage | FileMessage }) => void;\n  onMessageAnimated?: () => void;\n  onMessageHighlighted?: () => void;\n};\n\ninterface MessageStoreInterface {\n  allMessages: CoreMessageType[];\n  loading: boolean;\n  initialized: boolean;\n  unreadSince: string;\n  isInvalid: boolean;\n  currentGroupChannel: Nullable<GroupChannel>;\n  hasMorePrev: boolean;\n  oldestMessageTimeStamp: number;\n  hasMoreNext: boolean;\n  latestMessageTimeStamp: number;\n  emojiContainer: any;\n  readStatus: any;\n}\n\ninterface SendMessageParams {\n  message: string;\n  quoteMessage?: UserMessage | FileMessage;\n  // mentionedUserIds?: Array<string>;\n  mentionedUsers?: Array<User>;\n  mentionTemplate?: string;\n}\n\ninterface UpdateMessageProps {\n  messageId: string | number;\n  message: string;\n  mentionedUsers?: Array<User>;\n  mentionTemplate?: string;\n}\n\ninterface ChannelProviderInterface extends ChannelContextProps, MessageStoreInterface {\n  scrollToMessage?(createdAt: number, messageId: number): void;\n  messageActionTypes: Record<string, string>;\n  messagesDispatcher: CustomUseReducerDispatcher;\n  quoteMessage: UserMessage | FileMessage;\n  setQuoteMessage: React.Dispatch<React.SetStateAction<UserMessage | FileMessage>>;\n  initialTimeStamp: number;\n  setInitialTimeStamp: React.Dispatch<React.SetStateAction<number>>;\n  animatedMessageId: number;\n  highLightedMessageId: number;\n  nicknamesMap: Map<string, string>;\n  emojiAllMap: any;\n  onScrollCallback: any;\n  onScrollDownCallback: any;\n  scrollRef: React.MutableRefObject<HTMLDivElement>;\n  setAnimatedMessageId: React.Dispatch<React.SetStateAction<number>>;\n  setHighLightedMessageId: React.Dispatch<React.SetStateAction<number>>;\n  messageInputRef: React.MutableRefObject<HTMLInputElement>,\n  deleteMessage(message: CoreMessageType): Promise<CoreMessageType>,\n  updateMessage(props: UpdateMessageProps, callback?: (err: SendbirdError, message: UserMessage) => void): Promise<CoreMessageType>,\n  resendMessage(failedMessage: UserMessage | FileMessage): Promise<UserMessage | FileMessage>,\n  // TODO: Good to change interface to using params / This part need refactoring\n  sendMessage(props: SendMessageParams): Promise<UserMessage>,\n  sendFileMessage(file: File, quoteMessage: UserMessage | FileMessage): Promise<FileMessage>,\n  sendVoiceMessage: (file: File, duration: number, quoteMessage?: UserMessage | FileMessage) => void,\n  // sendMessage(messageParams: SendBird.UserMessageParams): Promise<SendBird.UserMessage>,\n  // sendFileMessage(messageParams: SendBird.FileMessageParams): Promise<SendBird.FileMessage>,\n  toggleReaction(message: UserMessage | FileMessage, emojiKey: string, isReacted: boolean): void,\n  renderUserMentionItem?: (props: { user: User }) => JSX.Element;\n}\n\nconst ChannelContext = React.createContext<ChannelProviderInterface | null>(undefined);\n\nconst ChannelProvider: React.FC<ChannelContextProps> = (props: ChannelContextProps) => {\n  const {\n    channelUrl,\n    children,\n    isReactionEnabled,\n    isMessageGroupingEnabled = true,\n    showSearchIcon,\n    animatedMessage,\n    highlightedMessage,\n    startingPoint,\n    onBeforeSendUserMessage,\n    onBeforeSendFileMessage,\n    onBeforeUpdateUserMessage,\n    onBeforeSendVoiceMessage,\n    onChatHeaderActionClick,\n    onSearchClick,\n    onBackClick,\n    replyType,\n    threadReplySelectType = ThreadReplySelectType.THREAD,\n    queries,\n    filterMessageList,\n    disableMarkAsRead = false,\n    onReplyInThread,\n    onQuoteMessageClick,\n    onMessageAnimated,\n    onMessageHighlighted,\n  } = props;\n\n  const globalStore = useSendbirdStateContext();\n  const { config } = globalStore;\n  const {\n    pubSub,\n    logger,\n    userId,\n    isOnline,\n    imageCompression,\n    isMentionEnabled,\n    isVoiceMessageEnabled,\n    onUserProfileMessage,\n    markAsReadScheduler,\n  } = config;\n  const sdk = globalStore?.stores?.sdkStore?.sdk as SendbirdGroupChat;\n  const sdkInit = globalStore?.stores?.sdkStore?.initialized;\n\n  const [initialTimeStamp, setInitialTimeStamp] = useState(startingPoint);\n  useEffect(() => {\n    setInitialTimeStamp(startingPoint);\n  }, [startingPoint, channelUrl]);\n  const [animatedMessageId, setAnimatedMessageId] = useState(0);\n  const [highLightedMessageId, setHighLightedMessageId] = useState(highlightedMessage);\n  useEffect(() => {\n    setHighLightedMessageId(highlightedMessage);\n  }, [highlightedMessage]);\n  const userFilledMessageListQuery = queries?.messageListParams;\n  const [quoteMessage, setQuoteMessage] = useState<UserMessage | FileMessage>(null);\n\n  const [messagesStore, messagesDispatcher] = useReducer(\n    messagesReducer,\n    messagesInitialState,\n  ) as [MessageStoreInterface, CustomUseReducerDispatcher];\n  const scrollRef = useRef(null);\n\n  const {\n    allMessages,\n    loading,\n    initialized,\n    unreadSince,\n    isInvalid,\n    currentGroupChannel,\n    hasMorePrev,\n    oldestMessageTimeStamp,\n    hasMoreNext,\n    latestMessageTimeStamp,\n    emojiContainer,\n    readStatus,\n  } = messagesStore;\n\n  const isSuper = currentGroupChannel?.isSuper || false;\n  const isBroadcast = currentGroupChannel?.isBroadcast || false;\n  const usingReaction = getIsReactionEnabled({\n    isBroadcast,\n    isSuper,\n    globalLevel: config?.isReactionEnabled,\n    moduleLevel: isReactionEnabled,\n  });\n\n  const emojiAllMap = useMemo(() => (\n    usingReaction\n      ? utils.getAllEmojisMapFromEmojiContainer(emojiContainer)\n      : new Map()\n  ), [emojiContainer]);\n  const nicknamesMap: Map<string, string> = useMemo(() => (\n    (usingReaction && currentGroupChannel)\n      ? utils.getNicknamesMapFromMembers(currentGroupChannel?.members)\n      : new Map()\n  ), [currentGroupChannel?.members]);\n\n  // Animate message\n  useEffect(() => {\n    if (animatedMessage) {\n      setAnimatedMessageId(animatedMessage);\n    }\n  }, [animatedMessage]);\n\n  // Scrollup is default scroll for channel\n  const onScrollCallback = useScrollCallback({\n    currentGroupChannel,\n    oldestMessageTimeStamp,\n    userFilledMessageListQuery,\n    replyType,\n    isVoiceMessageEnabled,\n  }, {\n    hasMorePrev,\n    logger,\n    messagesDispatcher,\n    sdk,\n  });\n\n  const scrollToMessage = useScrollToMessage({\n    setInitialTimeStamp,\n    setAnimatedMessageId,\n    allMessages,\n    scrollRef,\n  }, { logger });\n\n  // onScrollDownCallback is added for navigation to different timestamps on messageSearch\n  // hasMorePrev, onScrollCallback -> scroll up(default behavior)\n  // hasMoreNext, onScrollDownCallback -> scroll down\n  const onScrollDownCallback = useScrollDownCallback({\n    currentGroupChannel,\n    latestMessageTimeStamp,\n    userFilledMessageListQuery,\n    hasMoreNext,\n    replyType,\n    isVoiceMessageEnabled,\n  }, {\n    logger,\n    messagesDispatcher,\n    sdk,\n  });\n\n  const toggleReaction = useToggleReactionCallback({ currentGroupChannel }, { logger });\n\n  // to create message-datasource\n  // this hook sets currentGroupChannel asynchronously\n  useGetChannel(\n    { channelUrl, sdkInit, disableMarkAsRead },\n    { messagesDispatcher, sdk, logger, markAsReadScheduler },\n  );\n\n  // to set quote message as null\n  useEffect(() => {\n    setQuoteMessage(null);\n  }, [channelUrl]);\n\n  // Hook to handle ChannelEvents and send values to useReducer using messagesDispatcher\n  useHandleChannelEvents(\n    {\n      currentGroupChannel,\n      sdkInit,\n      currentUserId: userId,\n      disableMarkAsRead,\n    },\n    {\n      messagesDispatcher,\n      sdk,\n      logger,\n      scrollRef,\n      setQuoteMessage,\n    },\n  );\n\n  // hook that fetches messages when channel changes\n  // to be clear here useGetChannel sets currentGroupChannel\n  // and useInitialMessagesFetch executes when currentGroupChannel changes\n  // p.s This one executes on initialTimeStamp change too\n  useInitialMessagesFetch({\n    currentGroupChannel,\n    userFilledMessageListQuery,\n    initialTimeStamp,\n    latestMessageTimeStamp,\n    replyType,\n    isVoiceMessageEnabled,\n  }, {\n    logger,\n    scrollRef,\n    messagesDispatcher,\n  });\n\n  // handles API calls from withSendbird\n  useEffect(() => {\n    const subscriber = utils.pubSubHandler({\n      channelUrl,\n      pubSub,\n      dispatcher: messagesDispatcher,\n      scrollRef,\n    });\n    return () => {\n      utils.pubSubHandleRemover(subscriber);\n    };\n  }, [channelUrl, sdkInit]);\n\n  // handling connection breaks\n  useHandleReconnect({ isOnline, replyType, disableMarkAsRead }, {\n    logger,\n    sdk,\n    scrollRef,\n    currentGroupChannel,\n    messagesDispatcher,\n    userFilledMessageListQuery,\n    markAsReadScheduler,\n  });\n\n  // callbacks for Message CURD actions\n  const deleteMessage = useDeleteMessageCallback({ currentGroupChannel, messagesDispatcher },\n    { logger });\n  const updateMessage = useUpdateMessageCallback(\n    { currentGroupChannel, messagesDispatcher, onBeforeUpdateUserMessage, isMentionEnabled },\n    { logger, pubSub },\n  );\n  const resendMessage = useResendMessageCallback(\n    { currentGroupChannel, messagesDispatcher },\n    { logger },\n  );\n  const [messageInputRef, sendMessage] = useSendMessageCallback(\n    { currentGroupChannel, onBeforeSendUserMessage, isMentionEnabled },\n    {\n      logger,\n      pubSub,\n      scrollRef,\n      messagesDispatcher,\n    },\n  );\n  const [sendFileMessage] = useSendFileMessageCallback(\n    { currentGroupChannel, onBeforeSendFileMessage, imageCompression },\n    {\n      logger,\n      pubSub,\n      scrollRef,\n      messagesDispatcher,\n    },\n  );\n  const [sendVoiceMessage] = useSendVoiceMessageCallback(\n    {\n      currentGroupChannel,\n      onBeforeSendVoiceMessage,\n    },\n    {\n      logger,\n      pubSub,\n      scrollRef,\n      messagesDispatcher,\n    },\n  );\n\n  return (\n    <ChannelContext.Provider value={{\n      // props\n      channelUrl,\n      isReactionEnabled: usingReaction,\n      isMessageGroupingEnabled,\n      showSearchIcon,\n      highlightedMessage,\n      startingPoint,\n      onBeforeSendUserMessage,\n      onBeforeSendFileMessage,\n      onBeforeUpdateUserMessage,\n      onChatHeaderActionClick,\n      onSearchClick,\n      onBackClick,\n      replyType,\n      threadReplySelectType,\n      queries,\n      filterMessageList,\n      disableMarkAsRead,\n      onReplyInThread,\n      onQuoteMessageClick,\n      onMessageAnimated,\n      onMessageHighlighted,\n\n      // messagesStore\n      allMessages,\n      loading,\n      initialized,\n      unreadSince,\n      isInvalid,\n      currentGroupChannel,\n      hasMorePrev,\n      hasMoreNext,\n      oldestMessageTimeStamp,\n      latestMessageTimeStamp,\n      emojiContainer,\n      readStatus,\n\n      // utils\n      scrollToMessage,\n      quoteMessage,\n      setQuoteMessage,\n      deleteMessage,\n      updateMessage,\n      resendMessage,\n      messageInputRef,\n      sendMessage,\n      sendFileMessage,\n      sendVoiceMessage,\n      initialTimeStamp,\n      messageActionTypes,\n      messagesDispatcher,\n      setInitialTimeStamp,\n      setAnimatedMessageId,\n      setHighLightedMessageId,\n      animatedMessageId,\n      highLightedMessageId,\n      nicknamesMap,\n      emojiAllMap,\n      onScrollCallback,\n      onScrollDownCallback,\n      scrollRef,\n      toggleReaction,\n    }}>\n      <UserProfileProvider\n        disableUserProfile={props?.disableUserProfile}\n        renderUserProfile={props?.renderUserProfile}\n        onUserProfileMessage={onUserProfileMessage}\n      >\n        {children}\n      </UserProfileProvider>\n    </ChannelContext.Provider>\n  );\n};\n\nexport type UseChannelType = () => ChannelProviderInterface;\nconst useChannelContext: UseChannelType = () => React.useContext(ChannelContext);\n\nexport {\n  ChannelProvider,\n  useChannelContext,\n};\n"]},"metadata":{},"sourceType":"module"}