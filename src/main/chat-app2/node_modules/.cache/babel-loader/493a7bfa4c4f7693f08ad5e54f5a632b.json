{"ast":null,"code":"import { WavHeader as $dd7ee3788d91dcb8$export$cb948f2d6837f136, Mp3Encoder as $dd7ee3788d91dcb8$export$9ca5d136ebf61cf2 } from './lame.all.js';\n\n// Thanks to https://codesandbox.io/s/media-recorder-api-downsampling-16k-mp3-encode-using-lame-js-forked-n1pblw\nfunction encodeMp3(arrayBuffer) {\n  var wav = $dd7ee3788d91dcb8$export$cb948f2d6837f136.readHeader(new DataView(arrayBuffer));\n  var dataView = new Int16Array(arrayBuffer, wav.dataOffset, wav.dataLen / 2);\n  var mp3Encoder = new $dd7ee3788d91dcb8$export$9ca5d136ebf61cf2(wav.channels, wav.sampleRate, 128);\n  var maxSamples = 1152;\n  var samplesLeft = wav.channels === 1 ? dataView : new Int16Array(wav.dataLen / (2 * wav.channels));\n  var samplesRight = wav.channels === 2 ? new Int16Array(wav.dataLen / (2 * wav.channels)) : undefined;\n  if (wav.channels > 1) {\n    for (var j = 0; j < samplesLeft.length; j++) {\n      samplesLeft[j] = dataView[j * 2];\n      samplesRight[j] = dataView[j * 2 + 1];\n    }\n  }\n  var dataBuffer = [];\n  var remaining = samplesLeft.length;\n  for (var i = 0; remaining >= maxSamples; i += maxSamples) {\n    var left = samplesLeft.subarray(i, i + maxSamples);\n    var right = void 0;\n    if (samplesRight) {\n      right = samplesRight.subarray(i, i + maxSamples);\n    }\n    var mp3buf = mp3Encoder.encodeBuffer(left, right);\n    dataBuffer.push(new Int8Array(mp3buf));\n    remaining -= maxSamples;\n  }\n  var mp3Lastbuf = mp3Encoder.flush();\n  dataBuffer.push(new Int8Array(mp3Lastbuf));\n  return dataBuffer;\n}\n\n// Convert audioFile to arrayBuffer, because Mp3Encoder requires a parameter of ArrayBuffer type\nfunction downsampleToWav(file, callback) {\n  // Browser compatibility\n  // https://caniuse.com/?search=AudioContext\n  var audioCtx = new AudioContext();\n  var fileReader = new FileReader();\n  fileReader.onload = function (ev) {\n    // Decode audio\n    audioCtx.decodeAudioData(ev.target.result, function (buffer) {\n      // this is where you down sample the audio, usually is 44100 samples per second\n      var usingWebkit = !window.OfflineAudioContext;\n      var offlineAudioCtx = new OfflineAudioContext(1, 16000 * buffer.duration, 16000);\n      var soundSource = offlineAudioCtx.createBufferSource();\n      soundSource.buffer = buffer;\n      soundSource.connect(offlineAudioCtx.destination);\n      var reader = new FileReader();\n      reader.onload = function () {\n        var renderCompleteHandler = function renderCompleteHandler(evt) {\n          var renderedBuffer = usingWebkit ? evt.renderedBuffer : evt;\n          var buffer = bufferToWav(renderedBuffer, renderedBuffer.length);\n          if (callback) {\n            callback(buffer);\n          }\n        };\n        if (usingWebkit) {\n          offlineAudioCtx.oncomplete = renderCompleteHandler;\n          offlineAudioCtx.startRendering();\n        } else {\n          offlineAudioCtx.startRendering().then(renderCompleteHandler)\n          // eslint-disable-next-line no-console\n          .catch(function (err) {\n            return console.warn(err);\n          });\n        }\n      };\n      reader.readAsArrayBuffer(file);\n      soundSource.start(0);\n    });\n  };\n  fileReader.readAsArrayBuffer(file);\n}\nfunction bufferToWav(abuffer, len) {\n  var numOfChan = abuffer.numberOfChannels;\n  var length = len * numOfChan * 2 + 44;\n  var buffer = new ArrayBuffer(length);\n  var view = new DataView(buffer);\n  var channels = [];\n  var i = 0;\n  var sample;\n  var offset = 0;\n  var pos = 0;\n\n  // write WAVE header\n  setUint32(0x46464952); // \"RIFF\"\n  setUint32(length - 8); // file length - 8\n  setUint32(0x45564157); // \"WAVE\"\n  setUint32(0x20746d66); // \"fmt \" chunk\n  setUint32(16); // length = 16\n  setUint16(1); // PCM (uncompressed)\n  setUint16(numOfChan);\n  setUint32(abuffer.sampleRate);\n  setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec\n  setUint16(numOfChan * 2); // block-align\n  setUint16(16); // 16-bit (hardcoded in this demo)\n  setUint32(0x61746164); // \"data\" - chunk\n  setUint32(length - pos - 4); // chunk length\n  // write interleaved data\n  for (i = 0; i < abuffer.numberOfChannels; i++) {\n    channels.push(abuffer.getChannelData(i));\n  }\n  while (pos < length) {\n    for (i = 0; i < numOfChan; i++) {\n      // interleave channels\n      sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp\n      sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; // scale to 16-bit signed int\n      view.setInt16(pos, sample, true); // write 16-bit sample\n      pos += 2;\n    }\n    offset++; // next source sample\n  }\n\n  return buffer;\n  function setUint16(data) {\n    view.setUint16(pos, data, true);\n    pos += 2;\n  }\n  function setUint32(data) {\n    view.setUint32(pos, data, true);\n    pos += 4;\n  }\n}\nexport { downsampleToWav, encodeMp3 };","map":{"version":3,"mappings":"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","names":["encodeMp3","arrayBuffer","wav","WavHeader","readHeader","DataView","dataView","Int16Array","dataOffset","dataLen","mp3Encoder","Mp3Encoder","channels","sampleRate","maxSamples","samplesLeft","samplesRight","undefined","j","length","dataBuffer","remaining","i","left","subarray","right","mp3buf","encodeBuffer","push","Int8Array","mp3Lastbuf","flush","downsampleToWav","file","callback","audioCtx","AudioContext","fileReader","FileReader","onload","ev","decodeAudioData","target","result","buffer","usingWebkit","window","OfflineAudioContext","offlineAudioCtx","duration","soundSource","createBufferSource","connect","destination","reader","renderCompleteHandler","evt","renderedBuffer","bufferToWav","oncomplete","startRendering","then","catch","err","console","warn","readAsArrayBuffer","start","abuffer","len","numOfChan","numberOfChannels","ArrayBuffer","view","sample","offset","pos","setUint32","setUint16","getChannelData","Math","max","min","setInt16","data"],"sources":["C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\hooks\\VoiceRecorder\\WebAudioUtils.ts"],"sourcesContent":["// Thanks to https://codesandbox.io/s/media-recorder-api-downsampling-16k-mp3-encode-using-lame-js-forked-n1pblw\nimport { WavHeader, Mp3Encoder } from '../../_externals/lamejs/lame.all';\n\nfunction encodeMp3(arrayBuffer: ArrayBuffer): WavHeader {\n  const wav = WavHeader.readHeader(new DataView(arrayBuffer));\n  const dataView = new Int16Array(arrayBuffer, wav.dataOffset, wav.dataLen / 2);\n  const mp3Encoder = new Mp3Encoder(wav.channels, wav.sampleRate, 128);\n  const maxSamples = 1152;\n\n  const samplesLeft = (wav.channels === 1) ? dataView : new Int16Array(wav.dataLen / (2 * wav.channels));\n  const samplesRight = (wav.channels === 2) ? new Int16Array(wav.dataLen / (2 * wav.channels)) : undefined;\n\n  if (wav.channels > 1) {\n    for (let j = 0; j < samplesLeft.length; j++) {\n      samplesLeft[j] = dataView[j * 2];\n      samplesRight[j] = dataView[j * 2 + 1];\n    }\n  }\n\n  const dataBuffer = [];\n  let remaining = samplesLeft.length;\n  for (let i = 0; remaining >= maxSamples; i += maxSamples) {\n    const left = samplesLeft.subarray(i, i + maxSamples);\n    let right;\n    if (samplesRight) {\n      right = samplesRight.subarray(i, i + maxSamples);\n    }\n    const mp3buf = mp3Encoder.encodeBuffer(left, right);\n    dataBuffer.push(new Int8Array(mp3buf));\n    remaining -= maxSamples;\n  }\n\n  const mp3Lastbuf = mp3Encoder.flush();\n  dataBuffer.push(new Int8Array(mp3Lastbuf));\n  return dataBuffer;\n}\n\n// Convert audioFile to arrayBuffer, because Mp3Encoder requires a parameter of ArrayBuffer type\nfunction downsampleToWav(file: File, callback: (buffer: ArrayBuffer) => void): void {\n  // Browser compatibility\n  // https://caniuse.com/?search=AudioContext\n  const audioCtx = new AudioContext();\n  const fileReader = new FileReader();\n  fileReader.onload = function (ev) {\n    // Decode audio\n    audioCtx.decodeAudioData(ev.target.result as ArrayBuffer, (buffer) => {\n      // this is where you down sample the audio, usually is 44100 samples per second\n      const usingWebkit = !window.OfflineAudioContext;\n      const offlineAudioCtx = new OfflineAudioContext(1, 16000 * buffer.duration, 16000);\n\n      const soundSource = offlineAudioCtx.createBufferSource();\n      soundSource.buffer = buffer;\n      soundSource.connect(offlineAudioCtx.destination);\n\n      const reader = new FileReader();\n      reader.onload = function () {\n        const renderCompleteHandler = (evt): void => {\n          const renderedBuffer = usingWebkit ? evt.renderedBuffer : evt;\n          const buffer = bufferToWav(renderedBuffer, renderedBuffer.length);\n          if (callback) {\n            callback(buffer);\n          }\n        };\n        if (usingWebkit) {\n          offlineAudioCtx.oncomplete = renderCompleteHandler;\n          offlineAudioCtx.startRendering();\n        } else {\n          offlineAudioCtx\n            .startRendering()\n            .then(renderCompleteHandler)\n            // eslint-disable-next-line no-console\n            .catch((err) => console.warn(err));\n        }\n      };\n      reader.readAsArrayBuffer(file);\n      soundSource.start(0);\n    });\n  };\n  fileReader.readAsArrayBuffer(file);\n}\n\nfunction bufferToWav(abuffer, len) {\n  const numOfChan = abuffer.numberOfChannels;\n  const length = len * numOfChan * 2 + 44;\n  const buffer = new ArrayBuffer(length);\n  const view = new DataView(buffer);\n  const channels = [];\n  let i = 0;\n  let sample;\n  let offset = 0;\n  let pos = 0;\n\n  // write WAVE header\n  setUint32(0x46464952); // \"RIFF\"\n  setUint32(length - 8); // file length - 8\n  setUint32(0x45564157); // \"WAVE\"\n  setUint32(0x20746d66); // \"fmt \" chunk\n  setUint32(16); // length = 16\n  setUint16(1); // PCM (uncompressed)\n  setUint16(numOfChan);\n  setUint32(abuffer.sampleRate);\n  setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec\n  setUint16(numOfChan * 2); // block-align\n  setUint16(16); // 16-bit (hardcoded in this demo)\n  setUint32(0x61746164); // \"data\" - chunk\n  setUint32(length - pos - 4); // chunk length\n  // write interleaved data\n  for (i = 0; i < abuffer.numberOfChannels; i++)\n    channels.push(abuffer.getChannelData(i));\n\n  while (pos < length) {\n    for (i = 0; i < numOfChan; i++) {\n      // interleave channels\n      sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp\n      sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; // scale to 16-bit signed int\n      view.setInt16(pos, sample, true); // write 16-bit sample\n      pos += 2;\n    }\n    offset++; // next source sample\n  }\n\n  return buffer;\n\n  function setUint16(data) {\n    view.setUint16(pos, data, true);\n    pos += 2;\n  }\n\n  function setUint32(data) {\n    view.setUint32(pos, data, true);\n    pos += 4;\n  }\n}\n\nexport { downsampleToWav, encodeMp3 };\n"]},"metadata":{},"sourceType":"module"}