{"ast":null,"code":"import _slicedToArray from \"C:/Users/\\uC774\\uACBD\\uBBFC/IdeaProjects/sendbird-uikit-whatsapp-sample/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport React__default, { useState, useEffect, useCallback, useContext, createContext } from 'react';\nimport { B as BROWSER_SUPPORT_MIME_TYPE_LIST, h as VOICE_RECORDER_AUDIO_BITS, b as VOICE_MESSAGE_FILE_NAME, c as VOICE_MESSAGE_MIME_TYPE } from '../consts-95d8566e.js';\nimport useSendbirdStateContext from '../useSendbirdStateContext.js';\nimport '../withSendbird.js';\nimport '../_rollupPluginBabelHelpers-6bb0305c.js';\n\n// Input props of VoiceRecorder\n\n// Output of VoiceRecorder\n\nvar noop = function noop() {/* noop */};\nvar Context = /*#__PURE__*/createContext({\n  start: noop,\n  stop: noop,\n  isRecordable: false\n});\nvar VoiceRecorderProvider = function VoiceRecorderProvider(props) {\n  var _BROWSER_SUPPORT_MIME;\n  var children = props.children;\n  var _useSendbirdStateCont = useSendbirdStateContext(),\n    config = _useSendbirdStateCont.config;\n  var logger = config.logger,\n    isVoiceMessageEnabled = config.isVoiceMessageEnabled;\n  var _useState = useState(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    mediaRecorder = _useState2[0],\n    setMediaRecorder = _useState2[1];\n  var _useState3 = useState(false),\n    _useState4 = _slicedToArray(_useState3, 2),\n    isRecordable = _useState4[0],\n    setIsRecordable = _useState4[1];\n  var browserSupportMimeType = (_BROWSER_SUPPORT_MIME = BROWSER_SUPPORT_MIME_TYPE_LIST.find(function (mimeType) {\n    return MediaRecorder.isTypeSupported(mimeType);\n  })) !== null && _BROWSER_SUPPORT_MIME !== void 0 ? _BROWSER_SUPPORT_MIME : '';\n  if (!browserSupportMimeType) {\n    logger.error('VoiceRecorder: Browser does not support mimeType', {\n      mimmeTypes: BROWSER_SUPPORT_MIME_TYPE_LIST\n    });\n  }\n  var _useState5 = useState(null),\n    _useState6 = _slicedToArray(_useState5, 2),\n    webAudioUtils = _useState6[0],\n    setWebAudioUtils = _useState6[1];\n  useEffect(function () {\n    if (isVoiceMessageEnabled && !webAudioUtils) {\n      import('../WebAudioUtils-6df19fcc.js').then(function (data) {\n        setWebAudioUtils(data);\n      });\n    }\n  }, []);\n  var start = useCallback(function (eventHandler) {\n    var _navigator, _navigator$mediaDevic, _navigator$mediaDevic2;\n    if (isVoiceMessageEnabled && !webAudioUtils) {\n      logger.error('VoiceRecorder: Recording audio processor is being loaded.');\n      return;\n    }\n    logger.info('VoiceRecorder: Start recording.');\n    if (mediaRecorder) {\n      stop();\n      logger.info('VoiceRecorder: Previous mediaRecorder is stopped.');\n    }\n    (_navigator = navigator) === null || _navigator === void 0 ? void 0 : (_navigator$mediaDevic = _navigator.mediaDevices) === null || _navigator$mediaDevic === void 0 ? void 0 : (_navigator$mediaDevic2 = _navigator$mediaDevic.getUserMedia) === null || _navigator$mediaDevic2 === void 0 ? void 0 : _navigator$mediaDevic2.call(_navigator$mediaDevic, {\n      audio: true\n    }).then(function (stream) {\n      logger.info('VoiceRecorder: Succeeded getting media stream.', stream);\n      setIsRecordable(true);\n      var mediaRecorder = new MediaRecorder(stream, {\n        mimeType: browserSupportMimeType,\n        audioBitsPerSecond: VOICE_RECORDER_AUDIO_BITS\n      });\n      mediaRecorder.ondataavailable = function (e) {\n        var _stream$getAudioTrack, _stream$getAudioTrack2, _stream$getAudioTrack3;\n        // when recording stops\n        logger.info('VoiceRecorder: Succeeded getting an available data.', e.data);\n        var audioFile = new File([e.data], VOICE_MESSAGE_FILE_NAME, {\n          lastModified: new Date().getTime(),\n          type: VOICE_MESSAGE_MIME_TYPE\n        });\n        webAudioUtils === null || webAudioUtils === void 0 ? void 0 : webAudioUtils.downsampleToWav(audioFile, function (buffer) {\n          var mp3Buffer = webAudioUtils === null || webAudioUtils === void 0 ? void 0 : webAudioUtils.encodeMp3(buffer);\n          var mp3blob = new Blob(mp3Buffer, {\n            type: VOICE_MESSAGE_MIME_TYPE\n          });\n          var convertedAudioFile = new File([mp3blob], VOICE_MESSAGE_FILE_NAME, {\n            lastModified: new Date().getTime(),\n            type: VOICE_MESSAGE_MIME_TYPE\n          });\n          eventHandler === null || eventHandler === void 0 ? void 0 : eventHandler.onRecordingEnded(convertedAudioFile);\n          logger.info('VoiceRecorder: Succeeded converting audio file.', convertedAudioFile);\n        });\n        stream === null || stream === void 0 ? void 0 : (_stream$getAudioTrack = stream.getAudioTracks) === null || _stream$getAudioTrack === void 0 ? void 0 : (_stream$getAudioTrack2 = (_stream$getAudioTrack3 = _stream$getAudioTrack.call(stream)).forEach) === null || _stream$getAudioTrack2 === void 0 ? void 0 : _stream$getAudioTrack2.call(_stream$getAudioTrack3, function (track) {\n          return track === null || track === void 0 ? void 0 : track.stop();\n        });\n        setIsRecordable(false);\n      };\n      mediaRecorder === null || mediaRecorder === void 0 ? void 0 : mediaRecorder.start();\n      setMediaRecorder(mediaRecorder);\n      eventHandler === null || eventHandler === void 0 ? void 0 : eventHandler.onRecordingStarted();\n    }).catch(function (err) {\n      logger.error('VoiceRecorder: Failed getting media stream.', err);\n      setMediaRecorder(null);\n    });\n  }, [mediaRecorder, webAudioUtils]);\n  var stop = useCallback(function () {\n    // Stop recording\n    mediaRecorder === null || mediaRecorder === void 0 ? void 0 : mediaRecorder.stop();\n    setMediaRecorder(null);\n    setIsRecordable(false);\n    logger.info('VoiceRecorder: Stop recording.');\n  }, [mediaRecorder]);\n  return /*#__PURE__*/React__default.createElement(Context.Provider, {\n    value: {\n      start: start,\n      stop: stop,\n      isRecordable: isRecordable\n    }\n  }, children);\n};\nvar useVoiceRecorderContext = function useVoiceRecorderContext() {\n  return useContext(Context);\n};\nvar index = {\n  VoiceRecorderProvider: VoiceRecorderProvider,\n  useVoiceRecorderContext: useVoiceRecorderContext\n};\nexport { VoiceRecorderProvider, index as default, useVoiceRecorderContext };","map":{"version":3,"mappings":"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","names":["noop","Context","createContext","start","stop","isRecordable","VoiceRecorderProvider","props","children","useSendbirdStateContext","config","logger","isVoiceMessageEnabled","useState","mediaRecorder","setMediaRecorder","setIsRecordable","browserSupportMimeType","BROWSER_SUPPORT_MIME_TYPE_LIST","find","mimeType","MediaRecorder","isTypeSupported","error","mimmeTypes","webAudioUtils","setWebAudioUtils","useEffect","then","data","useCallback","eventHandler","info","_navigator","mediaDevices","_navigator$mediaDevic","getUserMedia","_navigator$mediaDevic2","audio","stream","audioBitsPerSecond","VOICE_RECORDER_AUDIO_BITS","ondataavailable","e","audioFile","File","VOICE_MESSAGE_FILE_NAME","lastModified","Date","getTime","type","VOICE_MESSAGE_MIME_TYPE","downsampleToWav","buffer","mp3Buffer","encodeMp3","mp3blob","Blob","convertedAudioFile","onRecordingEnded","getAudioTracks","forEach","_stream$getAudioTrack2","track","onRecordingStarted","catch","err","React","Provider","value","useVoiceRecorderContext","useContext"],"sources":["C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\hooks\\VoiceRecorder\\index.tsx"],"sourcesContent":["import React, { createContext, useCallback, useContext, useEffect, useState } from 'react';\nimport {\n  BROWSER_SUPPORT_MIME_TYPE_LIST,\n  VOICE_MESSAGE_FILE_NAME,\n  VOICE_MESSAGE_MIME_TYPE,\n  VOICE_RECORDER_AUDIO_BITS,\n} from '../../utils/consts';\nimport useSendbirdStateContext from '../useSendbirdStateContext';\n\n// Input props of VoiceRecorder\nexport interface VoiceRecorderProps {\n  children: React.ReactElement;\n}\n\nexport interface VoiceRecorderEventHandler {\n  onRecordingStarted?: () => void;\n  onRecordingEnded?: (props: null | File) => void;\n}\n\n// Output of VoiceRecorder\nexport interface VoiceRecorderContext {\n  start: (eventHandler?: VoiceRecorderEventHandler) => void,\n  stop: () => void,\n  isRecordable: boolean;\n}\nconst noop = () => { /* noop */ };\nconst Context = createContext<VoiceRecorderContext>({\n  start: noop,\n  stop: noop,\n  isRecordable: false,\n});\n\nexport const VoiceRecorderProvider = (props: VoiceRecorderProps): React.ReactElement => {\n  const { children } = props;\n  const { config } = useSendbirdStateContext();\n  const { logger, isVoiceMessageEnabled } = config;\n  const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder>(null);\n  const [isRecordable, setIsRecordable] = useState<boolean>(false);\n\n  const browserSupportMimeType = BROWSER_SUPPORT_MIME_TYPE_LIST.find((mimeType) => MediaRecorder.isTypeSupported(mimeType)) ?? '';\n  if (!browserSupportMimeType) {\n    logger.error('VoiceRecorder: Browser does not support mimeType', { mimmeTypes: BROWSER_SUPPORT_MIME_TYPE_LIST });\n  }\n\n  const [webAudioUtils, setWebAudioUtils] = useState(null);\n  useEffect(() => {\n    if (isVoiceMessageEnabled && !webAudioUtils) {\n      import('./WebAudioUtils').then((data) => {\n        setWebAudioUtils(data);\n      });\n    }\n  }, []);\n\n  const start = useCallback((eventHandler: VoiceRecorderEventHandler): void => {\n    if (isVoiceMessageEnabled && !webAudioUtils) {\n      logger.error('VoiceRecorder: Recording audio processor is being loaded.');\n      return;\n    }\n\n    logger.info('VoiceRecorder: Start recording.');\n    if (mediaRecorder) {\n      stop();\n      logger.info('VoiceRecorder: Previous mediaRecorder is stopped.');\n    }\n    navigator?.mediaDevices?.getUserMedia?.({ audio: true })\n      .then((stream) => {\n        logger.info('VoiceRecorder: Succeeded getting media stream.', stream);\n        setIsRecordable(true);\n        const mediaRecorder = new MediaRecorder(stream, {\n          mimeType: browserSupportMimeType,\n          audioBitsPerSecond: VOICE_RECORDER_AUDIO_BITS,\n        });\n        mediaRecorder.ondataavailable = (e) => { // when recording stops\n          logger.info('VoiceRecorder: Succeeded getting an available data.', e.data);\n          const audioFile = new File([e.data], VOICE_MESSAGE_FILE_NAME, {\n            lastModified: new Date().getTime(),\n            type: VOICE_MESSAGE_MIME_TYPE,\n          });\n          webAudioUtils?.downsampleToWav(audioFile, (buffer) => {\n            const mp3Buffer = webAudioUtils?.encodeMp3(buffer);\n            const mp3blob = new Blob(mp3Buffer, { type: VOICE_MESSAGE_MIME_TYPE });\n            const convertedAudioFile = new File([mp3blob], VOICE_MESSAGE_FILE_NAME, {\n              lastModified: new Date().getTime(),\n              type: VOICE_MESSAGE_MIME_TYPE,\n            });\n            eventHandler?.onRecordingEnded(convertedAudioFile);\n            logger.info('VoiceRecorder: Succeeded converting audio file.', convertedAudioFile);\n          });\n          stream?.getAudioTracks?.().forEach?.(track => track?.stop());\n          setIsRecordable(false);\n        };\n        mediaRecorder?.start();\n        setMediaRecorder(mediaRecorder);\n        eventHandler?.onRecordingStarted();\n      })\n      .catch((err) => {\n        logger.error('VoiceRecorder: Failed getting media stream.', err);\n        setMediaRecorder(null);\n      });\n  }, [mediaRecorder, webAudioUtils]);\n\n  const stop = useCallback((): void => {\n    // Stop recording\n    mediaRecorder?.stop();\n    setMediaRecorder(null);\n    setIsRecordable(false);\n    logger.info('VoiceRecorder: Stop recording.');\n  }, [mediaRecorder]);\n\n  return (\n    <Context.Provider value={{\n      start,\n      stop,\n      isRecordable,\n    }}>\n      {children}\n    </Context.Provider>\n  );\n};\n\nexport const useVoiceRecorderContext = (): VoiceRecorderContext => useContext(Context);\n\nexport default {\n  VoiceRecorderProvider,\n  useVoiceRecorderContext,\n};\n"]},"metadata":{},"sourceType":"module"}