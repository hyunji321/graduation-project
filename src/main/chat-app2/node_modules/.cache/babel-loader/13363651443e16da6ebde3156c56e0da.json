{"ast":null,"code":"import _toConsumableArray from \"C:/Users/\\uC774\\uACBD\\uBBFC/IdeaProjects/sendbird-uikit-whatsapp-sample/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { A as isUrl } from './index-7eb65acf.js';\nvar USER_MENTION_PREFIX = '@';\nvar TOKEN_TYPES = {\n  string: 'string',\n  mention: 'mention',\n  url: 'url',\n  undetermined: 'undetermined'\n};\nfunction getUserMentionRegex(mentionedUsers, templatePrefix_) {\n  var templatePrefix = templatePrefix_ || USER_MENTION_PREFIX;\n  return RegExp(\"(\".concat(mentionedUsers.map(function (u) {\n    var userId = u.userId.replace(\n    // If user.id includes these patterns, need to convert it into an escaped one\n    /([.*+?^${}()|[\\]\\\\])/g, '\\\\$1');\n    /**\n     * //{ And //} are also for escaping\n     * because curly braces `{}` are metacharacters in regular expressions used to specify repetition\n     */\n    return \"\".concat(templatePrefix, \"\\\\{\").concat(userId, \"\\\\}\");\n  }).join('|'), \")\"), 'g');\n}\nfunction identifyMentions(_ref) {\n  var tokens = _ref.tokens,\n    _ref$mentionedUsers = _ref.mentionedUsers,\n    mentionedUsers = _ref$mentionedUsers === void 0 ? [] : _ref$mentionedUsers,\n    _ref$templatePrefix = _ref.templatePrefix,\n    templatePrefix = _ref$templatePrefix === void 0 ? USER_MENTION_PREFIX : _ref$templatePrefix;\n  if (!(mentionedUsers !== null && mentionedUsers !== void 0 && mentionedUsers.length)) {\n    return tokens;\n  }\n  var userMentionRegex = getUserMentionRegex(mentionedUsers, templatePrefix);\n  var results = tokens.map(function (token) {\n    // if the token is not undetermined, return it as is\n    // is kinda unnecessary with TS, but just in case\n    if (token.type !== TOKEN_TYPES.undetermined) {\n      return token;\n    }\n    var value = token.value;\n    var parts = value.split(userMentionRegex);\n    var tokens = parts.map(function (part) {\n      if (part.match(userMentionRegex)) {\n        var matchedUser = mentionedUsers.find(function (user) {\n          return \"@{\".concat(user === null || user === void 0 ? void 0 : user.userId, \"}\") === part;\n        });\n        var nickname = (matchedUser === null || matchedUser === void 0 ? void 0 : matchedUser.nickname) || '(No name)';\n        return {\n          value: nickname,\n          type: TOKEN_TYPES.mention,\n          userId: matchedUser === null || matchedUser === void 0 ? void 0 : matchedUser.userId\n        };\n      } else {\n        return {\n          value: part,\n          type: TOKEN_TYPES.undetermined\n        };\n      }\n    });\n    return tokens;\n  }).flat();\n  return results;\n}\nfunction identifyUrlsAndStrings(token) {\n  var results = token.map(function (token) {\n    if (token.type !== TOKEN_TYPES.undetermined) {\n      return token;\n    }\n    var _token$value = token.value,\n      value = _token$value === void 0 ? '' : _token$value;\n    var parts = value.split(' ');\n    var tokens = parts.map(function (part) {\n      if (isUrl(part)) {\n        return {\n          value: part,\n          type: TOKEN_TYPES.url\n        };\n      } else {\n        return {\n          value: part,\n          type: TOKEN_TYPES.string\n        };\n      }\n    });\n    return tokens;\n  }).flat();\n  return results;\n}\nfunction combineNearbyStrings(tokens) {\n  var results = tokens.reduce(function (acc, token) {\n    var lastToken = acc[acc.length - 1];\n    if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === TOKEN_TYPES.string && token.type === TOKEN_TYPES.string) {\n      lastToken.value = \"\".concat(lastToken.value, \" \").concat(token.value);\n      return acc;\n    }\n    return [].concat(_toConsumableArray(acc), [token]);\n  }, []);\n  return results;\n}\n\n/**\n * Converts text into set of rich tokens\n */\nfunction tokenizeMessage(_ref2) {\n  var messageText = _ref2.messageText,\n    _ref2$mentionedUsers = _ref2.mentionedUsers,\n    mentionedUsers = _ref2$mentionedUsers === void 0 ? [] : _ref2$mentionedUsers,\n    _ref2$templatePrefix = _ref2.templatePrefix,\n    templatePrefix = _ref2$templatePrefix === void 0 ? USER_MENTION_PREFIX : _ref2$templatePrefix;\n  // mention can be squeezed-in(no-space-between) with other mentions and urls\n  // if no users are mentioned, return the messageText as a single token\n  var partialResult = [{\n    type: TOKEN_TYPES.undetermined,\n    value: messageText\n  }];\n\n  // order is important because we want to identify mentions first\n  // identifyMentions will return a token with type mention or undetermined\n  var partialWithMentions = identifyMentions({\n    tokens: partialResult,\n    mentionedUsers: mentionedUsers,\n    templatePrefix: templatePrefix\n  });\n  var partialsWithUrlsAndMentions = identifyUrlsAndStrings(partialWithMentions);\n  var result = combineNearbyStrings(partialsWithUrlsAndMentions);\n  return result;\n}\n\n/**\n * Don't need to use this util in DOM element since the white spaces will be kept as is,\n * but will need if the text is wrapped \\w React.Fragement or </>\n * @link https://sendbird.slack.com/archives/GPGHESTL3/p1681180484341369\n * Or!!! -> convert any space or tab in leading/trailing to nbsp\n * to preserve the leading & trailing white spaces\n */\nfunction getWhiteSpacePreservedText(text) {\n  var NON_BREAKING_SPACE = \"\\xA0\";\n  // Split the input string into lines\n  var lines = text.split('\\n');\n\n  // Process each line and convert leading and trailing white spaces to \"\\u00A0\"\n  var processedLines = lines.map(function (line) {\n    var _line$match, _line$match2;\n    var leadingWhitespace = ((_line$match = line.match(/^\\s*/)) === null || _line$match === void 0 ? void 0 : _line$match[0]) || '';\n    var trailingWhitespace = ((_line$match2 = line.match(/\\s*$/)) === null || _line$match2 === void 0 ? void 0 : _line$match2[0]) || '';\n    var convertedLeadingWhitespace = leadingWhitespace.replace(/ /g, NON_BREAKING_SPACE);\n    var convertedTrailingWhitespace = trailingWhitespace.replace(/ /g, NON_BREAKING_SPACE);\n    return convertedLeadingWhitespace + line.trim() + convertedTrailingWhitespace;\n  });\n\n  // Combine the processed lines into a new string with \"\\n\"\n  var result = processedLines.join('\\n');\n  return result;\n}\nexport { TOKEN_TYPES as T, USER_MENTION_PREFIX as U, getWhiteSpacePreservedText as g, tokenizeMessage as t };","map":{"version":3,"mappings":"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","names":["USER_MENTION_PREFIX","TOKEN_TYPES","string","mention","url","undetermined","getUserMentionRegex","mentionedUsers","templatePrefix_","templatePrefix","RegExp","map","u","userId","replace","join","identifyMentions","tokens","_ref","length","userMentionRegex","results","token","type","value","parts","split","part","match","matchedUser","find","user","nickname","flat","identifyUrlsAndStrings","isUrl","combineNearbyStrings","reduce","acc","lastToken","tokenizeMessage","messageText","_ref2","partialResult","partialWithMentions","partialsWithUrlsAndMentions","result","getWhiteSpacePreservedText","text","NON_BREAKING_SPACE","lines","processedLines","line","leadingWhitespace","_line$match","trailingWhitespace","_line$match2","convertedLeadingWhitespace","convertedTrailingWhitespace","trim"],"sources":["C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Message\\consts.ts","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Message\\utils\\tokens\\types.ts","C:\\Users\\이경민\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Message\\utils\\tokens\\tokenize.ts"],"sourcesContent":["export const USER_MENTION_PREFIX = '@';\n","import { User } from '@sendbird/chat';\nimport { ObjectValues } from '../../../../utils/typeHelpers/objectValues';\n\nexport const TOKEN_TYPES = {\n  string: 'string',\n  mention: 'mention',\n  url: 'url',\n  undetermined: 'undetermined',\n} as const;\n\nexport type TokenType = ObjectValues<typeof TOKEN_TYPES>;\n\nexport type StringToken = {\n  type: typeof TOKEN_TYPES.string;\n  value: string;\n};\n\nexport type MentionToken = {\n  type: TokenType;\n  value: string;\n  userId: string;\n};\n\nexport type UrlToken = {\n  type: typeof TOKEN_TYPES.url;\n  value: string;\n};\n\nexport type UndeterminedToken = {\n  type: typeof TOKEN_TYPES.undetermined;\n  value: string;\n};\n\nexport type Token = StringToken | MentionToken | UrlToken | UndeterminedToken;\n\nexport type TokenParams = {\n  messageText: string;\n  mentionedUsers?: User[];\n  templatePrefix?: string;\n};\n\nexport type IdentifyMentionsType = {\n  tokens: UndeterminedToken[];\n  mentionedUsers: User[];\n  templatePrefix: string;\n};\n","import { User } from '@sendbird/chat';\nimport { USER_MENTION_PREFIX } from '../../consts';\nimport { IdentifyMentionsType, MentionToken, Token, TOKEN_TYPES, TokenParams, UndeterminedToken } from './types';\nimport { isUrl } from '../../../../utils';\n\nexport function getUserMentionRegex(mentionedUsers: User[], templatePrefix_: string): RegExp {\n  const templatePrefix = templatePrefix_ || USER_MENTION_PREFIX;\n\n  return RegExp(`(${mentionedUsers.map(u => {\n    const userId = u.userId.replace(\n      // If user.id includes these patterns, need to convert it into an escaped one\n      /([.*+?^${}()|[\\]\\\\])/g,\n      '\\\\$1');\n      /**\n       * //{ And //} are also for escaping\n       * because curly braces `{}` are metacharacters in regular expressions used to specify repetition\n       */\n    return `${templatePrefix}\\\\{${userId}\\\\}`;\n  }).join('|')})`, 'g');\n}\n\nexport function identifyMentions({\n  tokens,\n  mentionedUsers = [],\n  templatePrefix = USER_MENTION_PREFIX,\n}: IdentifyMentionsType): (MentionToken | UndeterminedToken)[] {\n  if (!mentionedUsers?.length) {\n    return tokens;\n  }\n  const userMentionRegex = getUserMentionRegex(mentionedUsers, templatePrefix);\n  const results: (UndeterminedToken | MentionToken)[] = tokens.map((token) => {\n    // if the token is not undetermined, return it as is\n    // is kinda unnecessary with TS, but just in case\n    if (token.type !== TOKEN_TYPES.undetermined) {\n      return token;\n    }\n    const { value } = token;\n    const parts = value.split(userMentionRegex);\n\n    const tokens = parts.map((part) => {\n      if (part.match(userMentionRegex)) {\n        const matchedUser = mentionedUsers.find((user) => `@{${user?.userId}}` === part);\n        const nickname = matchedUser?.nickname || '(No name)';\n        return { value: nickname, type: TOKEN_TYPES.mention, userId: matchedUser?.userId };\n      } else {\n        return { value: part, type: TOKEN_TYPES.undetermined };\n      }\n    });\n    return tokens;\n  }).flat();\n  return results;\n}\n\nexport function identifyUrlsAndStrings(token: Token[]): Token[] {\n  const results: Token[] = token.map((token) => {\n    if (token.type !== TOKEN_TYPES.undetermined) {\n      return token;\n    }\n    const { value = '' } = token;\n    const parts = value.split(' ');\n    const tokens = parts.map((part) => {\n      if (isUrl(part)) {\n        return { value: part, type: TOKEN_TYPES.url };\n      } else {\n        return { value: part, type: TOKEN_TYPES.string };\n      }\n    });\n    return tokens;\n  }).flat();\n\n  return results;\n}\n\nexport function combineNearbyStrings(tokens: Token[]): Token[] {\n  const results: Token[] = tokens.reduce((acc, token) => {\n    const lastToken = acc[acc.length - 1];\n    if (lastToken?.type === TOKEN_TYPES.string && token.type === TOKEN_TYPES.string) {\n      lastToken.value = `${lastToken.value} ${token.value}`;\n      return acc;\n    }\n    return [...acc, token];\n  }, []);\n  return results;\n}\n\n/**\n * Converts text into set of rich tokens\n */\nexport function tokenizeMessage({\n  messageText,\n  mentionedUsers = [],\n  templatePrefix = USER_MENTION_PREFIX,\n}: TokenParams): Token[] {\n  // mention can be squeezed-in(no-space-between) with other mentions and urls\n  // if no users are mentioned, return the messageText as a single token\n  const partialResult = [{\n    type: TOKEN_TYPES.undetermined,\n    value: messageText,\n  }];\n\n  // order is important because we want to identify mentions first\n  // identifyMentions will return a token with type mention or undetermined\n  const partialWithMentions = identifyMentions({\n    tokens: partialResult,\n    mentionedUsers,\n    templatePrefix,\n  });\n  const partialsWithUrlsAndMentions = identifyUrlsAndStrings(partialWithMentions);\n  const result = combineNearbyStrings(partialsWithUrlsAndMentions);\n\n  return result;\n}\n\n/**\n * Don't need to use this util in DOM element since the white spaces will be kept as is,\n * but will need if the text is wrapped \\w React.Fragement or </>\n * @link https://sendbird.slack.com/archives/GPGHESTL3/p1681180484341369\n * Or!!! -> convert any space or tab in leading/trailing to nbsp\n * to preserve the leading & trailing white spaces\n */\nexport function getWhiteSpacePreservedText(text: string): string {\n  const NON_BREAKING_SPACE = '\\u00A0';\n  // Split the input string into lines\n  const lines = text.split('\\n');\n\n  // Process each line and convert leading and trailing white spaces to \"\\u00A0\"\n  const processedLines = lines.map((line) => {\n    const leadingWhitespace = line.match(/^\\s*/)?.[0] || '';\n    const trailingWhitespace = line.match(/\\s*$/)?.[0] || '';\n\n    const convertedLeadingWhitespace = leadingWhitespace.replace(/ /g, NON_BREAKING_SPACE);\n    const convertedTrailingWhitespace = trailingWhitespace.replace(/ /g, NON_BREAKING_SPACE);\n\n    return convertedLeadingWhitespace + line.trim() + convertedTrailingWhitespace;\n  });\n\n  // Combine the processed lines into a new string with \"\\n\"\n  const result = processedLines.join('\\n');\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}