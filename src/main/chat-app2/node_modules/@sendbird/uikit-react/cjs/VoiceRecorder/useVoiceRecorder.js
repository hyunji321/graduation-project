'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var VoiceRecorder_context = require('./context.js');
var useSendbirdStateContext = require('../useSendbirdStateContext.js');
require('../consts-297fdae1.js');
require('../withSendbird.js');
require('../_rollupPluginBabelHelpers-5fad415d.js');

// export interface UseVoiceRecorderProps extends VoiceRecorderEventHandler {
//   /**
//    * onRecordingStarted
//    * onRecordingEnded
//    */
// }
/* eslint-disable no-redeclare */
const VoiceRecorderStatus = {
  PREPARING: 'PREPARING',
  READY_TO_RECORD: 'READY_TO_RECORD',
  RECORDING: 'RECORDING',
  COMPLETED: 'COMPLETED'
};
const noop = () => {/* noop */};
const useVoiceRecorder = _ref => {
  let {
    onRecordingStarted = noop,
    onRecordingEnded = noop
  } = _ref;
  const {
    config
  } = useSendbirdStateContext();
  const {
    voiceRecord
  } = config;
  const {
    maxRecordingTime
  } = voiceRecord;
  const voiceRecorder = VoiceRecorder_context.useVoiceRecorderContext();
  const {
    isRecordable
  } = voiceRecorder;
  const [recordedFile, setRecordedFile] = React.useState(null);
  const [recordingStatus, setRecordingStatus] = React.useState(VoiceRecorderStatus.PREPARING);
  React.useEffect(() => {
    if (isRecordable && recordingStatus === VoiceRecorderStatus.PREPARING) {
      setRecordingStatus(VoiceRecorderStatus.READY_TO_RECORD);
    }
  }, [isRecordable]);
  const start = React.useCallback(() => {
    voiceRecorder === null || voiceRecorder === void 0 ? void 0 : voiceRecorder.start({
      onRecordingStarted: () => {
        setRecordingStatus(VoiceRecorderStatus.RECORDING);
        onRecordingStarted();
        startTimer();
      },
      onRecordingEnded: audioFile => {
        setRecordingStatus(VoiceRecorderStatus.COMPLETED);
        onRecordingEnded(audioFile);
        setRecordedFile(audioFile);
        stopTimer();
      }
    });
  }, [onRecordingStarted, onRecordingEnded]);
  const stop = React.useCallback(() => {
    voiceRecorder === null || voiceRecorder === void 0 ? void 0 : voiceRecorder.stop();
    stopTimer();
  }, [voiceRecorder]);
  const cancel = React.useCallback(() => {
    stop();
    setRecordedFile(null);
  }, [voiceRecorder]);

  // Timer
  const [recordingTime, setRecordingTime] = React.useState(0);
  let timer = null;
  function startTimer() {
    stopTimer();
    setRecordingTime(0);
    const interval = setInterval(() => {
      setRecordingTime(prevTime => {
        const newTime = prevTime + 100;
        if (newTime > maxRecordingTime) {
          stopTimer();
        }
        return newTime;
      });
    }, 100);
    timer = interval;
  }
  function stopTimer() {
    clearInterval(timer);
    timer = null;
  }
  React.useEffect(() => {
    if (recordingTime > maxRecordingTime) {
      stop();
    }
  }, [recordingTime, maxRecordingTime, stop]);
  return {
    start,
    stop,
    cancel,
    recordingStatus,
    recordingTime,
    recordedFile,
    recordingLimit: maxRecordingTime
  };
};

exports.VoiceRecorderStatus = VoiceRecorderStatus;
exports.useVoiceRecorder = useVoiceRecorder;
//# sourceMappingURL=useVoiceRecorder.js.map
