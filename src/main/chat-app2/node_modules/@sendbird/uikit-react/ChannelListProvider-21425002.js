import { _ as _objectSpread2 } from './_rollupPluginBabelHelpers-6bb0305c.js';
import React__default, { useEffect, useReducer, useState, useMemo, useContext } from 'react';
import { GroupChannelHandler } from '@sendbird/chat/groupChannel';
import { P as PUBSUB_TOPICS } from './topics-b2b77fb9.js';
import { u as uuidv4 } from './uuid-1adedf62.js';
import { n as noop } from './utils-4bbbca2c.js';
import { U as UserProfileProvider } from './UserProfileContext-9cfbab4d.js';
import useSendbirdStateContext from './useSendbirdStateContext.js';
import { f as filterChannelListParams, g as getChannelsWithUpsertedChannel } from './index-7eb65acf.js';

const RESET_CHANNEL_LIST = 'RESET_CHANNEL_LIST';
const CREATE_CHANNEL = 'CREATE_CHANNEL';
const USER_INVITED = 'USER_INVITED';
const LEAVE_CHANNEL_SUCCESS = 'LEAVE_CHANNEL_SUCCESS';
const SET_CURRENT_CHANNEL = 'SET_CURRENT_CHANNEL';
const FETCH_CHANNELS_START = 'FETCH_CHANNELS_START';
const FETCH_CHANNELS_SUCCESS = 'FETCH_CHANNELS_SUCCESS';
const FETCH_CHANNELS_FAILURE = 'FETCH_CHANNELS_FAILURE';
const INIT_CHANNELS_START = 'INIT_CHANNELS_START';
const INIT_CHANNELS_SUCCESS = 'INIT_CHANNELS_SUCCESS';
const INIT_CHANNELS_FAILURE = 'INIT_CHANNELS_FAILURE';
const ON_USER_JOINED = 'ON_USER_JOINED';
const ON_CHANNEL_DELETED = 'ON_CHANNEL_DELETED';
const ON_LAST_MESSAGE_UPDATED = 'ON_LAST_MESSAGE_UPDATED';
const ON_USER_LEFT = 'ON_USER_LEFT';
const ON_CHANNEL_CHANGED = 'ON_CHANNEL_CHANGED';
const ON_CHANNEL_ARCHIVED = 'ON_CHANNEL_ARCHIVED';
const ON_CHANNEL_FROZEN = 'ON_CHANNEL_FROZEN';
const ON_CHANNEL_UNFROZEN = 'ON_CHANNEL_UNFROZEN';
const ON_READ_RECEIPT_UPDATED = 'ON_READ_RECEIPT_UPDATED';
const ON_DELIVERY_RECEIPT_UPDATED = 'ON_DELIVERY_RECEIPT_UPDATED';
const CHANNEL_REPLACED_TO_TOP = 'CHANNEL_REPLACED_TO_TOP';
const CHANNEL_LIST_PARAMS_UPDATED = 'CHANNEL_LIST_PARAMS_UPDATED';

const DELIVERY_RECIPT = 'delivery_receipt';
const createEventHandler = _ref => {
  let {
    sdk,
    sdkChannelHandlerId,
    channelListDispatcher,
    logger
  } = _ref;
  const ChannelHandler = new GroupChannelHandler({
    onChannelChanged: channel => {
      logger.info('ChannelList: onChannelChanged', channel);
      channelListDispatcher({
        type: ON_CHANNEL_CHANGED,
        payload: channel
      });
    },
    onChannelDeleted: channelUrl => {
      logger.info('ChannelList: onChannelDeleted', channelUrl);
      channelListDispatcher({
        type: ON_CHANNEL_DELETED,
        payload: channelUrl
      });
    },
    onUserJoined: channel => {
      logger.info('ChannelList: onUserJoined', channel);
      if (channel !== null && channel !== void 0 && channel.lastMessage) {
        channelListDispatcher({
          type: ON_USER_JOINED,
          payload: channel
        });
      }
    },
    onUserReceivedInvitation: (channel, inviter, invitees) => {
      logger.info('ChannelList: onUserReceivedInvitation', {
        channel,
        inviter,
        invitees
      });
      const {
        currentUser
      } = sdk;
      const isInvited = invitees.find(user => (user === null || user === void 0 ? void 0 : user.userId) === (currentUser === null || currentUser === void 0 ? void 0 : currentUser.userId));
      // The newly created channel should be displayed only when there's a message
      if (isInvited && channel !== null && channel !== void 0 && channel.lastMessage) {
        channelListDispatcher({
          type: USER_INVITED,
          payload: channel
        });
      }
    },
    onUserBanned: (channel, user) => {
      const {
        currentUser
      } = sdk;
      logger.info('Channel: onUserBanned', channel);
      if (user.userId === currentUser.userId) {
        channelListDispatcher({
          type: ON_USER_LEFT,
          payload: {
            channel,
            isMe: true
          }
        });
      } else {
        channelListDispatcher({
          type: ON_USER_LEFT,
          payload: {
            channel,
            isMe: false
          }
        });
      }
    },
    onUserLeft: (channel, leftUser) => {
      const {
        currentUser
      } = sdk;
      const isMe = currentUser.userId === leftUser.userId;
      logger.info('ChannelList: onUserLeft', channel);
      channelListDispatcher({
        type: ON_USER_LEFT,
        payload: {
          channel,
          isMe
        }
      });
    },
    onReadStatus: channel => {
      logger.info('ChannelList: onReadStatus', channel);
      channelListDispatcher({
        type: ON_READ_RECEIPT_UPDATED,
        payload: channel
      });
    },
    onDeliveryReceiptUpdated: channel => {
      logger.info('ChannelList: onDeliveryReceiptUpdated', channel);
      if (channel !== null && channel !== void 0 && channel.lastMessage) {
        channelListDispatcher({
          type: ON_DELIVERY_RECEIPT_UPDATED,
          payload: channel
        });
      }
    },
    onMessageUpdated: (channel, message) => {
      if (channel !== null && channel !== void 0 && channel.lastMessage.isEqual(message)) {
        logger.info('ChannelList: onMessageUpdated', channel);
        channelListDispatcher({
          type: ON_LAST_MESSAGE_UPDATED,
          payload: channel
        });
      }
    },
    onChannelHidden: channel => {
      logger.info('ChannelList: onChannelHidden', channel);
      channelListDispatcher({
        type: ON_CHANNEL_ARCHIVED,
        payload: channel
      });
    },
    onChannelFrozen: channel => {
      logger.info('ChannelList: onChannelFrozen', channel);
      channelListDispatcher({
        type: ON_CHANNEL_FROZEN,
        payload: channel
      });
    },
    onChannelUnfrozen: channel => {
      logger.info('ChannelList: onChannelUnfrozen', channel);
      channelListDispatcher({
        type: ON_CHANNEL_UNFROZEN,
        payload: channel
      });
    }
  });
  logger.info('ChannelList: Added channelHandler');
  sdk.groupChannel.addGroupChannelHandler(sdkChannelHandlerId, ChannelHandler);
};
const createChannelListQuery = _ref2 => {
  let {
    sdk,
    userFilledChannelListQuery = {}
  } = _ref2;
  const param = {};
  param.includeEmpty = false;
  param.limit = 20; // The value of pagination limit could be set up to 100.
  param.order = 'latest_last_message'; // 'chronological', 'latest_last_message', 'channel_name_alphabetical', and 'metadata_value_alphabetical'

  if (userFilledChannelListQuery) {
    Object.keys(userFilledChannelListQuery).forEach(key => {
      param[key] = userFilledChannelListQuery[key];
    });
  }
  const channelListQuery = sdk.groupChannel.createMyGroupChannelListQuery(param);
  return channelListQuery;
};

/**
 * Setup event listener
 * create channel source query
 * addloading screen
 */
function setupChannelList(_ref3) {
  let {
    sdk,
    sdkChannelHandlerId,
    channelListDispatcher,
    setChannelSource,
    onChannelSelect,
    userFilledChannelListQuery,
    logger,
    sortChannelList,
    disableAutoSelect,
    markAsDeliveredScheduler,
    disableMarkAsDelivered
  } = _ref3;
  if (sdk !== null && sdk !== void 0 && sdk.groupChannel) {
    createEventHandler({
      sdk,
      channelListDispatcher,
      sdkChannelHandlerId,
      logger
    });
  } else {
    logger.warning('ChannelList - createEventHandler: sdk or sdk.ChannelHandler does not exist', sdk);
  }
  logger.info('ChannelList - creating query', {
    userFilledChannelListQuery
  });
  const channelListQuery = createChannelListQuery({
    sdk,
    userFilledChannelListQuery
  });
  logger.info('ChannelList - created query', channelListQuery);
  setChannelSource(channelListQuery);
  channelListDispatcher({
    type: INIT_CHANNELS_START
  });
  if (userFilledChannelListQuery) {
    logger.info('ChannelList - setting up channelListQuery', channelListQuery);
    channelListDispatcher({
      type: CHANNEL_LIST_PARAMS_UPDATED,
      payload: {
        channelListQuery,
        currentUserId: sdk && sdk.currentUser && sdk.currentUser.userId
      }
    });
  }
  logger.info('ChannelList - fetching channels');
  if (channelListQuery.hasNext) {
    channelListQuery.next().then(channelList => {
      var _sdk$appInfo, _sdk$appInfo$premiumF;
      logger.info('ChannelList - fetched channels', channelList);
      // select first channel
      logger.info('ChannelList - highlight channel', channelList[0]);
      let sortedChannelList = channelList;
      if (sortChannelList && typeof sortChannelList === 'function') {
        sortedChannelList = sortChannelList(channelList);
        logger.info('ChannelList - channel list sorted', sortedChannelList);
      }
      if (!disableAutoSelect) {
        onChannelSelect(sortedChannelList[0]);
      }
      channelListDispatcher({
        type: INIT_CHANNELS_SUCCESS,
        payload: {
          channelList: sortedChannelList,
          disableAutoSelect
        }
      });
      const canSetMarkAsDelivered = sdk === null || sdk === void 0 ? void 0 : (_sdk$appInfo = sdk.appInfo) === null || _sdk$appInfo === void 0 ? void 0 : (_sdk$appInfo$premiumF = _sdk$appInfo.premiumFeatureList) === null || _sdk$appInfo$premiumF === void 0 ? void 0 : _sdk$appInfo$premiumF.find(feature => feature === DELIVERY_RECIPT);
      if (canSetMarkAsDelivered && !disableMarkAsDelivered) {
        sortedChannelList.forEach(channel => {
          markAsDeliveredScheduler.push(channel);
        });
      }
    }).catch(err => {
      if (err) {
        logger.error('ChannelList - couldnt fetch channels', err);
        channelListDispatcher({
          type: INIT_CHANNELS_FAILURE
        });
      }
    });
  } else {
    logger.info('ChannelList - there are no more channels');
  }
}
const pubSubHandleRemover = subscriber => {
  subscriber.forEach(s => {
    try {
      s.remove();
    } catch (_unused) {
      //
    }
  });
};
const pubSubHandler = (pubSub, channelListDispatcher) => {
  const subscriber = new Map();
  if (!pubSub) return subscriber;
  subscriber.set(PUBSUB_TOPICS.CREATE_CHANNEL, pubSub.subscribe(PUBSUB_TOPICS.CREATE_CHANNEL, msg => {
    const {
      channel
    } = msg;
    channelListDispatcher({
      type: 'CREATE_CHANNEL',
      payload: channel
    });
  }));
  subscriber.set(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, msg => {
    var _updatedChannel$lastM;
    const {
      channel,
      message
    } = msg;
    const updatedChannel = channel;
    if ((updatedChannel === null || updatedChannel === void 0 ? void 0 : (_updatedChannel$lastM = updatedChannel.lastMessage) === null || _updatedChannel$lastM === void 0 ? void 0 : _updatedChannel$lastM.messageId) === message.messageId) {
      updatedChannel.lastMessage = message;
    }
    if (channel) {
      channelListDispatcher({
        type: ON_LAST_MESSAGE_UPDATED,
        payload: updatedChannel
      });
    }
  }));
  subscriber.set(PUBSUB_TOPICS.LEAVE_CHANNEL, pubSub.subscribe(PUBSUB_TOPICS.LEAVE_CHANNEL, msg => {
    const {
      channel
    } = msg;
    channelListDispatcher({
      type: LEAVE_CHANNEL_SUCCESS,
      payload: channel === null || channel === void 0 ? void 0 : channel.url
    });
  }));
  subscriber.set(PUBSUB_TOPICS.SEND_MESSAGE_START, pubSub.subscribe(PUBSUB_TOPICS.SEND_MESSAGE_START, msg => {
    const {
      channel
    } = msg;
    channelListDispatcher({
      type: CHANNEL_REPLACED_TO_TOP,
      payload: channel
    });
  }));
  return subscriber;
};

var channelListInitialState = {
  // we might not need this initialized state -> should remove
  initialized: false,
  loading: true,
  allChannels: [],
  currentChannel: null,
  channelListQuery: null,
  currentUserId: '',
  disableAutoSelect: false
};

function reducer(state, action) {
  switch (action.type) {
    case INIT_CHANNELS_START:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        loading: true
      });
    case RESET_CHANNEL_LIST:
      return channelListInitialState;
    case INIT_CHANNELS_SUCCESS:
      {
        const {
          channelList,
          disableAutoSelect
        } = action.payload;
        return _objectSpread2(_objectSpread2({}, state), {}, {
          initialized: true,
          loading: false,
          allChannels: channelList,
          disableAutoSelect,
          currentChannel: !disableAutoSelect && channelList && channelList.length && channelList.length > 0 ? channelList[0] : null
        });
      }
    case FETCH_CHANNELS_SUCCESS:
      {
        const currentChannels = state.allChannels.map(c => c.url);
        const filteredChannels = action.payload.filter(_ref => {
          let {
            url
          } = _ref;
          return !currentChannels.find(c => c === url);
        });
        return _objectSpread2(_objectSpread2({}, state), {}, {
          allChannels: [...state.allChannels, ...filteredChannels]
        });
      }
    case USER_INVITED:
      {
        const channel = action.payload;
        if (state.channelListQuery) {
          if (filterChannelListParams(state.channelListQuery, channel, state.currentUserId)) {
            return _objectSpread2(_objectSpread2({}, state), {}, {
              allChannels: getChannelsWithUpsertedChannel(state.allChannels, channel)
            });
          }
          return _objectSpread2(_objectSpread2({}, state), {}, {
            currentChannel: channel
          });
        }
        return _objectSpread2(_objectSpread2({}, state), {}, {
          allChannels: [channel, ...state.allChannels.filter(ch => ch.url !== (channel === null || channel === void 0 ? void 0 : channel.url))]
        });
      }
    case CREATE_CHANNEL:
      {
        const channel = action.payload;
        if (state.channelListQuery) {
          if (filterChannelListParams(state.channelListQuery, channel, state.currentUserId)) {
            return _objectSpread2(_objectSpread2({}, state), {}, {
              allChannels: getChannelsWithUpsertedChannel(state.allChannels, channel)
            });
          }
          return _objectSpread2(_objectSpread2({}, state), {}, {
            currentChannel: channel
          });
        }
        return _objectSpread2(_objectSpread2({}, state), {}, {
          allChannels: [channel, ...state.allChannels.filter(ch => ch.url !== (channel === null || channel === void 0 ? void 0 : channel.url))],
          currentChannel: channel
        });
      }
    case ON_CHANNEL_ARCHIVED:
      {
        var _state$currentChannel;
        const channel = action.payload;
        if (state.channelListQuery) {
          if (filterChannelListParams(state.channelListQuery, channel, state.currentUserId)) {
            return _objectSpread2(_objectSpread2({}, state), {}, {
              allChannels: getChannelsWithUpsertedChannel(state.allChannels, channel)
            });
            // TODO: Check if we have to set current channel
          }
        }

        const nextChannel = (channel === null || channel === void 0 ? void 0 : channel.url) === ((_state$currentChannel = state.currentChannel) === null || _state$currentChannel === void 0 ? void 0 : _state$currentChannel.url) ? state.allChannels[state.allChannels[0].url === (channel === null || channel === void 0 ? void 0 : channel.url) ? 1 : 0] : state.currentChannel;
        return _objectSpread2(_objectSpread2({}, state), {}, {
          allChannels: state.allChannels.filter(_ref2 => {
            let {
              url
            } = _ref2;
            return url !== (channel === null || channel === void 0 ? void 0 : channel.url);
          }),
          currentChannel: state.disableAutoSelect ? null : nextChannel
        });
      }
    case LEAVE_CHANNEL_SUCCESS:
    case ON_CHANNEL_DELETED:
      {
        var _state$currentChannel2;
        const channelUrl = action.payload;
        return _objectSpread2(_objectSpread2({}, state), {}, {
          currentChannel: channelUrl === ((_state$currentChannel2 = state.currentChannel) === null || _state$currentChannel2 === void 0 ? void 0 : _state$currentChannel2.url) ? state.allChannels[0] : state.currentChannel,
          allChannels: state.allChannels.filter(_ref3 => {
            let {
              url
            } = _ref3;
            return url !== channelUrl;
          })
        });
      }
    case ON_USER_LEFT:
      {
        var _state$currentChannel5;
        const {
          channel,
          isMe
        } = action.payload;
        if (state.channelListQuery) {
          var _state$currentChannel4;
          if (filterChannelListParams(state.channelListQuery, channel, state.currentUserId)) {
            var _state$currentChannel3;
            const filteredChannels = getChannelsWithUpsertedChannel(state.allChannels, channel);
            const nextChannel = isMe && (channel === null || channel === void 0 ? void 0 : channel.url) === ((_state$currentChannel3 = state.currentChannel) === null || _state$currentChannel3 === void 0 ? void 0 : _state$currentChannel3.url) ? filteredChannels[0] : state.currentChannel;
            return _objectSpread2(_objectSpread2({}, state), {}, {
              currentChannel: state.disableAutoSelect ? null : nextChannel,
              allChannels: filteredChannels
            });
          }
          const nextChannel = (channel === null || channel === void 0 ? void 0 : channel.url) === ((_state$currentChannel4 = state.currentChannel) === null || _state$currentChannel4 === void 0 ? void 0 : _state$currentChannel4.url) ? state.allChannels[0] : state.currentChannel;
          return _objectSpread2(_objectSpread2({}, state), {}, {
            currentChannel: state.disableAutoSelect ? null : nextChannel,
            allChannels: state.allChannels.filter(_ref4 => {
              let {
                url
              } = _ref4;
              return url !== (channel === null || channel === void 0 ? void 0 : channel.url);
            })
          });
        }
        const filteredChannels = state.allChannels.filter(c => !(c.url === (channel === null || channel === void 0 ? void 0 : channel.url) && isMe));
        const nextChannel = isMe && (channel === null || channel === void 0 ? void 0 : channel.url) === ((_state$currentChannel5 = state.currentChannel) === null || _state$currentChannel5 === void 0 ? void 0 : _state$currentChannel5.url) ? filteredChannels[0] : state.currentChannel;
        return _objectSpread2(_objectSpread2({}, state), {}, {
          currentChannel: state.disableAutoSelect ? null : nextChannel,
          allChannels: filteredChannels
        });
      }
    case ON_USER_JOINED:
    case ON_CHANNEL_CHANGED:
    case ON_READ_RECEIPT_UPDATED:
    case ON_DELIVERY_RECEIPT_UPDATED:
      {
        const {
          allChannels = []
        } = state;
        const channel = action.payload;
        const {
          unreadMessageCount
        } = channel;
        if (!(channel !== null && channel !== void 0 && channel.lastMessage)) return state;
        if (state.channelListQuery) {
          var _state$currentChannel6;
          if (filterChannelListParams(state.channelListQuery, channel, state.currentUserId)) {
            return _objectSpread2(_objectSpread2({}, state), {}, {
              allChannels: getChannelsWithUpsertedChannel(allChannels, channel)
            });
          }
          const nextChannel = (channel === null || channel === void 0 ? void 0 : channel.url) === ((_state$currentChannel6 = state.currentChannel) === null || _state$currentChannel6 === void 0 ? void 0 : _state$currentChannel6.url) ? state.allChannels[state.allChannels[0].url === (channel === null || channel === void 0 ? void 0 : channel.url) ? 1 : 0]
          // if coming channel is first of channel list, current channel will be the next one
          : state.currentChannel;
          return _objectSpread2(_objectSpread2({}, state), {}, {
            currentChannel: state.disableAutoSelect ? null : nextChannel,
            allChannels: state.allChannels.filter(_ref5 => {
              let {
                url
              } = _ref5;
              return url !== (channel === null || channel === void 0 ? void 0 : channel.url);
            })
          });
        }
        // if its only an unread message count change, dont push to top
        if (unreadMessageCount === 0) {
          const currentChannel = allChannels.find(_ref6 => {
            let {
              url
            } = _ref6;
            return url === (channel === null || channel === void 0 ? void 0 : channel.url);
          });
          const currentUnreadCount = currentChannel && currentChannel.unreadMessageCount;
          if (currentUnreadCount === 0) {
            return _objectSpread2(_objectSpread2({}, state), {}, {
              allChannels: state.allChannels.map(ch => ch.url === (channel === null || channel === void 0 ? void 0 : channel.url) ? channel : ch)
            });
          }
        }
        return _objectSpread2(_objectSpread2({}, state), {}, {
          allChannels: [channel, ...state.allChannels.filter(_ref7 => {
            let {
              url
            } = _ref7;
            return url !== action.payload.url;
          })]
        });
      }
    case SET_CURRENT_CHANNEL:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        currentChannel: action.payload
      });
    case ON_LAST_MESSAGE_UPDATED:
      {
        return _objectSpread2(_objectSpread2({}, state), {}, {
          allChannels: state.allChannels.map(channel => (channel === null || channel === void 0 ? void 0 : channel.url) === action.payload.url ? action.payload : channel)
        });
      }
    case ON_CHANNEL_FROZEN:
      {
        const channel = action.payload;
        if (state.channelListQuery) {
          var _state$currentChannel7;
          if (filterChannelListParams(state.channelListQuery, channel, state.currentUserId)) {
            return _objectSpread2(_objectSpread2({}, state), {}, {
              allChannels: getChannelsWithUpsertedChannel(state.allChannels, channel)
            });
          }
          const nextChannel = (channel === null || channel === void 0 ? void 0 : channel.url) === ((_state$currentChannel7 = state.currentChannel) === null || _state$currentChannel7 === void 0 ? void 0 : _state$currentChannel7.url) ? state.allChannels[state.allChannels[0].url === (channel === null || channel === void 0 ? void 0 : channel.url) ? 1 : 0]
          // if coming channel is first of channel list, current channel will be the next one
          : state.currentChannel;
          return _objectSpread2(_objectSpread2({}, state), {}, {
            allChannels: state.allChannels.filter(_ref8 => {
              let {
                url
              } = _ref8;
              return url !== (channel === null || channel === void 0 ? void 0 : channel.url);
            }),
            currentChannel: state.disableAutoSelect ? null : nextChannel
          });
        }
        return _objectSpread2(_objectSpread2({}, state), {}, {
          allChannels: state.allChannels.map(ch => {
            if (ch.url === (channel === null || channel === void 0 ? void 0 : channel.url)) {
              // eslint-disable-next-line no-param-reassign
              ch.isFrozen = true;
              return ch;
            }
            return ch;
          })
        });
      }
    case ON_CHANNEL_UNFROZEN:
      {
        const channel = action.payload;
        if (state.channelListQuery) {
          var _state$currentChannel8;
          if (filterChannelListParams(state.channelListQuery, channel, state.currentUserId)) {
            return _objectSpread2(_objectSpread2({}, state), {}, {
              allChannels: getChannelsWithUpsertedChannel(state.allChannels, channel)
            });
          }
          const nextChannel = (channel === null || channel === void 0 ? void 0 : channel.url) === ((_state$currentChannel8 = state.currentChannel) === null || _state$currentChannel8 === void 0 ? void 0 : _state$currentChannel8.url) ? state.allChannels[state.allChannels[0].url === (channel === null || channel === void 0 ? void 0 : channel.url) ? 1 : 0]
          // if coming channel is first of channel list, current channel will be the next one
          : state.currentChannel;
          return _objectSpread2(_objectSpread2({}, state), {}, {
            allChannels: state.allChannels.filter(_ref9 => {
              let {
                url
              } = _ref9;
              return url !== (channel === null || channel === void 0 ? void 0 : channel.url);
            }),
            currentChannel: state.disableAutoSelect ? null : nextChannel
          });
        }
        return _objectSpread2(_objectSpread2({}, state), {}, {
          allChannels: state.allChannels.map(ch => {
            if (ch.url === (channel === null || channel === void 0 ? void 0 : channel.url)) {
              // eslint-disable-next-line no-param-reassign
              ch.isFrozen = false;
              return ch;
            }
            return ch;
          })
        });
      }
    case CHANNEL_REPLACED_TO_TOP:
      {
        if (state.channelListQuery) {
          if (filterChannelListParams(state.channelListQuery, action.payload, state.currentUserId)) {
            return _objectSpread2(_objectSpread2({}, state), {}, {
              allChannels: [action.payload, ...state.allChannels.filter(channel => (channel === null || channel === void 0 ? void 0 : channel.url) !== action.payload.url)]
            });
          }
          return state;
        }
        return _objectSpread2(_objectSpread2({}, state), {}, {
          allChannels: [action.payload, ...state.allChannels.filter(channel => (channel === null || channel === void 0 ? void 0 : channel.url) !== action.payload.url)]
        });
      }
    case CHANNEL_LIST_PARAMS_UPDATED:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        currentUserId: action.payload.currentUserId,
        channelListQuery: action.payload.channelListQuery
      });
    default:
      return state;
  }
}

function useActiveChannelUrl(_ref, _ref2) {
  let {
    activeChannelUrl,
    channels,
    sdk
  } = _ref;
  let {
    logger,
    channelListDispatcher
  } = _ref2;
  return useEffect(() => {
    if (activeChannelUrl) {
      logger.info('ChannelListProvider: looking for active channel', {
        activeChannelUrl
      });
      const activeChannel = channels === null || channels === void 0 ? void 0 : channels.find(channel => channel.url === activeChannelUrl);
      if (activeChannel) {
        channelListDispatcher({
          type: SET_CURRENT_CHANNEL,
          payload: activeChannel
        });
      } else {
        var _sdk$groupChannel;
        logger.info('ChannelListProvider: searching backend for active channel', {
          activeChannelUrl
        });
        sdk === null || sdk === void 0 ? void 0 : (_sdk$groupChannel = sdk.groupChannel) === null || _sdk$groupChannel === void 0 ? void 0 : _sdk$groupChannel.getChannel(activeChannelUrl).then(channel => {
          channelListDispatcher({
            type: FETCH_CHANNELS_SUCCESS,
            payload: [channel]
          });
          channelListDispatcher({
            type: SET_CURRENT_CHANNEL,
            payload: channel
          });
        }).catch(() => {
          logger.warning('ChannelListProvider: Active channel not found');
        });
      }
    }
  }, [activeChannelUrl]);
}

const ChannelListContext = /*#__PURE__*/React__default.createContext({
  disableUserProfile: true,
  allowProfileEdit: true,
  onBeforeCreateChannel: null,
  onThemeChange: null,
  onProfileEditSuccess: null,
  onChannelSelect: null,
  queries: {},
  className: null,
  initialized: false,
  loading: false,
  allChannels: [],
  currentChannel: null,
  channelListQuery: {},
  currentUserId: null,
  channelListDispatcher: null,
  channelSource: null,
  typingChannels: []
});
const ChannelListProvider = props => {
  var _sdk$currentUser;
  // destruct props
  const {
    children,
    className,
    disableUserProfile,
    allowProfileEdit,
    queries,
    onProfileEditSuccess,
    onThemeChange,
    onBeforeCreateChannel,
    sortChannelList,
    overrideInviteUser,
    activeChannelUrl,
    isTypingIndicatorEnabled = null,
    isMessageReceiptStatusEnabled = null
  } = props;
  // disable autoselect, if activeChannelUrl is provided
  // useActiveChannelUrl should be executed when activeChannelUrl is present
  const disableAutoSelect = (props === null || props === void 0 ? void 0 : props.disableAutoSelect) || !!activeChannelUrl;
  const onChannelSelect = (props === null || props === void 0 ? void 0 : props.onChannelSelect) || noop;
  // fetch store from <SendbirdProvider />
  const globalStore = useSendbirdStateContext();
  const {
    config,
    stores
  } = globalStore;
  const {
    sdkStore
  } = stores;
  const {
    pubSub,
    logger,
    onUserProfileMessage
  } = config;
  const {
    markAsDeliveredScheduler,
    disableMarkAsDelivered = false,
    isTypingIndicatorEnabledOnChannelList = false,
    isMessageReceiptStatusEnabledOnChannelList = false
  } = config;
  const sdk = sdkStore === null || sdkStore === void 0 ? void 0 : sdkStore.sdk;

  // derive some variables
  // enable if it is true atleast once(both are flase by default)
  const userDefinedDisableUserProfile = disableUserProfile || (config === null || config === void 0 ? void 0 : config.disableUserProfile);
  const userDefinedRenderProfile = config === null || config === void 0 ? void 0 : config.renderUserProfile;
  const enableEditProfile = allowProfileEdit || (config === null || config === void 0 ? void 0 : config.allowProfileEdit);
  const userFilledChannelListQuery = queries === null || queries === void 0 ? void 0 : queries.channelListQuery;
  const userFilledApplicationUserListQuery = queries === null || queries === void 0 ? void 0 : queries.applicationUserListQuery;
  const sdkIntialized = sdkStore === null || sdkStore === void 0 ? void 0 : sdkStore.initialized;
  const [channelListStore, channelListDispatcher] = useReducer(reducer, channelListInitialState);
  const {
    currentChannel
  } = channelListStore;
  const [channelSource, setChannelSource] = useState(null);
  const [typingChannels, setTypingChannels] = useState([]);
  useEffect(() => {
    const subscriber = pubSubHandler(pubSub, channelListDispatcher);
    return () => {
      pubSubHandleRemover(subscriber);
    };
  }, [sdkIntialized]);
  useEffect(() => {
    const sdkChannelHandlerId = uuidv4();
    if (sdkIntialized) {
      logger.info('ChannelList: Setup channelHandlers');
      setupChannelList({
        sdk,
        sdkChannelHandlerId,
        channelListDispatcher,
        setChannelSource,
        onChannelSelect,
        userFilledChannelListQuery,
        logger,
        sortChannelList,
        disableAutoSelect,
        markAsDeliveredScheduler,
        disableMarkAsDelivered
      });
    } else {
      var _sdk$groupChannel;
      logger.info('ChannelList: Removing channelHandlers');
      // remove previous channelHandlers
      if (sdk !== null && sdk !== void 0 && (_sdk$groupChannel = sdk.groupChannel) !== null && _sdk$groupChannel !== void 0 && _sdk$groupChannel.removeGroupChannelHandler) {
        sdk.groupChannel.removeGroupChannelHandler(sdkChannelHandlerId);
      }
      // remove channelSource
      setChannelSource(null);
      // cleanup
      channelListDispatcher({
        type: RESET_CHANNEL_LIST,
        payload: null
      });
    }
    return () => {
      var _sdk$groupChannel2;
      logger.info('ChannelList: Removing channelHandlers');
      if (sdk !== null && sdk !== void 0 && (_sdk$groupChannel2 = sdk.groupChannel) !== null && _sdk$groupChannel2 !== void 0 && _sdk$groupChannel2.removeGroupChannelHandler) {
        var _sdk$groupChannel3;
        sdk === null || sdk === void 0 ? void 0 : (_sdk$groupChannel3 = sdk.groupChannel) === null || _sdk$groupChannel3 === void 0 ? void 0 : _sdk$groupChannel3.removeGroupChannelHandler(sdkChannelHandlerId);
      }
    };
  }, [sdkIntialized, userFilledChannelListQuery, sortChannelList]);
  useEffect(() => {
    var _sdk$groupChannel4;
    let typingHandlerId = '';
    if (sdk !== null && sdk !== void 0 && (_sdk$groupChannel4 = sdk.groupChannel) !== null && _sdk$groupChannel4 !== void 0 && _sdk$groupChannel4.addGroupChannelHandler) {
      var _sdk$groupChannel5;
      typingHandlerId = uuidv4();
      const handler = new GroupChannelHandler({
        onTypingStatusUpdated: channel => {
          var _channel$getTypingUse;
          const typingMemberCount = channel === null || channel === void 0 ? void 0 : (_channel$getTypingUse = channel.getTypingUsers()) === null || _channel$getTypingUse === void 0 ? void 0 : _channel$getTypingUse.length;
          const channelList = typingChannels.filter(ch => ch.url !== channel.url);
          if (typingMemberCount > 0) {
            setTypingChannels([...channelList, channel]);
          } else {
            setTypingChannels(channelList);
          }
        },
        onUnreadMemberStatusUpdated(channel) {
          channelListDispatcher({
            type: ON_LAST_MESSAGE_UPDATED,
            payload: channel
          });
        },
        onUndeliveredMemberStatusUpdated(channel) {
          channelListDispatcher({
            type: ON_LAST_MESSAGE_UPDATED,
            payload: channel
          });
        },
        onMessageUpdated(channel) {
          channelListDispatcher({
            type: ON_LAST_MESSAGE_UPDATED,
            payload: channel
          });
          sdk.groupChannel.getChannelWithoutCache(channel.url).then(ch => {
            channelListDispatcher({
              type: ON_LAST_MESSAGE_UPDATED,
              payload: ch
            });
          });
        },
        onMentionReceived(channel) {
          channelListDispatcher({
            type: ON_LAST_MESSAGE_UPDATED,
            payload: channel
          });
          sdk.groupChannel.getChannelWithoutCache(channel.url).then(ch => {
            channelListDispatcher({
              type: ON_LAST_MESSAGE_UPDATED,
              payload: ch
            });
          });
        }
      });
      sdk === null || sdk === void 0 ? void 0 : (_sdk$groupChannel5 = sdk.groupChannel) === null || _sdk$groupChannel5 === void 0 ? void 0 : _sdk$groupChannel5.addGroupChannelHandler(typingHandlerId, handler);
    }
    return () => {
      var _sdk$groupChannel6;
      if (sdk !== null && sdk !== void 0 && (_sdk$groupChannel6 = sdk.groupChannel) !== null && _sdk$groupChannel6 !== void 0 && _sdk$groupChannel6.removeGroupChannelHandler && typingHandlerId !== '') {
        sdk.groupChannel.removeGroupChannelHandler(typingHandlerId);
      }
    };
  }, [sdk === null || sdk === void 0 ? void 0 : (_sdk$currentUser = sdk.currentUser) === null || _sdk$currentUser === void 0 ? void 0 : _sdk$currentUser.userId]);
  const queries_ = useMemo(() => {
    return {
      applicationUserListQuery: userFilledApplicationUserListQuery,
      channelListQuery: userFilledChannelListQuery
    };
  }, [userFilledApplicationUserListQuery, userFilledChannelListQuery]);
  const {
    allChannels
  } = channelListStore;
  const sortedChannels = sortChannelList && typeof sortChannelList === 'function' ? sortChannelList(allChannels) : allChannels;
  if (sortedChannels.length !== allChannels.length) {
    const warning = `ChannelList: You have removed/added extra channels on sortChannelList
      this could cause unexpected problems`;
    // eslint-disable-next-line no-console
    console.warn(warning, {
      before: allChannels,
      after: sortedChannels
    });
    logger.warning(warning, {
      before: allChannels,
      after: sortedChannels
    });
  }

  // Set current channel (by on_channel_selected event)
  useEffect(() => {
    if (!sdk || !sdk.groupChannel || !currentChannel || !(currentChannel !== null && currentChannel !== void 0 && currentChannel.url)) {
      return;
    }
    sdk.groupChannel.getChannel(currentChannel.url).then(groupChannel => {
      if (groupChannel) {
        onChannelSelect(groupChannel);
      } else {
        onChannelSelect(null);
      }
    });
  }, [currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url]);

  // Set active channel (by url)
  useActiveChannelUrl({
    activeChannelUrl,
    channels: sortedChannels,
    sdk
  }, {
    logger,
    channelListDispatcher
  });
  return /*#__PURE__*/React__default.createElement(ChannelListContext.Provider, {
    value: _objectSpread2(_objectSpread2({
      className,
      disableUserProfile,
      queries: queries_,
      onProfileEditSuccess,
      onThemeChange,
      onBeforeCreateChannel,
      overrideInviteUser,
      onChannelSelect,
      sortChannelList,
      allowProfileEdit: enableEditProfile,
      channelListDispatcher,
      channelSource
    }, channelListStore), {}, {
      allChannels: sortedChannels,
      typingChannels,
      isTypingIndicatorEnabled: isTypingIndicatorEnabled !== null ? isTypingIndicatorEnabled : isTypingIndicatorEnabledOnChannelList,
      isMessageReceiptStatusEnabled: isMessageReceiptStatusEnabled !== null ? isMessageReceiptStatusEnabled : isMessageReceiptStatusEnabledOnChannelList
    })
  }, /*#__PURE__*/React__default.createElement(UserProfileProvider, {
    disableUserProfile: userDefinedDisableUserProfile,
    renderUserProfile: userDefinedRenderProfile,
    onUserProfileMessage: onUserProfileMessage
  }, /*#__PURE__*/React__default.createElement("div", {
    className: `sendbird-channel-list ${className}`
  }, children)));
};
function useChannelListContext() {
  const context = useContext(ChannelListContext);
  return context;
}

export { ChannelListProvider as C, FETCH_CHANNELS_START as F, LEAVE_CHANNEL_SUCCESS as L, SET_CURRENT_CHANNEL as S, FETCH_CHANNELS_SUCCESS as a, FETCH_CHANNELS_FAILURE as b, useChannelListContext as u };
//# sourceMappingURL=ChannelListProvider-21425002.js.map
