{"version":3,"file":"tokenize-c40f2b57.js","sources":["../src/modules/Message/consts.ts","../src/modules/Message/utils/tokens/types.ts","../src/modules/Message/utils/tokens/tokenize.ts"],"sourcesContent":["export const USER_MENTION_PREFIX = '@';\n","import { User } from '@sendbird/chat';\nimport { ObjectValues } from '../../../../utils/typeHelpers/objectValues';\n\nexport const TOKEN_TYPES = {\n  string: 'string',\n  mention: 'mention',\n  url: 'url',\n  undetermined: 'undetermined',\n} as const;\n\nexport type TokenType = ObjectValues<typeof TOKEN_TYPES>;\n\nexport type StringToken = {\n  type: typeof TOKEN_TYPES.string;\n  value: string;\n};\n\nexport type MentionToken = {\n  type: TokenType;\n  value: string;\n  userId: string;\n};\n\nexport type UrlToken = {\n  type: typeof TOKEN_TYPES.url;\n  value: string;\n};\n\nexport type UndeterminedToken = {\n  type: typeof TOKEN_TYPES.undetermined;\n  value: string;\n};\n\nexport type Token = StringToken | MentionToken | UrlToken | UndeterminedToken;\n\nexport type TokenParams = {\n  messageText: string;\n  mentionedUsers?: User[];\n  templatePrefix?: string;\n};\n\nexport type IdentifyMentionsType = {\n  tokens: UndeterminedToken[];\n  mentionedUsers: User[];\n  templatePrefix: string;\n};\n","import { User } from '@sendbird/chat';\nimport { USER_MENTION_PREFIX } from '../../consts';\nimport { IdentifyMentionsType, MentionToken, Token, TOKEN_TYPES, TokenParams, UndeterminedToken } from './types';\nimport { isUrl } from '../../../../utils';\n\nexport function getUserMentionRegex(mentionedUsers: User[], templatePrefix_: string): RegExp {\n  const templatePrefix = templatePrefix_ || USER_MENTION_PREFIX;\n\n  return RegExp(`(${mentionedUsers.map(u => {\n    const userId = u.userId.replace(\n      // If user.id includes these patterns, need to convert it into an escaped one\n      /([.*+?^${}()|[\\]\\\\])/g,\n      '\\\\$1');\n      /**\n       * //{ And //} are also for escaping\n       * because curly braces `{}` are metacharacters in regular expressions used to specify repetition\n       */\n    return `${templatePrefix}\\\\{${userId}\\\\}`;\n  }).join('|')})`, 'g');\n}\n\nexport function identifyMentions({\n  tokens,\n  mentionedUsers = [],\n  templatePrefix = USER_MENTION_PREFIX,\n}: IdentifyMentionsType): (MentionToken | UndeterminedToken)[] {\n  if (!mentionedUsers?.length) {\n    return tokens;\n  }\n  const userMentionRegex = getUserMentionRegex(mentionedUsers, templatePrefix);\n  const results: (UndeterminedToken | MentionToken)[] = tokens.map((token) => {\n    // if the token is not undetermined, return it as is\n    // is kinda unnecessary with TS, but just in case\n    if (token.type !== TOKEN_TYPES.undetermined) {\n      return token;\n    }\n    const { value } = token;\n    const parts = value.split(userMentionRegex);\n\n    const tokens = parts.map((part) => {\n      if (part.match(userMentionRegex)) {\n        const matchedUser = mentionedUsers.find((user) => `@{${user?.userId}}` === part);\n        const nickname = matchedUser?.nickname || '(No name)';\n        return { value: nickname, type: TOKEN_TYPES.mention, userId: matchedUser?.userId };\n      } else {\n        return { value: part, type: TOKEN_TYPES.undetermined };\n      }\n    });\n    return tokens;\n  }).flat();\n  return results;\n}\n\nexport function identifyUrlsAndStrings(token: Token[]): Token[] {\n  const results: Token[] = token.map((token) => {\n    if (token.type !== TOKEN_TYPES.undetermined) {\n      return token;\n    }\n    const { value = '' } = token;\n    const parts = value.split(' ');\n    const tokens = parts.map((part) => {\n      if (isUrl(part)) {\n        return { value: part, type: TOKEN_TYPES.url };\n      } else {\n        return { value: part, type: TOKEN_TYPES.string };\n      }\n    });\n    return tokens;\n  }).flat();\n\n  return results;\n}\n\nexport function combineNearbyStrings(tokens: Token[]): Token[] {\n  const results: Token[] = tokens.reduce((acc, token) => {\n    const lastToken = acc[acc.length - 1];\n    if (lastToken?.type === TOKEN_TYPES.string && token.type === TOKEN_TYPES.string) {\n      lastToken.value = `${lastToken.value} ${token.value}`;\n      return acc;\n    }\n    return [...acc, token];\n  }, []);\n  return results;\n}\n\n/**\n * Converts text into set of rich tokens\n */\nexport function tokenizeMessage({\n  messageText,\n  mentionedUsers = [],\n  templatePrefix = USER_MENTION_PREFIX,\n}: TokenParams): Token[] {\n  // mention can be squeezed-in(no-space-between) with other mentions and urls\n  // if no users are mentioned, return the messageText as a single token\n  const partialResult = [{\n    type: TOKEN_TYPES.undetermined,\n    value: messageText,\n  }];\n\n  // order is important because we want to identify mentions first\n  // identifyMentions will return a token with type mention or undetermined\n  const partialWithMentions = identifyMentions({\n    tokens: partialResult,\n    mentionedUsers,\n    templatePrefix,\n  });\n  const partialsWithUrlsAndMentions = identifyUrlsAndStrings(partialWithMentions);\n  const result = combineNearbyStrings(partialsWithUrlsAndMentions);\n\n  return result;\n}\n\n/**\n * Don't need to use this util in DOM element since the white spaces will be kept as is,\n * but will need if the text is wrapped \\w React.Fragement or </>\n * @link https://sendbird.slack.com/archives/GPGHESTL3/p1681180484341369\n * Or!!! -> convert any space or tab in leading/trailing to nbsp\n * to preserve the leading & trailing white spaces\n */\nexport function getWhiteSpacePreservedText(text: string): string {\n  const NON_BREAKING_SPACE = '\\u00A0';\n  // Split the input string into lines\n  const lines = text.split('\\n');\n\n  // Process each line and convert leading and trailing white spaces to \"\\u00A0\"\n  const processedLines = lines.map((line) => {\n    const leadingWhitespace = line.match(/^\\s*/)?.[0] || '';\n    const trailingWhitespace = line.match(/\\s*$/)?.[0] || '';\n\n    const convertedLeadingWhitespace = leadingWhitespace.replace(/ /g, NON_BREAKING_SPACE);\n    const convertedTrailingWhitespace = trailingWhitespace.replace(/ /g, NON_BREAKING_SPACE);\n\n    return convertedLeadingWhitespace + line.trim() + convertedTrailingWhitespace;\n  });\n\n  // Combine the processed lines into a new string with \"\\n\"\n  const result = processedLines.join('\\n');\n\n  return result;\n}\n"],"names":["USER_MENTION_PREFIX","TOKEN_TYPES","string","mention","url","undetermined","getUserMentionRegex","mentionedUsers","templatePrefix_","templatePrefix","RegExp","map","u","userId","replace","join","identifyMentions","_ref","tokens","length","userMentionRegex","results","token","type","value","parts","split","part","match","matchedUser","find","user","nickname","flat","identifyUrlsAndStrings","isUrl","combineNearbyStrings","reduce","acc","lastToken","tokenizeMessage","_ref2","messageText","partialResult","partialWithMentions","partialsWithUrlsAndMentions","result","getWhiteSpacePreservedText","text","NON_BREAKING_SPACE","lines","processedLines","line","_line$match","_line$match2","leadingWhitespace","trailingWhitespace","convertedLeadingWhitespace","convertedTrailingWhitespace","trim"],"mappings":"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"}