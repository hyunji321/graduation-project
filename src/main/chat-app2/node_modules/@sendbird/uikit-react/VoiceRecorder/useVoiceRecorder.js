import { useState, useEffect, useCallback } from 'react';
import { useVoiceRecorderContext } from './context.js';
import useSendbirdStateContext from '../useSendbirdStateContext.js';
import '../consts-95d8566e.js';
import '../withSendbird.js';
import '../_rollupPluginBabelHelpers-6bb0305c.js';

// export interface UseVoiceRecorderProps extends VoiceRecorderEventHandler {
//   /**
//    * onRecordingStarted
//    * onRecordingEnded
//    */
// }
/* eslint-disable no-redeclare */
const VoiceRecorderStatus = {
  PREPARING: 'PREPARING',
  READY_TO_RECORD: 'READY_TO_RECORD',
  RECORDING: 'RECORDING',
  COMPLETED: 'COMPLETED'
};
const noop = () => {/* noop */};
const useVoiceRecorder = _ref => {
  let {
    onRecordingStarted = noop,
    onRecordingEnded = noop
  } = _ref;
  const {
    config
  } = useSendbirdStateContext();
  const {
    voiceRecord
  } = config;
  const {
    maxRecordingTime
  } = voiceRecord;
  const voiceRecorder = useVoiceRecorderContext();
  const {
    isRecordable
  } = voiceRecorder;
  const [recordedFile, setRecordedFile] = useState(null);
  const [recordingStatus, setRecordingStatus] = useState(VoiceRecorderStatus.PREPARING);
  useEffect(() => {
    if (isRecordable && recordingStatus === VoiceRecorderStatus.PREPARING) {
      setRecordingStatus(VoiceRecorderStatus.READY_TO_RECORD);
    }
  }, [isRecordable]);
  const start = useCallback(() => {
    voiceRecorder === null || voiceRecorder === void 0 ? void 0 : voiceRecorder.start({
      onRecordingStarted: () => {
        setRecordingStatus(VoiceRecorderStatus.RECORDING);
        onRecordingStarted();
        startTimer();
      },
      onRecordingEnded: audioFile => {
        setRecordingStatus(VoiceRecorderStatus.COMPLETED);
        onRecordingEnded(audioFile);
        setRecordedFile(audioFile);
        stopTimer();
      }
    });
  }, [onRecordingStarted, onRecordingEnded]);
  const stop = useCallback(() => {
    voiceRecorder === null || voiceRecorder === void 0 ? void 0 : voiceRecorder.stop();
    stopTimer();
  }, [voiceRecorder]);
  const cancel = useCallback(() => {
    stop();
    setRecordedFile(null);
  }, [voiceRecorder]);

  // Timer
  const [recordingTime, setRecordingTime] = useState(0);
  let timer = null;
  function startTimer() {
    stopTimer();
    setRecordingTime(0);
    const interval = setInterval(() => {
      setRecordingTime(prevTime => {
        const newTime = prevTime + 100;
        if (newTime > maxRecordingTime) {
          stopTimer();
        }
        return newTime;
      });
    }, 100);
    timer = interval;
  }
  function stopTimer() {
    clearInterval(timer);
    timer = null;
  }
  useEffect(() => {
    if (recordingTime > maxRecordingTime) {
      stop();
    }
  }, [recordingTime, maxRecordingTime, stop]);
  return {
    start,
    stop,
    cancel,
    recordingStatus,
    recordingTime,
    recordedFile,
    recordingLimit: maxRecordingTime
  };
};

export { VoiceRecorderStatus, useVoiceRecorder };
//# sourceMappingURL=useVoiceRecorder.js.map
