import { _ as _objectSpread2 } from './_rollupPluginBabelHelpers-6bb0305c.js';
import { OutgoingMessageStates, getOutgoingMessageState } from './utils/message/getOutgoingMessageState.js';

// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types
const SUPPORTED_MIMES = {
  IMAGE: ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/svg+xml', 'image/webp' // not supported in IE
  ],

  VIDEO: ['video/mpeg', 'video/ogg', 'video/webm', 'video/mp4'],
  AUDIO: ['audio/aac', 'audio/midi', 'audio/x-midi', 'audio/mpeg', 'audio/ogg', 'audio/opus', 'audio/wav', 'audio/webm', 'audio/3gpp', 'audio/3gpp2', 'audio/mp3']
};

/* eslint-disable no-redeclare */

const UIKitMessageTypes = {
  ADMIN: 'ADMIN',
  TEXT: 'TEXT',
  FILE: 'FILE',
  THUMBNAIL: 'THUMBNAIL',
  OG: 'OG',
  UNKNOWN: 'UNKNOWN'
};
/* eslint-disable no-redeclare */

const UIKitFileTypes = {
  IMAGE: 'IMAGE',
  AUDIO: 'AUDIO',
  VIDEO: 'VIDEO',
  GIF: 'GIF',
  VOICE: 'VOICE',
  OTHERS: 'OTHERS'
};

/* eslint-disable no-redeclare */

const SendingMessageStatus = {
  NONE: 'none',
  SUCCEEDED: 'succeeded',
  FAILED: 'failed',
  PENDING: 'pending'
};
const isTextuallyNull = text => {
  if (text === '' || text === null) {
    return true;
  }
  return false;
};
const isImage = type => SUPPORTED_MIMES.IMAGE.indexOf(type) >= 0;
const isVideo = type => SUPPORTED_MIMES.VIDEO.indexOf(type) >= 0;
const isGif = type => type === 'image/gif';
const isSupportedFileView = type => isImage(type) || isVideo(type);
const isAudio = type => SUPPORTED_MIMES.AUDIO.indexOf(type) >= 0;
const getUIKitFileTypes = () => _objectSpread2({}, UIKitFileTypes);
const getUIKitFileType = type => {
  if (isGif(type)) return UIKitFileTypes.GIF;
  if (isImage(type)) return UIKitFileTypes.IMAGE;
  if (isVideo(type)) return UIKitFileTypes.VIDEO;
  if (isAudio(type)) return UIKitFileTypes.AUDIO;
  return UIKitFileTypes.OTHERS;
};
const isSentMessage = message => message.sendingStatus === 'succeeded';
const isReadMessage = (channel, message) => getOutgoingMessageState(channel, message) === OutgoingMessageStates.READ;
// TODO: Remove channel from the params, it seems unnecessary
const isFailedMessage = message => (message === null || message === void 0 ? void 0 : message.sendingStatus) === 'failed';
const isPendingMessage = message => (message === null || message === void 0 ? void 0 : message.sendingStatus) === 'pending';
const isSentStatus = state => state === OutgoingMessageStates.SENT || state === OutgoingMessageStates.DELIVERED || state === OutgoingMessageStates.READ;
const isAdminMessage = message => {
  var _message$isAdminMessa;
  return message && ((message === null || message === void 0 ? void 0 : (_message$isAdminMessa = message.isAdminMessage) === null || _message$isAdminMessa === void 0 ? void 0 : _message$isAdminMessa.call(message)) || (message === null || message === void 0 ? void 0 : message.messageType) === 'admin');
};
const isUserMessage = message => {
  var _message$isUserMessag;
  return message && ((message === null || message === void 0 ? void 0 : (_message$isUserMessag = message.isUserMessage) === null || _message$isUserMessag === void 0 ? void 0 : _message$isUserMessag.call(message)) || (message === null || message === void 0 ? void 0 : message.messageType) === 'user');
};
const isFileMessage = message => {
  var _message$isFileMessag;
  return message && ((message === null || message === void 0 ? void 0 : (_message$isFileMessag = message.isFileMessage) === null || _message$isFileMessag === void 0 ? void 0 : _message$isFileMessag.call(message)) || (message === null || message === void 0 ? void 0 : message.messageType) === 'file');
};
const isParentMessage = message => !message.parentMessageId && !message.parentMessage && message.threadInfo !== null;
const isThreadMessage = message => !!message.parentMessageId && !!message.parentMessage;
const isOGMessage = message => {
  var _message$ogMetaData, _message$ogMetaData2, _message$ogMetaData3, _message$ogMetaData4;
  return !!(message && isUserMessage(message) && message !== null && message !== void 0 && message.ogMetaData && ((_message$ogMetaData = message.ogMetaData) !== null && _message$ogMetaData !== void 0 && _message$ogMetaData.url || (_message$ogMetaData2 = message.ogMetaData) !== null && _message$ogMetaData2 !== void 0 && _message$ogMetaData2.title || (_message$ogMetaData3 = message.ogMetaData) !== null && _message$ogMetaData3 !== void 0 && _message$ogMetaData3.description || (_message$ogMetaData4 = message.ogMetaData) !== null && _message$ogMetaData4 !== void 0 && _message$ogMetaData4.defaultImage));
};
const isTextMessage = message => isUserMessage(message) && !isOGMessage(message);
const isThumbnailMessage = message => message && isFileMessage(message) && isSupportedFileView(message.type);
const isImageMessage = message => message && isThumbnailMessage(message) && isImage(message.type);
const isVideoMessage = message => message && isThumbnailMessage(message) && isVideo(message.type);
const isGifMessage = message => message && isThumbnailMessage(message) && isGif(message.type);
const isAudioMessage = message => message && isFileMessage(message) && isAudio(message.type);
const isAudioMessageMimeType = type => /^audio\//.test(type);
const isVoiceMessage = message => {
  var _message$metaArrays$f, _message$metaArrays, _message$metaArrays$f2, _message$metaArrays$f3;
  // ex) audio/m4a OR audio/m4a;sbu_type=voice
  if (!(message && isFileMessage(message))) {
    return false;
  }
  const [mimeType, typeParameter] = message.type.split(';');
  if (!isAudioMessageMimeType(mimeType) || !typeParameter) {
    return false;
  }
  const [key, value] = typeParameter.split('=');
  if (key === 'sbu_type' && value === 'voice') {
    return true;
  }
  // ex) message.metaArrays = [{ key: 'KEY_INTERNAL_MESSAGE_TYPE', value: ['voice/m4a'] }]
  return isVoiceMessageMimeType((_message$metaArrays$f = message === null || message === void 0 ? void 0 : (_message$metaArrays = message.metaArrays) === null || _message$metaArrays === void 0 ? void 0 : (_message$metaArrays$f2 = _message$metaArrays.find(metaArray => metaArray.key === 'KEY_INTERNAL_MESSAGE_TYPE')) === null || _message$metaArrays$f2 === void 0 ? void 0 : (_message$metaArrays$f3 = _message$metaArrays$f2.value) === null || _message$metaArrays$f3 === void 0 ? void 0 : _message$metaArrays$f3[0]) !== null && _message$metaArrays$f !== void 0 ? _message$metaArrays$f : '');
};
const isVoiceMessageMimeType = type => /^voice\//.test(type);
const isEditedMessage = message => isUserMessage(message) && (message === null || message === void 0 ? void 0 : message.updatedAt) > 0;
const getUIKitMessageTypes = () => _objectSpread2({}, UIKitMessageTypes);
const getUIKitMessageType = message => {
  if (isAdminMessage(message)) return UIKitMessageTypes.ADMIN;
  if (isUserMessage(message)) {
    return isOGMessage(message) ? UIKitMessageTypes.OG : UIKitMessageTypes.TEXT;
  }
  if (isFileMessage(message)) {
    if (isThumbnailMessage(message)) {
      return UIKitMessageTypes.THUMBNAIL;
    }
    if (isVoiceMessage(message)) {
      return UIKitFileTypes.VOICE;
    }
    return UIKitMessageTypes.FILE;
  }
  return UIKitMessageTypes.UNKNOWN;
};
const getSendingMessageStatus = () => _objectSpread2({}, SendingMessageStatus);
const reducer = (accumulator, currentValue) => {
  if (Array.isArray(currentValue)) {
    return [...accumulator, ...currentValue];
  } else {
    accumulator.push(currentValue);
    return accumulator;
  }
};
const getClassName = classNames => Array.isArray(classNames) ? classNames.reduce(reducer, []).join(' ') : classNames;
const isReactedBy = (userId, reaction) => reaction.userIds.some(reactorUserId => reactorUserId === userId);
const getEmojiTooltipString = (reaction, userId, memberNicknamesMap, stringSet) => {
  let you = '';
  if (isReactedBy(userId, reaction)) {
    you = reaction.userIds.length === 1 ? stringSet.TOOLTIP__YOU : stringSet.TOOLTIP__AND_YOU;
  }
  return `${reaction.userIds.filter(reactorUserId => reactorUserId !== userId).map(reactorUserId => memberNicknamesMap.get(reactorUserId) || stringSet.TOOLTIP__UNKNOWN_USER).join(', ')}${you}`;
};
const URL_REG = /^((http|https):\/\/)?([a-z\d]+\.)+[a-z]{2,6}(\:[0-9]{1,5})?(\/[-a-zA-Z\d%_.~+&=]*)*(\?[;&a-zA-Z\d%_.~+=-]*)?(\#[-a-zA-Z\d_]*)?$/;
const isUrl = text => URL_REG.test(text);
const truncateString = (fullStr, strLen) => {
  if (!strLen) strLen = 40;
  if (fullStr === null || fullStr === undefined) return '';
  if (fullStr.length <= strLen) return fullStr;
  const separator = '...';
  const sepLen = separator.length;
  const charsToShow = strLen - sepLen;
  const frontChars = Math.ceil(charsToShow / 2);
  const backChars = Math.floor(charsToShow / 2);
  return fullStr.substr(0, frontChars) + separator + fullStr.substr(fullStr.length - backChars);
};
const copyToClipboard = text => {
  // @ts-ignore: Unreachable code error
  if (window.clipboardData && window.clipboardData.setData) {
    // Internet Explorer-specific code path to prevent textarea being shown while dialog is visible.
    // @ts-ignore: Unreachable code error
    return window.clipboardData.setData('Text', text);
  }
  if (document.queryCommandSupported && document.queryCommandSupported('copy')) {
    const textarea = document.createElement('textarea');
    textarea.textContent = text;
    textarea.style.position = 'fixed'; // Prevent scrolling to bottom of page in Microsoft Edge.
    document.body.appendChild(textarea);
    textarea.select();
    try {
      return document.execCommand('copy'); // Security exception may be thrown by some browsers.
    } catch (ex) {
      return false;
    } finally {
      document.body.removeChild(textarea);
    }
  }
  return false;
};
const getEmojiListAll = emojiContainer => {
  var _emojiContainer$emoji;
  return emojiContainer === null || emojiContainer === void 0 ? void 0 : (_emojiContainer$emoji = emojiContainer.emojiCategories) === null || _emojiContainer$emoji === void 0 ? void 0 : _emojiContainer$emoji.map(emojiCategory => emojiCategory.emojis).reduce((prevArr, currArr) => prevArr.concat(currArr), []);
};
const getEmojiMapAll = emojiContainer => {
  var _emojiContainer$emoji2;
  const emojiMap = new Map();
  emojiContainer === null || emojiContainer === void 0 ? void 0 : (_emojiContainer$emoji2 = emojiContainer.emojiCategories) === null || _emojiContainer$emoji2 === void 0 ? void 0 : _emojiContainer$emoji2.forEach(category => {
    var _category$emojis;
    category === null || category === void 0 ? void 0 : (_category$emojis = category.emojis) === null || _category$emojis === void 0 ? void 0 : _category$emojis.forEach(emoji => {
      if (emoji && emoji.key) {
        emojiMap.set(emoji.key, emoji);
      }
    });
  });
  return emojiMap;
};
const findEmojiUrl = targetKey => _ref => {
  let {
    key
  } = _ref;
  return key === targetKey;
};
const getEmojiUrl = (emojiContainer, emojiKey) => {
  var _emojiContainer$emoji3, _emojiContainer$emoji4;
  const isFindingKey = findEmojiUrl(emojiKey !== null && emojiKey !== void 0 ? emojiKey : '');
  return (emojiContainer === null || emojiContainer === void 0 ? void 0 : (_emojiContainer$emoji3 = emojiContainer.emojiCategories.find(category => category.emojis.some(isFindingKey))) === null || _emojiContainer$emoji3 === void 0 ? void 0 : (_emojiContainer$emoji4 = _emojiContainer$emoji3.emojis.find(isFindingKey)) === null || _emojiContainer$emoji4 === void 0 ? void 0 : _emojiContainer$emoji4.url) || '';
};
const getUserName = user => (user === null || user === void 0 ? void 0 : user.friendName) || (user === null || user === void 0 ? void 0 : user.nickname) || (user === null || user === void 0 ? void 0 : user.userId);
const getSenderName = message => (message === null || message === void 0 ? void 0 : message.sender) && getUserName(message === null || message === void 0 ? void 0 : message.sender);
const hasSameMembers = (a, b) => {
  if (a === b) {
    return true;
  }
  if (a == null || b == null) {
    return false;
  }
  if (a.length !== b.length) {
    return false;
  }
  const sortedA = [...a].sort();
  const sortedB = [...b].sort();
  for (let i = 0; i < sortedA.length; ++i) {
    if (sortedA[i] !== sortedB[i]) {
      return false;
    }
  }
  return true;
};
const isFriend = user => !!(user.friendDiscoveryKey || user.friendName);
const filterMessageListParams = (params, message) => {
  var _params$customTypesFi, _params$senderUserIds;
  // @ts-ignore
  if (params !== null && params !== void 0 && params.messageTypeFilter && params.messageTypeFilter !== message.messageType) {
    return false;
  }
  if ((params === null || params === void 0 ? void 0 : (_params$customTypesFi = params.customTypesFilter) === null || _params$customTypesFi === void 0 ? void 0 : _params$customTypesFi.length) > 0) {
    const customTypes = params.customTypesFilter.filter(item => item !== '*');
    // Because Chat SDK inserts '*' when customTypes is empty
    if (customTypes.length > 0 && !customTypes.includes(message.customType)) {
      return false;
    }
  }
  if (params !== null && params !== void 0 && params.senderUserIdsFilter && (params === null || params === void 0 ? void 0 : (_params$senderUserIds = params.senderUserIdsFilter) === null || _params$senderUserIds === void 0 ? void 0 : _params$senderUserIds.length) > 0) {
    var _message$isUserMessag2, _message$isFileMessag2;
    if (message !== null && message !== void 0 && (_message$isUserMessag2 = message.isUserMessage) !== null && _message$isUserMessag2 !== void 0 && _message$isUserMessag2.call(message) || message !== null && message !== void 0 && (_message$isFileMessag2 = message.isFileMessage) !== null && _message$isFileMessag2 !== void 0 && _message$isFileMessag2.call(message)) {
      var _params$senderUserIds2;
      const messageSender = message.sender || message['_sender'];
      if (!(params !== null && params !== void 0 && (_params$senderUserIds2 = params.senderUserIdsFilter) !== null && _params$senderUserIds2 !== void 0 && _params$senderUserIds2.includes(messageSender === null || messageSender === void 0 ? void 0 : messageSender.userId))) {
        return false;
      }
    } else {
      return false;
    }
  }
  if (!(params !== null && params !== void 0 && params.includeParentMessageInfo) && (message !== null && message !== void 0 && message.parentMessageId || message !== null && message !== void 0 && message.parentMessage)) {
    return false;
  }
  return true;
};
const filterChannelListParams = (params, channel, currentUserId) => {
  var _searchFilter$fields$, _searchFilter$fields, _userIdsFilter$userId, _params$customTypesFi2, _channel$name2, _params$channelUrlsFi;
  if (!(params !== null && params !== void 0 && params.includeEmpty) && (channel === null || channel === void 0 ? void 0 : channel.lastMessage) === null) {
    return false;
  }
  const searchFilter = params === null || params === void 0 ? void 0 : params.searchFilter;
  if (searchFilter !== null && searchFilter !== void 0 && searchFilter.query && ((_searchFilter$fields$ = searchFilter === null || searchFilter === void 0 ? void 0 : (_searchFilter$fields = searchFilter.fields) === null || _searchFilter$fields === void 0 ? void 0 : _searchFilter$fields.length) !== null && _searchFilter$fields$ !== void 0 ? _searchFilter$fields$ : 0) > 0) {
    const searchQuery = searchFilter.query;
    const searchFields = searchFilter.fields;
    if (searchQuery && searchFields && searchFields.length > 0) {
      if (!searchFields.some(searchField => {
        switch (searchField) {
          case 'channel_name':
            {
              var _channel$name;
              return channel === null || channel === void 0 ? void 0 : (_channel$name = channel.name) === null || _channel$name === void 0 ? void 0 : _channel$name.toLowerCase().includes(searchQuery.toLowerCase());
            }
          case 'member_nickname':
            {
              var _channel$members;
              return channel === null || channel === void 0 ? void 0 : (_channel$members = channel.members) === null || _channel$members === void 0 ? void 0 : _channel$members.some(member => member.nickname.toLowerCase().includes(searchQuery.toLowerCase()));
            }
          default:
            {
              return true;
            }
        }
      })) {
        return false;
      }
    }
  }
  const userIdsFilter = params === null || params === void 0 ? void 0 : params.userIdsFilter;
  if ((userIdsFilter === null || userIdsFilter === void 0 ? void 0 : (_userIdsFilter$userId = userIdsFilter.userIds) === null || _userIdsFilter$userId === void 0 ? void 0 : _userIdsFilter$userId.length) > 0) {
    var _channel$members2;
    const {
      includeMode,
      queryType
    } = userIdsFilter;
    const userIds = userIdsFilter.userIds;
    const memberIds = channel === null || channel === void 0 ? void 0 : (_channel$members2 = channel.members) === null || _channel$members2 === void 0 ? void 0 : _channel$members2.map(member => member.userId);
    if (!includeMode) {
      var _channel$members3;
      // exact match
      if (!userIds.includes(currentUserId)) {
        userIds.push(currentUserId); // add the caller's userId if not added already.
      }

      if ((channel === null || channel === void 0 ? void 0 : (_channel$members3 = channel.members) === null || _channel$members3 === void 0 ? void 0 : _channel$members3.length) > userIds.length) {
        return false; // userIds may contain one or more non-member(s).
      }

      if (!hasSameMembers(userIds, memberIds)) {
        return false;
      }
    } else if (userIds.length > 0) {
      // inclusive
      switch (queryType) {
        case 'AND':
          {
            if (userIds.some(userId => !memberIds.includes(userId))) {
              return false;
            }
            break;
          }
        case 'OR':
          {
            if (userIds.every(userId => !memberIds.includes(userId))) {
              return false;
            }
            break;
          }
      }
    }
  }
  if ((params === null || params === void 0 ? void 0 : params.includeEmpty) === false && (channel === null || channel === void 0 ? void 0 : channel.lastMessage) === null) {
    return false;
  }
  if ((params === null || params === void 0 ? void 0 : params.includeFrozen) === false && (channel === null || channel === void 0 ? void 0 : channel.isFrozen) === true) {
    return false;
  }
  if ((params === null || params === void 0 ? void 0 : (_params$customTypesFi2 = params.customTypesFilter) === null || _params$customTypesFi2 === void 0 ? void 0 : _params$customTypesFi2.length) > 0 && !params.customTypesFilter.includes(channel === null || channel === void 0 ? void 0 : channel.customType)) {
    return false;
  }
  if (params !== null && params !== void 0 && params.customTypeStartsWithFilter && !new RegExp(`^${params.customTypeStartsWithFilter}`).test(channel === null || channel === void 0 ? void 0 : channel.customType)) {
    return false;
  }
  if (params !== null && params !== void 0 && params.channelNameContainsFilter && !(channel !== null && channel !== void 0 && (_channel$name2 = channel.name) !== null && _channel$name2 !== void 0 && _channel$name2.toLowerCase().includes(params.channelNameContainsFilter.toLowerCase()))) {
    return false;
  }
  if (params !== null && params !== void 0 && params.nicknameContainsFilter) {
    var _channel$members4;
    const lowerCasedSubString = params.nicknameContainsFilter.toLowerCase();
    if (channel !== null && channel !== void 0 && (_channel$members4 = channel.members) !== null && _channel$members4 !== void 0 && _channel$members4.every(member => !member.nickname.toLowerCase().includes(lowerCasedSubString))) {
      return false;
    }
  }
  if ((params === null || params === void 0 ? void 0 : (_params$channelUrlsFi = params.channelUrlsFilter) === null || _params$channelUrlsFi === void 0 ? void 0 : _params$channelUrlsFi.length) > 0 && !params.channelUrlsFilter.includes(channel === null || channel === void 0 ? void 0 : channel.url)) {
    return false;
  }
  if (params !== null && params !== void 0 && params.myMemberStateFilter) {
    switch (params.myMemberStateFilter) {
      case 'joined_only':
        if ((channel === null || channel === void 0 ? void 0 : channel.myMemberState) !== 'joined') {
          return false;
        }
        break;
      case 'invited_only':
        if ((channel === null || channel === void 0 ? void 0 : channel.myMemberState) !== 'invited') {
          return false;
        }
        break;
      case 'invited_by_friend':
        if ((channel === null || channel === void 0 ? void 0 : channel.myMemberState) !== 'invited' || !isFriend(channel === null || channel === void 0 ? void 0 : channel.inviter)) {
          return false;
        }
        break;
      case 'invited_by_non_friend':
        if ((channel === null || channel === void 0 ? void 0 : channel.myMemberState) !== 'invited' || isFriend(channel === null || channel === void 0 ? void 0 : channel.inviter)) {
          return false;
        }
        break;
    }
  }
  if (params !== null && params !== void 0 && params.hiddenChannelFilter) {
    switch (params.hiddenChannelFilter) {
      case 'unhidden_only':
        if (channel !== null && channel !== void 0 && channel.isHidden || (channel === null || channel === void 0 ? void 0 : channel.hiddenState) !== 'unhidden') {
          return false;
        }
        break;
      case 'hidden_only':
        if (!(channel !== null && channel !== void 0 && channel.isHidden)) {
          return false;
        }
        break;
      case 'hidden_allow_auto_unhide':
        if (!(channel !== null && channel !== void 0 && channel.isHidden) || (channel === null || channel === void 0 ? void 0 : channel.hiddenState) !== 'hidden_allow_auto_unhide') {
          return false;
        }
        break;
      case 'hidden_prevent_auto_unhide':
        if (!(channel !== null && channel !== void 0 && channel.isHidden) || (channel === null || channel === void 0 ? void 0 : channel.hiddenState) !== 'hidden_prevent_auto_unhide') {
          return false;
        }
        break;
    }
  }
  if (params !== null && params !== void 0 && params.unreadChannelFilter) {
    switch (params.unreadChannelFilter) {
      case 'unread_message':
        if ((channel === null || channel === void 0 ? void 0 : channel.unreadMessageCount) === 0) {
          return false;
        }
        break;
    }
  }
  if (params !== null && params !== void 0 && params.publicChannelFilter) {
    switch (params.publicChannelFilter) {
      case 'public':
        if (!(channel !== null && channel !== void 0 && channel.isPublic)) {
          return false;
        }
        break;
      case 'private':
        if (channel !== null && channel !== void 0 && channel.isPublic) {
          return false;
        }
        break;
    }
  }
  if (params !== null && params !== void 0 && params.superChannelFilter) {
    switch (params.superChannelFilter) {
      case 'super':
        if (!(channel !== null && channel !== void 0 && channel.isSuper)) {
          return false;
        }
        break;
      case 'nonsuper':
        if (channel !== null && channel !== void 0 && channel.isSuper) {
          return false;
        }
        break;
    }
  }
  return true;
};
const binarySearch = (list, number) => {
  // [100, 99, 98, 97, ...]
  const pivot = Math.floor(list.length / 2);
  if (list[pivot] === number) {
    return pivot;
  }
  const leftList = list.slice(0, pivot);
  const rightList = list.slice(pivot + 1, list.length);
  if (list[pivot] > number) {
    return pivot + 1 + (rightList.length === 0 ? 0 : binarySearch(rightList, number));
  } else {
    return leftList.length === 0 ? pivot : binarySearch(leftList, number);
  }
};
// This is required when channel is displayed on channel list by filter
const getChannelsWithUpsertedChannel = (channels, channel) => {
  var _channel$lastMessage2;
  if (channels.some(ch => ch.url === (channel === null || channel === void 0 ? void 0 : channel.url))) {
    return channels.map(ch => ch.url === (channel === null || channel === void 0 ? void 0 : channel.url) ? channel : ch);
  }
  const targetIndex = binarySearch(channels.map(channel => {
    var _channel$lastMessage;
    return (channel === null || channel === void 0 ? void 0 : (_channel$lastMessage = channel.lastMessage) === null || _channel$lastMessage === void 0 ? void 0 : _channel$lastMessage.createdAt) || (channel === null || channel === void 0 ? void 0 : channel.createdAt);
  }), (channel === null || channel === void 0 ? void 0 : (_channel$lastMessage2 = channel.lastMessage) === null || _channel$lastMessage2 === void 0 ? void 0 : _channel$lastMessage2.createdAt) || (channel === null || channel === void 0 ? void 0 : channel.createdAt));
  return [...channels.slice(0, targetIndex), channel, ...channels.slice(targetIndex, channels.length)];
};
let StringObjType = /*#__PURE__*/function (StringObjType) {
  StringObjType["normal"] = "normal";
  StringObjType["mention"] = "mention";
  StringObjType["url"] = "url";
  return StringObjType;
}({});
/**
 * @deprecated
 * use modules/message/utils/tokenize instead
 */
const convertWordToStringObj = (word, _users, _template) => {
  const users = _users || [];
  const template = _template || '@'; // Use global variable
  const resultArray = [];
  const regex = RegExp(`${template}{(${users.map(user => user === null || user === void 0 ? void 0 : user.userId).join('|')})}`, 'g');
  let excutionResult;
  let lastIndex = 0;
  while ((excutionResult = regex.exec(word)) !== null) {
    const [template, userId] = excutionResult;
    const endIndex = regex.lastIndex;
    const startIndex = endIndex - template.length;
    // Normal text
    const normalText = word.slice(lastIndex, startIndex);
    resultArray.push({
      type: isUrl(normalText) ? StringObjType.url : StringObjType.normal,
      value: normalText
    });
    // Mention template
    const mentionedUser = users.find(user => (user === null || user === void 0 ? void 0 : user.userId) === userId);
    if (!mentionedUser) {
      resultArray.push({
        type: StringObjType.normal,
        value: template // because template is the origin text
      });
    } else {
      resultArray.push({
        type: StringObjType.mention,
        value: (mentionedUser === null || mentionedUser === void 0 ? void 0 : mentionedUser.nickname) || '(No name)',
        userId: userId
      });
    }
    lastIndex = endIndex;
  }
  if (lastIndex < word.length) {
    // Normal text
    const normalText = word.slice(lastIndex);
    resultArray.push({
      type: isUrl(normalText) ? StringObjType.url : StringObjType.normal,
      value: normalText
    });
  }
  return resultArray;
};
const arrayEqual = (array1, array2) => {
  if (Array.isArray(array1) && Array.isArray(array2) && array1.length === array2.length) {
    for (let i = 0; i < array1.length; i++) {
      if (array1[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
};

export { isUrl as A, isEditedMessage as B, isSentMessage as C, isFailedMessage as D, isPendingMessage as E, copyToClipboard as F, getEmojiListAll as G, getEmojiUrl as H, isReactedBy as I, getEmojiTooltipString as J, getEmojiMapAll as K, getUIKitFileType as L, getUIKitFileTypes as M, isGif as N, isThreadMessage as O, isParentMessage as P, convertWordToStringObj as Q, StringObjType as S, UIKitMessageTypes as U, getSendingMessageStatus as a, isReadMessage as b, filterMessageListParams as c, isVoiceMessage as d, isSentStatus as e, filterChannelListParams as f, getChannelsWithUpsertedChannel as g, getClassName as h, isTextuallyNull as i, arrayEqual as j, isFileMessage as k, isImageMessage as l, isThumbnailMessage as m, isAudioMessage as n, isGifMessage as o, isVideoMessage as p, isUserMessage as q, getUIKitMessageType as r, getUIKitMessageTypes as s, truncateString as t, getSenderName as u, isTextMessage as v, isOGMessage as w, isSupportedFileView as x, isVideo as y, isImage as z };
//# sourceMappingURL=index-7eb65acf.js.map
