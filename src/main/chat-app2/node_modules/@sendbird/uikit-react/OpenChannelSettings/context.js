import React__default, { useState, useEffect } from 'react';
import { OpenChannelHandler } from '@sendbird/chat/openChannel';
import useSendbirdStateContext from '../useSendbirdStateContext.js';
import { U as UserProfileProvider } from '../UserProfileContext-9cfbab4d.js';
import { u as uuidv4 } from '../uuid-1adedf62.js';
import '../withSendbird.js';
import '../_rollupPluginBabelHelpers-6bb0305c.js';
import 'prop-types';

const OpenChannelSettingsContext = /*#__PURE__*/React__default.createContext(undefined);
const OpenChannelSettingsProvider = props => {
  var _globalStore$stores, _globalStore$stores$s, _globalStore$stores2, _globalStore$stores2$, _globalStore$config, _sdk$currentUser;
  const {
    children,
    channelUrl,
    onCloseClick,
    onChannelModified,
    onBeforeUpdateChannel,
    onDeleteChannel
  } = props;

  // fetch store from <SendbirdProvider />
  const globalStore = useSendbirdStateContext();
  const sdk = globalStore === null || globalStore === void 0 ? void 0 : (_globalStore$stores = globalStore.stores) === null || _globalStore$stores === void 0 ? void 0 : (_globalStore$stores$s = _globalStore$stores.sdkStore) === null || _globalStore$stores$s === void 0 ? void 0 : _globalStore$stores$s.sdk;
  const isSDKInitialized = globalStore === null || globalStore === void 0 ? void 0 : (_globalStore$stores2 = globalStore.stores) === null || _globalStore$stores2 === void 0 ? void 0 : (_globalStore$stores2$ = _globalStore$stores2.sdkStore) === null || _globalStore$stores2$ === void 0 ? void 0 : _globalStore$stores2$.initialized;
  const logger = globalStore === null || globalStore === void 0 ? void 0 : (_globalStore$config = globalStore.config) === null || _globalStore$config === void 0 ? void 0 : _globalStore$config.logger;
  const currentUserId = sdk === null || sdk === void 0 ? void 0 : (_sdk$currentUser = sdk.currentUser) === null || _sdk$currentUser === void 0 ? void 0 : _sdk$currentUser.userId;
  const [currentChannel, setChannel] = useState(null);
  const [isChannelInitialized, setChannelInitialized] = useState(false);
  useEffect(() => {
    if (!channelUrl || !sdk.openChannel) {
      setChannel(null);
      return;
    }
    sdk.openChannel.getChannel(channelUrl).then(channel => {
      logger.info('open channel setting: fetched', channel);
      // TODO: Add pending status
      channel.enter().then(() => {
        setChannel(channel);
        logger.info('OpenChannelSettings | Succeeded to enter channel', channel === null || channel === void 0 ? void 0 : channel.url);
        setChannelInitialized(true);
      }).catch(error => {
        setChannel(null);
        logger.warning('OpenChannelSettings | Failed to enter channel', error);
      });
    }).catch(error => {
      logger.error('open channel setting: error fetching', error);
      setChannel(null);
    });
    return () => {
      if (currentChannel && currentChannel.exit) {
        currentChannel.exit().then(() => {
          logger.info('OpenChannelSettings | Succeeded to exit channel', currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url);
        }).catch(error => {
          logger.warning('OpenChannelSettings | Failed to exit channel', error);
        });
      }
    };
  }, [channelUrl, isSDKInitialized]);
  useEffect(() => {
    var _sdk$openChannel;
    const channelHandlerId = uuidv4();
    if (currentChannel !== null && sdk !== null && sdk !== void 0 && (_sdk$openChannel = sdk.openChannel) !== null && _sdk$openChannel !== void 0 && _sdk$openChannel.addOpenChannelHandler) {
      const channelHandlerParams = new OpenChannelHandler({
        onOperatorUpdated(channel) {
          if ((channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url)) {
            setChannel(channel);
          }
        },
        onUserMuted(channel, user) {
          if ((channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) && (user === null || user === void 0 ? void 0 : user.userId) === currentUserId) {
            setChannel(channel);
          }
        },
        onUserUnmuted(channel, user) {
          if ((channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) && (user === null || user === void 0 ? void 0 : user.userId) === currentUserId) {
            setChannel(channel);
          }
        },
        onUserBanned(channel, user) {
          if ((channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) && (user === null || user === void 0 ? void 0 : user.userId) === currentUserId) {
            setChannel(null);
          }
        },
        onUserUnbanned(channel, user) {
          if ((user === null || user === void 0 ? void 0 : user.userId) === currentUserId) {
            setChannel(channel);
          }
        },
        onChannelChanged(channel) {
          if ((channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url)) {
            setChannel(channel);
          }
        },
        onChannelDeleted(channelUrl) {
          if (channelUrl === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url)) {
            setChannel(null);
          }
        }
      });
      sdk.openChannel.addOpenChannelHandler(channelHandlerId, channelHandlerParams);
    }
    return () => {
      var _sdk$openChannel2;
      if (sdk !== null && sdk !== void 0 && (_sdk$openChannel2 = sdk.openChannel) !== null && _sdk$openChannel2 !== void 0 && _sdk$openChannel2.removeOpenChannelHandler && channelHandlerId) {
        var _sdk$openChannel$remo, _sdk$openChannel3;
        logger.info('OpenChannelSettings | Removing channel handlers', channelHandlerId);
        (_sdk$openChannel$remo = (_sdk$openChannel3 = sdk.openChannel).removeOpenChannelHandler) === null || _sdk$openChannel$remo === void 0 ? void 0 : _sdk$openChannel$remo.call(_sdk$openChannel3, channelHandlerId);
      }
    };
  }, [channelUrl]);
  return /*#__PURE__*/React__default.createElement(OpenChannelSettingsContext.Provider, {
    value: {
      channelUrl,
      channel: currentChannel,
      isChannelInitialized: isChannelInitialized,
      setChannel,
      onCloseClick,
      onChannelModified,
      onBeforeUpdateChannel,
      onDeleteChannel
    }
  }, /*#__PURE__*/React__default.createElement(UserProfileProvider, {
    isOpenChannel: true,
    renderUserProfile: props === null || props === void 0 ? void 0 : props.renderUserProfile,
    disableUserProfile: props === null || props === void 0 ? void 0 : props.disableUserProfile
  }, children));
};
const useOpenChannelSettingsContext = () => React__default.useContext(OpenChannelSettingsContext);

export { OpenChannelSettingsProvider, useOpenChannelSettingsContext };
//# sourceMappingURL=context.js.map
